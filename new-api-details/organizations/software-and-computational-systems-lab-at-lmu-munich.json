{
  "id": "692251e753dd9d7326d33eb4",
  "slug": "software-and-computational-systems-lab-at-lmu-munich",
  "name": "Software and Computational Systems Lab at LMU Munich",
  "category": "Programming languages",
  "description": "Algorithms and Tooling for Software Verification",
  "image_url": "https://summerofcode.withgoogle.com/media/org/software-and-computational-systems-lab-at-lmu-munich/kcrheiieoyvdm0r7-360.png",
  "img_r2_url": "https://pub-268c3a1efc8b4f8a99115507a760ca14.r2.dev/software-and-computational-systems-lab-at-lmu-munich.webp",
  "logo_r2_url": null,
  "url": "https://www.sosy-lab.org/",
  "active_years": [
    2018,
    2019,
    2023,
    2024,
    2025
  ],
  "first_year": 2018,
  "last_year": 2025,
  "is_currently_active": true,
  "technologies": [
    "python",
    "javascript",
    "java",
    "grpc",
    "Quarkus"
  ],
  "topics": [
    "software analysis",
    "software verification",
    "benchmarking",
    "smt solver",
    "result presentation",
    "program analysis",
    "formal methods",
    "SAT & SMT solving",
    "cloud"
  ],
  "total_projects": 14,
  "stats": {
    "avg_projects_per_appeared_year": 2.8,
    "projects_by_year": {
      "year_2016": null,
      "year_2017": null,
      "year_2018": 1,
      "year_2019": 2,
      "year_2020": null,
      "year_2021": null,
      "year_2022": null,
      "year_2023": 4,
      "year_2024": 3,
      "year_2025": 4
    },
    "students_by_year": {
      "year_2016": null,
      "year_2017": null,
      "year_2018": 1,
      "year_2019": 2,
      "year_2020": null,
      "year_2021": null,
      "year_2022": null,
      "year_2023": 4,
      "year_2024": 3,
      "year_2025": 4
    },
    "total_students": 14
  },
  "years": {
    "year_2016": null,
    "year_2017": null,
    "year_2018": {
      "num_projects": 1,
      "projects": [
        {
          "code_url": "https://lokeshkvn.github.io/GSoC-CPAchecker-Project/",
          "description": "<h3>CPAchecker Project -</h3>\n<ul>\n<li>Upgrade of AngularJS and other third-party libraries used.</li>\n<li>Refactoring of User Interface</li>\n<li>Writing automated tests for unit testing using Jasmine Framework.</li>\n<li>End to end testing for verification report using Protractor framework.</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_software-and-computa_2018_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4726926518255616/",
          "proposal_id": null,
          "short_description": "CPAchecker Project -\n\nUpgrade of AngularJS and other third-party libraries used.\nRefactoring of User Interface\nWriting automated tests for unit...",
          "slug": "upgrade-of-angularjs-refactoring-ui-and-automated-testing-for-cpachecker",
          "status": "completed",
          "student_name": "Lokesh Kishor Nandanwar",
          "student_profile": null,
          "tags": [
            "angular",
            "ui"
          ],
          "title": "Upgrade of AngularJS, Refactoring UI and automated testing for CPAchecker."
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2018/organizations/5139217877303296/"
    },
    "year_2019": {
      "num_projects": 2,
      "projects": [
        {
          "code_url": "https://gitlab.com/sosy-lab/software/cpachecker-intellij-plugin",
          "description": "<p>CPAChecker is a framework which can be used as a software verification tool for C programs. We can use CPAchecker locally by command line interface or in cloud by web interface. Even Though CPAchecker is good for software verification and program analysis, one developer cannot use this CPAchecker inside an IDE. This massively decreases the usability of CPAchecker. The solution for this problem is creating a plugin that can make use of CPAchecker inside the IDE.</p>\n",
          "difficulty": null,
          "id": "proj_software-and-computa_2019_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5497678564163584/",
          "proposal_id": null,
          "short_description": "CPAChecker is a framework which can be used as a software verification tool for C programs. We can use CPAchecker locally by command line interface...",
          "slug": "design-and-create-clion-plugin-for-cpachecker-execution",
          "status": "completed",
          "student_name": "Tharsanan Kurukulasingam",
          "student_profile": null,
          "tags": [
            "web",
            "cloud"
          ],
          "title": "Design and Create CLion plugin for CPAchecker execution"
        },
        {
          "code_url": "https://gitlab.com/sosy-lab/software/pqos-wrapper/wikis/Google-Summer-of-Code-2019-Report",
          "description": "<p>In this project we aim to incorporate Intel cache allocation software package (intel-cmt-cat) in BenchExec for cache allocation on a per core basis for parallel benchmarking and add pqos cli monitoring options along with OS and MSR interface support for linux systems.</p>\n",
          "difficulty": null,
          "id": "proj_software-and-computa_2019_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6098062647230464/",
          "proposal_id": null,
          "short_description": "In this project we aim to incorporate Intel cache allocation software package (intel-cmt-cat) in BenchExec for cache allocation on a per core basis...",
          "slug": "implement-cache-allocation-technology-in-benchexec",
          "status": "completed",
          "student_name": "Aditya Arora",
          "student_profile": null,
          "tags": [
            "ai",
            "ux"
          ],
          "title": "Implement Cache Allocation Technology in BenchExec"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2019/organizations/5660544999096320/"
    },
    "year_2020": null,
    "year_2021": null,
    "year_2022": null,
    "year_2023": {
      "num_projects": 4,
      "projects": [
        {
          "code_url": "https://www.sosy-lab.org/gsoc/gsoc2023.php",
          "description": "Backward bounded model checking is a technique for program analysis that aims to solve the error location reachability problem by searching for execution paths from an error location to the initial location and determining their feasibility, whereas regular forward techniques search for paths from the initial location to an error location. \n\nThe main aim of this project will be to formulate the backward bounded model checking algorithm within the framework of CPA and develop an implementation in CPAchecker. This will also require figuring out which components already provide support for backward analysis in CPAchecker and developing support where it does not already exist. Once backward analysis is supported and the algorithm is implemented, it can be tested and benchmarked on a set of programs to evaluate its performance.",
          "difficulty": null,
          "id": "proj_software-and-computa_2023_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/BqBmUDig",
          "proposal_id": "5ztB7rog",
          "short_description": "Backward bounded model checking is a technique for program analysis that aims to solve the error location reachability problem by searching for...",
          "slug": "implementing-backward-bounded-model-checking-in-cpachecker",
          "status": "completed",
          "student_name": "Bas Laarakker",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Implementing backward bounded model checking in CPAchecker"
        },
        {
          "code_url": "https://gitlab.com/sosy-lab/software/cpachecker/-/merge_requests/119",
          "description": "Formal methods have been known to be useful for verifying critical software. However, one of the main factors keeping tools such as CPA-Checker from being more widely adopted in industry is the prohibitive amount of time it takes to verify complex programs. We wish to address this by making CPAChecker scalable via divide-and-conquer and parallelization. We want to come up with a mechanical approach for decomposing verification tasks into subtasks that can verified individually. As soon as one subtask finds a violation, we abort the rest and return the violation.",
          "difficulty": "advanced",
          "id": "proj_software-and-computa_2023_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/lHNppaxZ",
          "proposal_id": "qQvMeLhX",
          "short_description": "Formal methods have been known to be useful for verifying critical software. However, one of the main factors keeping tools such as CPA-Checker from...",
          "slug": "scaling-formal-verification-parallel-analysis-of-functions",
          "status": "completed",
          "student_name": "George Granberry",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Scaling Formal Verification: Parallel Analysis of Functions"
        },
        {
          "code_url": "https://www.sosy-lab.org/gsoc/2023/reverse-cfa",
          "description": "CPAchecker now supports reachability analysis, which can search for a path from the initial program location to the error location. This project is a Proof of Concept, to implement the Backward Reachability Analysis, i.e. search for a path from the error location to the initial location. The main goal of this project is to implement a control-flow automata (CFA) transformer in CPAchecker that reverses program executions by following the transitions backward, such that for any program path in the original CFA, there is a corresponding equisatisfiable path in reverse CFA. After the transformation, the existing analysis can be applied to verify the reverse CFA, thus enabling the  Backward Reachability Analysis.",
          "difficulty": null,
          "id": "proj_software-and-computa_2023_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/GUaldtJG",
          "proposal_id": "5I6pehq9",
          "short_description": "CPAchecker now supports reachability analysis, which can search for a path from the initial program location to the error location. This project is a...",
          "slug": "reverse-program-synthesis-for-backward-reachability-analysis-in-cpachecker",
          "status": "completed",
          "student_name": "Jia Sun",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Reverse Program Synthesis for Backward Reachability Analysis in CPAchecker"
        },
        {
          "code_url": "https://juliusbrehme.github.io/GSoC_Submission/",
          "description": "SMT solvers are widely utilized in computer-guided verification of computer programs and artificial intelligence. With a multitude of theories employed in these solvers, it is beneficial to have access to a diverse range of solvers and to minimize the challenge of learning a new API for each of them. Using the solver’s own API directly makes it difficult to switch to another solver without rewriting extensive parts of the application, as there is no standardized binary API for SMT solvers. Also, since these SMT solvers have varying degrees of capabilities and performance and may not accept the same input, frameworks were created, that offer a unified API to several SMT solvers.\nJavaSMT has exactly these attributes, a common API for SMT solvers. The framework provides access to a variety of solvers created using Java and other programming languages. Although most solvers share a common set of supported theories and features, their availability of extra theories and performance may differ. Therefore, the inclusion of additional solvers in the framework is advantageous to its users.\n\nSMT formulas over the real numbers can encode a wide range of problems in theorem proving and formal verification. Such formulas are very hard to solve when nonlinear functions are involved. For that reason, the SMT solver dReal will be implemented in JavaSMT.\nThe SMT solver dReal is a solver that solves nonlinear formulas over the reals. The solver can handle various nonlinear real functions such as polynomials, trigonometric functions, exponential functions, etc. \nThe goal of the project will be to integrate the SMT solver dReal into the JavaSMT framework and to include it in the existing JavaSMT tests.",
          "difficulty": null,
          "id": "proj_software-and-computa_2023_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/nveyV1Qh",
          "proposal_id": "qWamwRRh",
          "short_description": "SMT solvers are widely utilized in computer-guided verification of computer programs and artificial intelligence. With a multitude of theories...",
          "slug": "integrating-the-smt-solver-dreal-to-the-framework-javasmt",
          "status": "completed",
          "student_name": "Julius Brehme",
          "student_profile": null,
          "tags": [
            "java",
            "api",
            "ai",
            "ui"
          ],
          "title": "Integrating the SMT solver dReal to the framework JavaSMT"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/programs/2023/organizations/software-and-computational-systems-lab-at-lmu-munich"
    },
    "year_2024": {
      "num_projects": 3,
      "projects": [
        {
          "code_url": "https://ahmedtareek.github.io/pages/GSoC2024",
          "description": "PJBDD is a Java-based, multi-threaded Binary Decision Diagram (BDD) library that facilitates concurrent computation and parallel operations. It is specifically designed to enable efficient manipulation of Boolean formulas. This project aims to introduce a new type of decision diagram that is expected to improve performance by incorporating more reduction rules than existing ones called CESRBDD( binary decision diagrams with complemented edges and edge-specified reductions).",
          "difficulty": null,
          "id": "proj_software-and-computa_2024_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/FVwqpWrT/",
          "proposal_id": null,
          "short_description": "PJBDD is a Java-based, multi-threaded Binary Decision Diagram (BDD) library that facilitates concurrent computation and parallel operations. It is...",
          "slug": "extending-pjbdd-with-cesrbdds-bdds-with-complemented-edges-and-edge-specified-reductions",
          "status": "completed",
          "student_name": "Ahmed Tarek",
          "student_profile": null,
          "tags": [
            "java",
            "ai"
          ],
          "title": "Extending PJBDD with CESRBDDs:  BDDs with Complemented Edges and Edge-Specified Reductions"
        },
        {
          "code_url": "https://www.sosy-lab.org/gsoc/2024/btor2-select/report.pdf",
          "description": "We developed the first algorithm selector, Btor2-Select, for the word-level hardware model-checking problem described in the Btor2 language. Given a Btor2 instance, Btor2-Select selects and applies the expected best verifier(s) from a pool of hardware and software tools. These decisions are based on various machine learning (ML) models, trained upon historical performance data, mapping from instance features to algorithm selections.\n\nWe proposed two embeddings for Btor2 instances: bag of keywords and bit-width aggregation. Two traditional algorithm-selection ML models, i.e., empirical hardness model and pairwise classifiers, were implemented in Btor2-Select. More importantly, we developed a novel algorithm selection and scheduling framework based on deep reinforcement learning (RL). This RL framework allows for adaptive algorithm selection throughout the solving process, leveraging dynamic information such as previous attempts and elapsed time. Upon evaluation, the adaptive algorithm selector outperformed the best non-portfolio solver (SBS) by 24.4%. Moreover, it closed 6.69% more SBS-VBS gaps than the best non-adaptive algorithm-selection method, a common performance indicator for algorithm selectors.\n\nAll the codes, experiments, and data can be found at: https://gitlab.com/sosy-lab/software/btor2-select.",
          "difficulty": null,
          "id": "proj_software-and-computa_2024_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/FGmF8gS3/",
          "proposal_id": null,
          "short_description": "We developed the first algorithm selector, Btor2-Select, for the word-level hardware model-checking problem described in the Btor2 language. Given a...",
          "slug": "adaptive-algorithm-selection-for-btor2-verification-tasks",
          "status": "completed",
          "student_name": "Zhengyang Lu",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Adaptive Algorithm Selection for Btor2 Verification Tasks"
        },
        {
          "code_url": "https://github.com/sosy-lab/benchexec/discussions/1036#discussioncomment-10452486",
          "description": "For benchmarking purposes, BenchExec typically creates a container with a file-system overlay atop the system's file system. However, due to a kernel change, this process is no longer viable for the root file system. Implementing fuse-overlayfs as an alternative overlay mechanism might resolve this issue. This entails developing a fallback mechanism for BenchExec's file-system overlay strategy: initially attempting to utilize the kernel overlayfs, and if unsuccessful, resorting to fuse-overlayfs. This approach ensures BenchExec's functionality remains intact.",
          "difficulty": null,
          "id": "proj_software-and-computa_2024_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/UzhlnEel/",
          "proposal_id": null,
          "short_description": "For benchmarking purposes, BenchExec typically creates a container with a file-system overlay atop the system's file system. However, due to a kernel...",
          "slug": "overlay-handling-with-fuse-overlayfs",
          "status": "completed",
          "student_name": "Haoran Yang",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Overlay Handling with fuse-overlayfs"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2024/organizations/software-and-computational-systems-lab-at-lmu-munich/"
    },
    "year_2025": {
      "num_projects": 4,
      "projects": [
        {
          "code_url": null,
          "description": "Problem: CPAchecker lacks robust support for exporting and validating correctness witnesses for memory safety properties (null pointers, buffer overflows), limiting independent verification of its results.\n\nSolution: \n- Implement YAML 2.0 witness export capturing ACSL \\valid predicates from SMG states.\n- Develop SMT-based validation leveraging CPAchecker’s predicate analysis.\n- Optimise configurations for validation accuracy using SV-COMP benchmarks.\n\nDeliverables:\n- Memory safety witness exporter module\n- Integrated validation pipeline with >95% accuracy\n- Test suite covering 50+ SV-COMP programs\n- Documentation on ACSL/SMG witness mapping",
          "difficulty": null,
          "id": "proj_software-and-computa_2025_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/ytzuKlC3",
          "proposal_id": "8b5RDpAB",
          "short_description": "Problem: CPAchecker lacks robust support for exporting and validating correctness witnesses for memory safety properties (null pointers, buffer...",
          "slug": "exporting-and-validating-correctness-witnesses-for-memory-safety-in-cpachecker",
          "status": "in-progress",
          "student_name": "Nupur Singhi",
          "student_profile": null,
          "tags": [
            "ml",
            "ui"
          ],
          "title": "Exporting and Validating Correctness Witnesses for Memory Safety in CPAchecker"
        },
        {
          "code_url": null,
          "description": "The growing use of large language models (LLMs) in code understanding has paved the way for significant advancements in software verification. In particular, code embeddings, such as NV-Embed and LLM2Vec, offer efficient, low-dimensional representations that can be used to improve the selection of the best-performing verifiers for various tasks. Existing approaches, such as Pesco and Graves, either rely on manually computed program features or train custom machine learning algorithms for verifier selection. This project aims to create an open-source tool that utilizes LLM-based embeddings to predict the most suitable verifier for a given task, thereby enhancing the automation of formal verification processes.\n\nThe goal of this project is to develop a command-line tool that takes a self-contained C file (preprocessed using gcc -E) along with a verification specification and recommends the most suitable verifier from a pool of SV-COMP participants. The recommendation will be based on learned predictions and presented as a ranking, classification, or regression, depending on what proves to be the most effective and feasible. To evaluate the tool's performance, results will be benchmarked against the virtually best verifier as well as established approaches like Pesco and Graves. The tool will be implemented in Python and optimized for CPU usage, making automated verifier selection more accessible, efficient, and practical on everyday hardware.",
          "difficulty": null,
          "id": "proj_software-and-computa_2025_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/RiOOLRsU",
          "proposal_id": "eOmIYm2s",
          "short_description": "The growing use of large language models (LLMs) in code understanding has paved the way for significant advancements in software verification. In...",
          "slug": "verifier-selection-using-llms",
          "status": "in-progress",
          "student_name": "Patrik Felbinger",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Verifier Selection using LLMs"
        },
        {
          "code_url": null,
          "description": "This project aims to enhance the BenchExec benchmarking framework by resolving issues with output handling and log management. Key improvements include adding timestamps to solver outputs, separating stdout and stderr, and optimizing log size management by implementing stdout/stderr pipes and buffers. The project will introduce the --timestamp option, and improve the --maxOutputSize functionality.",
          "difficulty": null,
          "id": "proj_software-and-computa_2025_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/AAnqA9dr",
          "proposal_id": "tiLSUrLQ",
          "short_description": "This project aims to enhance the BenchExec benchmarking framework by resolving issues with output handling and log management. Key improvements...",
          "slug": "timestamps-in-logs-in-benchexec",
          "status": "in-progress",
          "student_name": "Taito Ohsumi",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Timestamps in logs in BenchExec"
        },
        {
          "code_url": null,
          "description": "CPA-Daemon is a microservice (currently gRPC service) for continuous verification of C programs with CPAchecker. Clients could craft gRPC requests (with details for instructing a CPAchecker program run) sending to CPA-Daemon and receive the program-verification response.\n\nCurrent CPA-Daemon integration tests require large inputs that are difficult to read within code: c input programs, CPAchecker specifications, CPAchecker configurations[3]. So our goal in this project is \"A running integration-test suite for CPA-Daemon based on Cucumber\". \n\nWith Cucumber clear \"Given / When / Then\" semantics in writing test, we aim to reach the same or more branch coverage than the existing integration tests. Adopt Cucumber should help us easily add more test in the future.",
          "difficulty": null,
          "id": "proj_software-and-computa_2025_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/gfeHjXL3",
          "proposal_id": "fn4dzqim",
          "short_description": "CPA-Daemon is a microservice (currently gRPC service) for continuous verification of C programs with CPAchecker. Clients could craft gRPC requests...",
          "slug": "cpa-daemon-behavior-driven-tests",
          "status": "in-progress",
          "student_name": "Wenyi Shi",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "CPA-Daemon: Behavior Driven Tests"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/programs/2025/organizations/software-and-computational-systems-lab-at-lmu-munich"
    }
  },
  "first_time": false,
  "contact": {
    "email": "info@sosy-lab.org",
    "guide_url": "https://www.sosy-lab.org/gsoc/gsoc2025.php#instructions",
    "ideas_url": "https://www.sosy-lab.org/gsoc/gsoc2025.php",
    "irc_channel": null,
    "mailing_list": null
  },
  "social": {
    "blog": null,
    "discord": null,
    "facebook": null,
    "github": null,
    "gitlab": null,
    "instagram": null,
    "linkedin": null,
    "mastodon": null,
    "medium": null,
    "reddit": null,
    "slack": null,
    "stackoverflow": null,
    "twitch": null,
    "twitter": null,
    "youtube": null
  },
  "meta": {
    "version": 1,
    "generated_at": "2026-01-25T15:28:54.228Z"
  }
}