{
  "id": "692251cf53dd9d7326d33d6b",
  "slug": "cncf",
  "name": "CNCF",
  "category": "Data",
  "description": "Building sustainable ecosystems for cloud native",
  "image_url": "https://summerofcode.withgoogle.com/media/org/cncf/jmxijrttlucfutel-360.png",
  "img_r2_url": "https://pub-268c3a1efc8b4f8a99115507a760ca14.r2.dev/cncf.webp",
  "logo_r2_url": null,
  "url": "https://cncf.io",
  "active_years": [
    2017,
    2018,
    2019,
    2020,
    2021,
    2022,
    2023,
    2024,
    2025
  ],
  "first_year": 2017,
  "last_year": 2025,
  "is_currently_active": true,
  "technologies": [
    "prometheus",
    "go",
    "kubernetes",
    "fluentd",
    "grpc",
    "golang",
    "docker",
    "rust",
    "cloud",
    "service mesh",
    "OpenTelemetry",
    "envoy"
  ],
  "topics": [
    "monitoring",
    "cloud",
    "tracing",
    "logging",
    "cloud native",
    "container",
    "containers",
    "web",
    "devops",
    "kubernetes",
    "service mesh",
    "cloud computing",
    "observability"
  ],
  "total_projects": 113,
  "stats": {
    "avg_projects_per_appeared_year": 12.56,
    "projects_by_year": {
      "year_2016": null,
      "year_2017": 6,
      "year_2018": 7,
      "year_2019": 15,
      "year_2020": 17,
      "year_2021": 16,
      "year_2022": 16,
      "year_2023": 14,
      "year_2024": 11,
      "year_2025": 11
    },
    "students_by_year": {
      "year_2016": null,
      "year_2017": 6,
      "year_2018": 7,
      "year_2019": 15,
      "year_2020": 17,
      "year_2021": 16,
      "year_2022": 16,
      "year_2023": 14,
      "year_2024": 11,
      "year_2025": 11
    },
    "total_students": 113
  },
  "years": {
    "year_2016": null,
    "year_2017": {
      "num_projects": 6,
      "projects": [
        {
          "code_url": "https://github.com/nikhita/gsoc-meta-k8s",
          "description": "<p>ThirdPartyResources are already available but the implementation has languished with multiple outstanding capabilities that are missing. They did not complete the list of requirements for graduating to beta.</p>\n<p>Hence, there are multiple problems present in the current implementation of ThirdPartyResources. This project aims at working towards a number of known shortcomings to drive the ongoing effort toward a stable TPR release forward.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2017_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/5736684469616640/",
          "proposal_id": null,
          "short_description": "ThirdPartyResources are already available but the implementation has languished with multiple outstanding capabilities that are missing. They did not...",
          "slug": "improve-third-party-resources",
          "status": "completed",
          "student_name": "Nikhita Raghunath",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Improve Third Party Resources"
        },
        {
          "code_url": "https://github.com/opentracing-contrib/go-restful",
          "description": "<p><code>go-restful</code>（<a href=\"https://github.com/emicklei/go-restful）is\" target=\"_blank\">https://github.com/emicklei/go-restful）is</a> a widely-used library for building REST-style Web Services using Google Go. With powerful built-in modules including intelligent request routing, RESTful support and \nfilters for intercepting HTTP request, go-restful make it very convenient to build a web application from scratch. This proposal aims at instrumenting OpenTracing with go-restful.</p>\n<p>With OpenTracing instrumentation, go-restful web app developers can add (or switch) tracing \nimplementations with an O(1) configuration change. More important, because OpenTracing is \ninstrumented at go-restful library, a low enough level in the software stack, even large \nweb application could be traced without additional annotations, application programmers \nalso does not need to be aware of the tracing system.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2017_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/5449224187543552/",
          "proposal_id": null,
          "short_description": "go-restful（https://github.com/emicklei/go-restful）is a widely-used library for building REST-style Web Services using Google Go. With powerful...",
          "slug": "instrument-opentracing-with-go-restful-web-framework",
          "status": "completed",
          "student_name": "MINGQIANG LIANG",
          "student_profile": null,
          "tags": [
            "web",
            "ai",
            "ui"
          ],
          "title": "instrument OpenTracing with go-restful web framework"
        },
        {
          "code_url": "https://github.com/amitkumarj441/gsoc17-cncf",
          "description": "<p>This project aims to build and implement a Data model for logs in a large kubernetes cluster to process, correlate and query to make the troubleshooting easier and can reduce the time in finding root causes.</p>\n<p>The objective of this proposal is to twofold.</p>\n<ol>\n<li>Build on the <a href=\"https://github.com/ViaQ/elasticsearch-templates\" target=\"_blank\">existing</a> work on Data model from Red Hat and others in the open source community, demonstrate the work and identify any gaps. </li>\n<li>To enhance the data model to based on the gaps.</li>\n</ol>\n",
          "difficulty": null,
          "id": "proj_cncf_2017_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/5112703567790080/",
          "proposal_id": null,
          "short_description": "This project aims to build and implement a Data model for logs in a large kubernetes cluster to process, correlate and query to make the...",
          "slug": "create-and-implement-a-data-model-to-standardize-kubernetes-logs",
          "status": "completed",
          "student_name": "Amit Kumar Jaiswal",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "Create and implement a Data model to standardize Kubernetes logs"
        },
        {
          "code_url": "https://drive.google.com/file/d/0B6nvUsp4JxeCenByOXpuSm5tMGc/view?usp=sharing",
          "description": "<h3>The project</h3>\n<p>The goal is to capture the DNS data within a CoreDNS middleware and write it to a \"dnstap log file\" (prehaps over the network)</p>\n<h4>Steps</h4>\n<p>I can see from <a href=\"https://godoc.org/github.com/coredns/coredns/middleware/whoami\" target=\"_blank\"><code>middleware/whoami</code></a> that the message is to be constructed inside a <code>middleware.Handler</code> interface, from the parameters passed in <code>ServeDNS(context.Context, dns.ResponseWriter, *dns.Msg) (int, error)</code>, especially from <code>*dns.Msg</code>.</p>\n<p>The message is in fact a <code>dnstap.Message</code> nested within a <code>dnstap.Dnstap</code> structure which is <em>(satisfies)</em> a Protocol Buffer <code>proto.Message</code> to be marshalled by <code>proto.Marshal</code>.</p>\n<p>The serialized data can then be streamed over the network using the <code>dnstap.FrameStreamOutput</code>/<code>dnstap.FrameStreamInput</code> structures.</p>\n<p>In fact, according to <a href=\"https://github.com/dnstap/golang-dnstap/blob/master/dnstap/main.go\" target=\"_blank\">this</a>: encoding the serialized data with <code>dnstap.FrameStreamOutput</code>, and writing the output to a socket <em>(<code>dnstap.sock</code>)</em>, is enough to use the <a href=\"http://dnstap.info/Examples/\" target=\"_blank\">dnstap command-line tool</a>, for example: <code>dnstap -u dnstap.sock</code>.</p>\n<p>The log file can then be generated using: <code>dnstap -u dnstap.sock -w log.dnstap</code>.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2017_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/5269744752001024/",
          "proposal_id": null,
          "short_description": "The project\nThe goal is to capture the DNS data within a CoreDNS middleware and write it to a \"dnstap log file\" (prehaps over the network)\nSteps\nI...",
          "slug": "dnstap-middleware",
          "status": "completed",
          "student_name": "Antoine D.",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "dnstap Middleware"
        },
        {
          "code_url": "https://docs.google.com/document/d/1hkzasAlzqpRQAIZTChELLFsce4-HyQvnypQOjCjYlPE/edit?usp=sharing",
          "description": "<p>The Kubernetes python client is a Kubernetes incubator project. The python client makes it possible to access Kubernetes with python. Jupyter notebook extends the console-based approach to interactive computing in a qualitatively new direction, providing a web-based application suitable for capturing the whole computation process. The aim of this project is to develop a set of notebooks that highlight the Kubernetes primitives. This project would also include updating the python client to make it easier for users to carry out certain operations.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2017_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/6048005979373568/",
          "proposal_id": null,
          "short_description": "The Kubernetes python client is a Kubernetes incubator project. The python client makes it possible to access Kubernetes with python. Jupyter...",
          "slug": "develop-a-set-of-jupyter-notebooks-for-the-kubernetes-python-client-kubernetes-python-client-update",
          "status": "completed",
          "student_name": "Konrad Djimeli",
          "student_profile": null,
          "tags": [
            "python",
            "web",
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "Develop a set of Jupyter Notebooks for the Kubernetes Python Client + Kubernetes Python Client update"
        },
        {
          "code_url": "https://gist.github.com/Crazykev/bd9d0fbb7d41aa8c12cbd2c450cfa319",
          "description": "<p>The main idea of this proposal is <em>Why</em> and <em>How</em> we integrate <strong>unikernel</strong> as a runtime into <strong>kubernetes/frakti</strong> project, so that kubernetes could use unikernel instance just like use docker, which eventually make kubernetes play a role in more application scenarios. If you are not familar with these two words, here is a brief introduction.</p>\n<p><strong>Unikernel</strong> are specialised, single-address-space machine images constructed by using library operating systems. You can consider it as a virtual machine but only has a special OS compiled with your applications binaries. Unikernels are considered as the future infrastructure of IoT and cloud system. And already show great potential in NFV, serverless and immutable infrastructure.</p>\n<p><strong>Frakti</strong> is an official Kubernetes sub-project which is a well-designed CRI implementation for hypervisor-based runtimes. It now support hypervisor container as well as mixed container runtimes (e.g. Docker + HyperContainer)on same node.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2017_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/5962288766910464/",
          "proposal_id": null,
          "short_description": "The main idea of this proposal is Why and How we integrate unikernel as a runtime into kubernetes/frakti project, so that kubernetes could use...",
          "slug": "integrate-unikernel-runtime",
          "status": "completed",
          "student_name": "Hao Zhang",
          "student_profile": null,
          "tags": [
            "ios",
            "ai",
            "docker",
            "kubernetes",
            "cloud"
          ],
          "title": "Integrate Unikernel Runtime"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2017/organizations/6018829461225472/"
    },
    "year_2018": {
      "num_projects": 7,
      "projects": [
        {
          "code_url": "https://docs.google.com/document/d/1rB-RqaRTelqH8mGeR_6uKlElxCJ06TW28scYKNtgsPI/edit?usp=sharing",
          "description": "<p>The project aims at creating a containerd-kata runtime plugin for containerd to integrate it with katacontainers. The integration enables containerd and its users (docker&amp;kubernetes) to enjoy security and multi-tenancy brought by KataConainers as well as native Linux container experience brought by the existing containerd runtime plugin <code>linux</code> .</p>\n<p>Containerd is an industry-standard container runtime with an emphasis on simplicity, robustness and portability. It can manage the complete container lifecycle of its host system: image transfer and storage, container execution and supervision, low-level storage and network attachments, etc.</p>\n<p>Kata Containers is an open source project and community working to build a standard implementation of lightweight Virtual Machines (VMs) that feel and perform like containers, but provide the workload isolation and security advantages of VMs.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2018_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6403629539917824/",
          "proposal_id": null,
          "short_description": "The project aims at creating a containerd-kata runtime plugin for containerd to integrate it with katacontainers. The integration enables containerd...",
          "slug": "integrate-containerd-with-katacontainers",
          "status": "completed",
          "student_name": "Jian Liu",
          "student_profile": null,
          "tags": [
            "ai",
            "docker",
            "kubernetes",
            "ui",
            "ux"
          ],
          "title": "Integrate Containerd with Katacontainers"
        },
        {
          "code_url": "https://sipian.github.io/blogs/google-summer-of-code-with-prometheus.html",
          "description": "<p>My project aims to benchmark Prometheus &amp; test Prometheus’s Kubernetes &amp; Consul Service Discovery in an automated &amp; real-time environment.\nThis will help in recognizing bugs before confirming new releases and will also confirm the robustness of new releases.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2018_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6728419798679552/",
          "proposal_id": null,
          "short_description": "My project aims to benchmark Prometheus & test Prometheus’s Kubernetes & Consul Service Discovery in an automated & real-time environment.\nThis will...",
          "slug": "building-a-testing-benchmarking-environment-for-prometheus",
          "status": "completed",
          "student_name": "Harsh_Agarwal",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "Building a testing & benchmarking environment for Prometheus"
        },
        {
          "code_url": "https://github.com/rohan47/gsoc2018-cncf-rook/",
          "description": "<p>Rook is an open source orchestrator for distributed storage systems running in kubernetes, currently in alpha state and has focused initially on orchestrating Ceph on top of Kubernetes. There is no option for Network File System (NFS) yet.\nThis project aims to add NFS as another storage backend.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2018_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5713541642321920/",
          "proposal_id": null,
          "short_description": "Rook is an open source orchestrator for distributed storage systems running in kubernetes, currently in alpha state and has focused initially on...",
          "slug": "add-network-file-system-nfs-as-a-rook-storage-backend",
          "status": "completed",
          "student_name": "Rohan Gupta",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "backend"
          ],
          "title": "Add Network File System (NFS) as a Rook storage backend"
        },
        {
          "code_url": "http://www.anirudhm.com/blog/gsoc-2018/",
          "description": "<p>Envoy is getting fuzz testing support. The coverage is limited. This project focuses on extending the fuzz coverage including proto, data plane, H2 level frame fuzzing.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2018_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5597459212402688/",
          "proposal_id": null,
          "short_description": "Envoy is getting fuzz testing support. The coverage is limited. This project focuses on extending the fuzz coverage including proto, data plane, H2...",
          "slug": "extending-envoys-fuzzing-coverage",
          "status": "completed",
          "student_name": "Anirudh M",
          "student_profile": null,
          "tags": [],
          "title": "Extending Envoy's fuzzing coverage"
        },
        {
          "code_url": "https://ganeshvernekar.com/gsoc-2018/",
          "description": "<p>Alerting is an important feature in monitoring when it comes to maintaining site reliability, and Prometheus is being used widely for this. Hence it becomes very important to be able to check the correctness of the alerting rules. Prometheus lacks any good and convenient way of visualising and testing the alert rules before it can be used.</p>\n<p>There are many long standing issues and feature requests regarding the above, and many others, and my GSoC aims to solve some of them.</p>\n<h4>Deliverables</h4>\n<h6>From <a href=\"https://github.com/cncf/soc#prometheus\" target=\"_blank\">cncf/soc</a></h6>\n<ul>\n<li>Persist “for” state for alerts [<a href=\"https://github.com/prometheus/prometheus/issues/422\" target=\"_blank\">1</a>]</li>\n<li>Label Values Composite Index (TSDB) [<a href=\"https://github.com/prometheus/tsdb/issues/26\" target=\"_blank\">1</a>]</li>\n<li>Unit testing for alerts in promtool  [<a href=\"https://github.com/prometheus/prometheus/issues/1695\" target=\"_blank\">1</a>]</li>\n<li>Features for building and testing alert expressions [<a href=\"https://github.com/prometheus/prometheus/issues/1154\" target=\"_blank\">1</a>] [<a href=\"https://github.com/prometheus/prometheus/issues/1220\" target=\"_blank\">2</a>]</li>\n</ul>\n<h6>Nice to have</h6>\n<ul>\n<li>More features in TSDB CLI for easy debugging [<a href=\"https://github.com/prometheus/tsdb/issues/107\" target=\"_blank\">1</a>]</li>\n</ul>\n",
          "difficulty": "beginner",
          "id": "proj_cncf_2018_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4516877250330624/",
          "proposal_id": null,
          "short_description": "Alerting is an important feature in monitoring when it comes to maintaining site reliability, and Prometheus is being used widely for this. Hence it...",
          "slug": "composite-label-indices-alerts-rule-testing",
          "status": "completed",
          "student_name": "Ganesh Vernekar",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Composite Label Indices & Alerts rule testing"
        },
        {
          "code_url": "https://github.com/jiachengxu/idetcd",
          "description": "<p>In distributed TensorFlow, identifying the nodes without domain name collision is a big challenge. CoreDNS supports DNS Name Server Identifier (NSID) which allow a DNS server to identify itself. So we can deploy CoreDNS for every node in the distributed TensorFlow cluster to solve this problem. There are two ways to achieve this goal. One way is to set up a distributed Key-Value store like zookeeper or etcd, and another way is to assign each node with an order based on the timestamp. My GSoc work aims to implement one of the approaches above.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2018_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4869116712189952/",
          "proposal_id": null,
          "short_description": "In distributed TensorFlow, identifying the nodes without domain name collision is a big challenge. CoreDNS supports DNS Name Server Identifier (NSID)...",
          "slug": "conditional-name-server-identifier-coredns",
          "status": "completed",
          "student_name": "Jiacheng Xu",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Conditional Name Server Identifier - CoreDNS"
        },
        {
          "code_url": "https://github.com/xmudrii/etcdproxy-controller",
          "description": "<p>Kubernetes offers two ways to  extend the core API, by using the CustomResourceDefinitons or by setting up an aggregated API server. This ensures users don’t need to modify the core API in order to add the features needed for their workflow, which later ensures the more stable and secure core API.</p>\n<p>One missing part is how to efficiently store data used by aggregated API servers. This project implements a Storage API, with a main goal to share the cluster’s main etcd server with the Aggregated API Servers, allowing it to use cluster’s main etcd  just like it would use it’s own etcd server.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2018_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5952269212188672/",
          "proposal_id": null,
          "short_description": "Kubernetes offers two ways to  extend the core API, by using the CustomResourceDefinitons or by setting up an aggregated API server. This ensures...",
          "slug": "storage-api-for-aggregated-api-servers",
          "status": "completed",
          "student_name": "Marko Mudrinić",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "kubernetes"
          ],
          "title": "Storage API for Aggregated API Servers"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2018/organizations/4800404952973312/"
    },
    "year_2019": {
      "num_projects": 15,
      "projects": [
        {
          "code_url": "https://apg258.github.io/gsoc/2019/08/16/gsoc-2019.html",
          "description": "<p>rkt implements the App Container Executor specification of the appc Container Specification and uses systemd unit properties to implement its features. To implement the OCI runtime spec, systemd unit properties are not suitable since they differ from what the spec defines. The idea is to replace systemd unit properties by runc to implement the OCI runtime spec.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6333611203100672/",
          "proposal_id": null,
          "short_description": "rkt implements the App Container Executor specification of the appc Container Specification and uses systemd unit properties to implement its...",
          "slug": "add-support-for-the-oci-runtime-spec-by-implementing-a-runc-stage2",
          "status": "completed",
          "student_name": "Alejandro Germain",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Add support for the OCI runtime spec by implementing a runc stage2"
        },
        {
          "code_url": "https://github.com/k8s-gpu-allocator/GSoC2019",
          "description": "<p>We would like to propose a improvement on current Kubernetes topology manager to become aware of generic hardware device topology at node level, so Deep Learning training can be improved significantly due to data inter-connection between NVIDIA GPU devices on the node.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6336863634194432/",
          "proposal_id": null,
          "short_description": "We would like to propose a improvement on current Kubernetes topology manager to become aware of generic hardware device topology at node level, so...",
          "slug": "kubernetes-with-hardware-devices-topology-awareness-at-node-level",
          "status": "completed",
          "student_name": "Junjun LI",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes"
          ],
          "title": "Kubernetes with hardware devices topology awareness at node level"
        },
        {
          "code_url": "https://github.com/mLavacca/falco-tracing-framework",
          "description": "<p>The outcome of this project has been the development of a tracing framework that allows to measure and monitor some Falco internal metrics (counter and latency), such as the flowchart of all the possible stack traces that can be generated by Falco (with the metrics for every function) and the rules check metrics. At the end of the GSOC period, this tool has been used for creating a report of Falco performances.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6404259405365248/",
          "proposal_id": null,
          "short_description": "The outcome of this project has been the development of a tracing framework that allows to measure and monitor some Falco internal metrics (counter...",
          "slug": "falco-engine-performance-analysis-and-optimization",
          "status": "completed",
          "student_name": "Mattia Lavacca",
          "student_profile": null,
          "tags": [],
          "title": "Falco engine performance analysis and optimization"
        },
        {
          "code_url": "https://docs.google.com/document/d/1pMWbiZrnVQmwg9KtyJo6sepTH6wdPnLe1DiZRC2WI0w/edit?usp=sharing",
          "description": "<p>A common use case for regex matchers is to use them to query all series matching a set of label values, e.g. up{instance=~\"foo|bar|baz\"}. Grafana's template variables feature is a big user of that pattern. We could catch and split it into 3 different matchers, each selecting the three cases. This would make the templated queries produced by Grafana much faster.\nPostings is a lists of numbers which are references to series that contain a given label pair. They are used as a reference table to get the requested series. The project is to research and implement some compression.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5513478607994880/",
          "proposal_id": null,
          "short_description": "A common use case for regex matchers is to use them to query all series matching a set of label values, e.g. up{instance=~\"foo|bar|baz\"}. Grafana's...",
          "slug": "prometheus-optimize-queries-using-regex-matchers-for-set-lookups-postings-compression",
          "status": "completed",
          "student_name": "Zhiqi WANG",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Prometheus - Optimize queries using regex matchers for set lookups & Postings compression"
        },
        {
          "code_url": "https://gist.github.com/gman0/ab1c40a7b6e6ae52d610cbfeabdf0bfa",
          "description": "<p>OpenStack Manila manages shared file-systems across the cloud. Being able to create and access them with ease from the container world is showing to be quite useful - that’s what csi-manila is for. One of the features that’s also in high demand when dealing with shared file-systems is taking snapshots as well as creating new shares from those snapshots from within Container Orchestrators like Kubernetes. csi-manila itself is quite a new piece of software and is missing certain features, like snapshots for an instance. This GSoC project will try to close this feature gap.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5574535259095040/",
          "proposal_id": null,
          "short_description": "OpenStack Manila manages shared file-systems across the cloud. Being able to create and access them with ease from the container world is showing to...",
          "slug": "implement-volume-snapshotting-support-into-the-external-manila-provisioner",
          "status": "completed",
          "student_name": "Róbert Vašek",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "cloud",
            "ui"
          ],
          "title": "Implement volume snapshotting support into the external Manila provisioner"
        },
        {
          "code_url": "https://github.com/open-policy-agent/contrib/tree/master/opa-iptables",
          "description": "<p>This project involves designing the layout of IPTable rules using OPA's policy language Rego, implementing the algorithms that generate IPTables from that policy, and writing the code that populates the generated IPTables rules into Linux host.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6201904034480128/",
          "proposal_id": null,
          "short_description": "This project involves designing the layout of IPTable rules using OPA's policy language Rego, implementing the algorithms that generate IPTables from...",
          "slug": "iptables-integration-with-open-policy-agentopa",
          "status": "completed",
          "student_name": "Urvil Patel",
          "student_profile": null,
          "tags": [
            "ux"
          ],
          "title": "IPTables Integration with  OPEN POLICY AGENT(OPA)"
        },
        {
          "code_url": "https://medium.com/@sahriyarm/google-summer-of-code-2019-final-report-cncf-meshery-80a4693fe292",
          "description": "<p>Benchmarks continuously strive to improve performance standards in order to stay relevant in the market and playing important role for having better customer loyalty, SEO ranking and more. Meanwhile there are various factors affecting performance, having high performant proxy in front of webservers is one of important which could be achieved by continuous performance measurements and improvements.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6211205507579904/",
          "proposal_id": null,
          "short_description": "Benchmarks continuously strive to improve performance standards in order to stay relevant in the market and playing important role for having better...",
          "slug": "multi-mesh-performance-benchmark-tool",
          "status": "completed",
          "student_name": "Shahriyar Mammadov",
          "student_profile": null,
          "tags": [
            "web"
          ],
          "title": "Multi-mesh performance benchmark tool"
        },
        {
          "code_url": "https://geekodour.xyz/post/gsoc19/",
          "description": "<p>Prombench the benchmarking tool for Prometheus will be extended to support even more tests, newer components, metrics which will help both developers and users in terms of identifying bugs and scalability tests. Another task the proposal aims to solve is the longstanding issue of Prometheus rule formatting.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/4610665543630848/",
          "proposal_id": null,
          "short_description": "Prombench the benchmarking tool for Prometheus will be extended to support even more tests, newer components, metrics which will help both developers...",
          "slug": "extending-prombench-and-adding-rule-formatting-for-prometheus",
          "status": "completed",
          "student_name": "Hrishikesh Barman",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Extending Prombench and adding rule formatting for Prometheus"
        },
        {
          "code_url": "https://github.com/pentium3/AutoTiKV",
          "description": "<p>Using machine learning method to tune database configurations automatically</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/4737753357484032/",
          "proposal_id": null,
          "short_description": "Using machine learning method to tune database configurations automatically",
          "slug": "proposal-for-auto-tune-rocksdb",
          "status": "completed",
          "student_name": "Yuanli Wang",
          "student_profile": null,
          "tags": [
            "database"
          ],
          "title": "Proposal for Auto-tune RocksDB"
        },
        {
          "code_url": "https://github.com/ihac/acl",
          "description": "<p>When CoreDNS serves DNS queries publicly or inside Kubernetes clusters, the source IP of the incoming DNS query is an important identity. For security considerations, only certain queries (from specific source-IP or CIDR block) should be allowed to prevent the server from being attacked. The goal of this project is to support a firewall-like source-IP based block/allow mechanism for CoreDNS. With our plugin (named as firewall) enabled, users are able to define ACLs  for any DNS queries, i.e. allowing authorized queries to recurse or blocking unauthorized queries towards protected DNS zones.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/4786589752885248/",
          "proposal_id": null,
          "short_description": "When CoreDNS serves DNS queries publicly or inside Kubernetes clusters, the source IP of the incoming DNS query is an important identity. For...",
          "slug": "support-source-ip-based-query-blockallow-in-coredns",
          "status": "completed",
          "student_name": "An Xiao",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes"
          ],
          "title": "Support Source IP Based Query Block/Allow in CoreDNS"
        },
        {
          "code_url": "https://ajatprabha.github.io/gsoc-meta-k8s/",
          "description": "<p>This project aims to introduce a plugin mechanism to the Kubernetes Dashboard. It shall deal with defining the plugin framework architecture, it’s scope, how it could enhance the Dashboard UI and make it possible to utilize third party APIs to extend its functionality.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6552345297551360/",
          "proposal_id": null,
          "short_description": "This project aims to introduce a plugin mechanism to the Kubernetes Dashboard. It shall deal with defining the plugin framework architecture, it’s...",
          "slug": "add-plugin-mechanism-to-the-dashboard",
          "status": "completed",
          "student_name": "Ajat Prabha",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "Add Plugin Mechanism to the Dashboard"
        },
        {
          "code_url": "https://github.com/Sakuralbj/CNCF-GSoC/blob/master/README.md",
          "description": "<p>GPUSharing is an open source project which could share GPU  by leveraging Kubernetes scheduling and Device Plugin extensibility.I would like to integrate it with kubeflow/arena.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5857894333939712/",
          "proposal_id": null,
          "short_description": "GPUSharing is an open source project which could share GPU  by leveraging Kubernetes scheduling and Device Plugin extensibility.I would like to...",
          "slug": "run-gpu-sharing-workloads-with-kubernetes-kubeflow",
          "status": "completed",
          "student_name": "Jianbo Ma",
          "student_profile": null,
          "tags": [
            "kubernetes"
          ],
          "title": "Run GPU sharing workloads with Kubernetes + Kubeflow"
        },
        {
          "code_url": "https://github.com/eloyekunle/gsoc-2019-meta-k8s",
          "description": "<p>The Kubernetes dashboard previously supported Third Party Resources (TPR), but these were replaced in Kubernetes by Custom Resource Definitions (CRD). As a result, the original TPR support was removed in Dashboard, but CRD support has not been added yet.\nThis proposal aims at providing a generic support for Custom Resource Definitions to the dashboard, similar to the previous TPR support.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5962909421666304/",
          "proposal_id": null,
          "short_description": "The Kubernetes dashboard previously supported Third Party Resources (TPR), but these were replaced in Kubernetes by Custom Resource Definitions...",
          "slug": "add-support-for-custom-resource-definitions-to-the-dashboard",
          "status": "completed",
          "student_name": "Elijah Oyekunle",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes"
          ],
          "title": "Add Support for Custom Resource Definitions to the Dashboard"
        },
        {
          "code_url": "https://github.com/giovanism/gsoc-2019-rook/",
          "description": "<p>This project aims to create new API to enable multiple network interface for Rook storage providers. Currently, Rook providers only choice is to use hostNetwork or not. The new API will be used to define networks resource for Rook clusters. Rook operators will be able to consume those definitions and manage them. Therefore, it enables more fine-grained control over storage providers network access.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2019_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5963949340622848/",
          "proposal_id": null,
          "short_description": "This project aims to create new API to enable multiple network interface for Rook storage providers. Currently, Rook providers only choice is to use...",
          "slug": "enable-multiple-network-interfaces-for-rook-storage-providers",
          "status": "completed",
          "student_name": "Giovan Isa Musthofa",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Enable multiple network interfaces for Rook storage providers"
        },
        {
          "code_url": "https://medium.com/@masarik.vladimir7/report-google-summer-of-code-2019-866d1fc5a71e",
          "description": "<p>It is better to discover performance problems sooner than later, but this is even more important if we are talking about a database. The newly introduced performance flaws are hard to notice, and the process of discovering them is cumbersome if done manually. Since Prometheus TSDB does not have such a feature yet, this project should be the solution. Meaning, the plan is to develop detailed performance tests and automate the process of testing using Prow, the Kubernetes based CI/CD system with GitHub integration. Moreover, for easy analysis, the results of the benchmarked pull request will be compared against the master branch test results. Fortunately, the foundation for implementing the benchmarks partially exists, and so do some benchmarking tests, which means an excellent start for the project.</p>\n",
          "difficulty": "beginner",
          "id": "proj_cncf_2019_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5218130282938368/",
          "proposal_id": null,
          "short_description": "It is better to discover performance problems sooner than later, but this is even more important if we are talking about a database. The newly...",
          "slug": "github-integrated-benchmarking-tool-for-prometheus-tsdb",
          "status": "completed",
          "student_name": "Vladimir Masarik",
          "student_profile": null,
          "tags": [
            "ai",
            "database",
            "kubernetes"
          ],
          "title": "GitHub integrated benchmarking tool for Prometheus TSDB"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2019/organizations/6034778267058176/"
    },
    "year_2020": {
      "num_projects": 17,
      "projects": [
        {
          "code_url": "https://docs.google.com/document/d/1-7DlMNlindlwx54cehqqGZAgqdJCmLyl9mWOWkI4-9I/edit?usp=sharing",
          "description": "<p>A cloud computing is a set of huge networks and computing nodes, where enormous amount of data flow takes place. An efficient performance is needed along with security to access and store data.\n    In order to meet the availability and confidentiality properties with performance, is the backbone of any computing system and is the basic expectation of a vendor from its providers in Cloud computing environment.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5649719642030080/",
          "proposal_id": null,
          "short_description": "A cloud computing is a set of huge networks and computing nodes, where enormous amount of data flow takes place. An efficient performance is needed...",
          "slug": "cloud-storage",
          "status": "completed",
          "student_name": "Furqan Munir",
          "student_profile": null,
          "tags": [
            "ai",
            "cloud"
          ],
          "title": "Cloud Storage"
        },
        {
          "code_url": "https://docs.google.com/document/d/17SWUDDbky0m2M_pz8NOjRGtoa2-USVcL4qO57HD1f6s/edit?usp=sharing",
          "description": "<p>Versioned key-value data management interface for TiKV</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5106163948978176/",
          "proposal_id": null,
          "short_description": "Versioned key-value data management interface for TiKV",
          "slug": "versioned-rawkv",
          "status": "completed",
          "student_name": "Hyungsuk Kang",
          "student_profile": null,
          "tags": [],
          "title": "Versioned rawKV"
        },
        {
          "code_url": "https://mlbridge.github.io",
          "description": "<p>This project aims to try and detect anomalies that occur in a CoreDNS server using a machine learning\nmodel developed in Keras. This project would help automate the process of anomaly detection, and\nreduce the necessity to write anomaly detection 'rules'.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5314202803109888/",
          "proposal_id": null,
          "short_description": "This project aims to try and detect anomalies that occur in a CoreDNS server using a machine learning\nmodel developed in Keras. This project would...",
          "slug": "anomaly-detection-of-the-coredns-server-through-machine-learning",
          "status": "completed",
          "student_name": "Chanakya Ekbote",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Anomaly Detection of the CoreDNS Server through Machine Learning"
        },
        {
          "code_url": "https://dev.to/devduttshenoi/a-summer-of-code-with-tikv-1gck",
          "description": "<p>To create a Cloud Native TiKV implementation which utilises a Cloud Platform's remote provisions to augment the current local only storage back-end based on rocksdb.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6217776412229632/",
          "proposal_id": null,
          "short_description": "To create a Cloud Native TiKV implementation which utilises a Cloud Platform's remote provisions to augment the current local only storage back-end...",
          "slug": "cloud-native-kv-service",
          "status": "completed",
          "student_name": "Devdutt Shenoi",
          "student_profile": null,
          "tags": [
            "cloud"
          ],
          "title": "Cloud Native KV-service"
        },
        {
          "code_url": "https://github.com/rajdas98/gsoc-2020-cncf",
          "description": "<p>This project aims is to work on the following issues:</p>\n<ol>\n<li>Develop local cluster provider (KIND)</li>\n<li>Deployment of Prombench on EKS and local cluster</li>\n<li>Resolve issues related to Grafana Dashboard being used in prometheus/test-infra</li>\n</ol>\n<p>This needs to create a provider for the local cluster with the help of KIND and deploy different components of prombench in the KIND cluster. Currently, Prombench is only supported on GKE Cluster. By having a KIND provider, users can check the performance of prometheus in the KIND cluster.</p>\n<p>Secondly, I am proposing to resolve the issues of the grafana dashboard used in test-infra of prometheus. This will help the user to see more consistent and useful dashboards</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4546170073907200/",
          "proposal_id": null,
          "short_description": "This project aims is to work on the following issues:\n\nDevelop local cluster provider (KIND)\nDeployment of Prombench on EKS and local cluster\nResolve...",
          "slug": "develop-local-cluster-provider-for-test-infaprombench-and-extending-test-infra",
          "status": "completed",
          "student_name": "Raj Babu Das",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Develop local cluster provider for test-infa/prombench and extending test-infra"
        },
        {
          "code_url": "https://github.com/jaybatra26/GSOC",
          "description": "<p>Prometheus is one of the standard-bearing open-source solutions for monitoring and observability. As a Prometheus-as-a-Service platform, Cortex fills in all of these crucial gaps with aplomb and thus provides a complete out-of-the-box solution for even the most demanding monitoring and observability use cases. Currently all querying labels are indexed. This is IO operation and storage heavy. The idea is to reduce that.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4753176323948544/",
          "proposal_id": null,
          "short_description": "Prometheus is one of the standard-bearing open-source solutions for monitoring and observability. As a Prometheus-as-a-Service platform, Cortex fills...",
          "slug": "selectively-disable-indexing-of-labels",
          "status": "completed",
          "student_name": "JayBatra",
          "student_profile": null,
          "tags": [],
          "title": "Selectively disable Indexing of labels"
        },
        {
          "code_url": "https://shibumi.dev/posts/google-summer-of-code-2020/",
          "description": "<p>in-toto is a project for protecting supply chain integrity. The project is a sister project of the TUF project and both are there for tightening the release process and making releases more secure. Therefore it’s not surprisingly, that in-toto has frameworks in various languages like golang. The golang in-toto framework is missing runlib functionality. The runlib library implements functionality for capturing evidence of a running process. For this project it’s possible to have a look on the python implementation for reimplementing the same functionality in golang. In the end it should be possible to call a function or a group of functions within golang for generating and signing in-toto link metadata.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4805808296034304/",
          "proposal_id": null,
          "short_description": "in-toto is a project for protecting supply chain integrity. The project is a sister project of the TUF project and both are there for tightening the...",
          "slug": "port-runlib-into-in-toto-golang",
          "status": "completed",
          "student_name": "Christian Rebischke",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "Port runlib into in-toto golang"
        },
        {
          "code_url": "https://github.com/prksu/gsoc-2020-cncf-rook",
          "description": "<p>This project aims to implement controller-runtime for Rook nfs-operator and addresses several issues along with it. Currently, Rook nfs-operator only simply watches an event of CustomResource from an informer. Controller-runtime is a good library for building an operator which incorporates the best-practice controller principles.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6494144572162048/",
          "proposal_id": null,
          "short_description": "This project aims to implement controller-runtime for Rook nfs-operator and addresses several issues along with it. Currently, Rook nfs-operator only...",
          "slug": "rewrite-nfs-operator-to-use-controller-runtime",
          "status": "completed",
          "student_name": "Ahmad Nurus Shobah",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Rewrite NFS Operator to use controller-runtime"
        },
        {
          "code_url": "https://docs.google.com/document/d/1YHrGNxQJipvED8AOp2jpNYTWc-KMW3d28n909xC4uPc",
          "description": "<p>Thanos is allowing storing metrics for long, if not unlimited time. Currently however there is no fine-granular process of retaining only some portion of metrics for longer time e.g useful aggregations, while deleting other parts early on. This project aims to implement this missing feature in Thanos and potentially Prometheus.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4839342998028288/",
          "proposal_id": null,
          "short_description": "Thanos is allowing storing metrics for long, if not unlimited time. Currently however there is no fine-granular process of retaining only some...",
          "slug": "per-series-metric-retention-thanos",
          "status": "completed",
          "student_name": "Harshitha Chowdary Thota",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Per Series Metric Retention - Thanos"
        },
        {
          "code_url": "https://github.com/phoenixking25/gsoc-meta-k8s",
          "description": "<p>The Kubernetes Multi-Tenancy Working Group is chartered with exploring and defining multi-tenancy models for Kubernetes. The Multi Tenancy Benchmarks effort focuses on measuring and validating the desired behaviors for multitenancy. Part of this effort is to automate behavioral and configuration checks on existing clusters, which will be the focus of this project. This automated test suite will help all Kubernetes users validate whether their clusters are set up correctly for multi-tenancy.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4881505114914816/",
          "proposal_id": null,
          "short_description": "The Kubernetes Multi-Tenancy Working Group is chartered with exploring and defining multi-tenancy models for Kubernetes. The Multi Tenancy Benchmarks...",
          "slug": "kubernetes-multitenancy-working-group-benchmarks",
          "status": "completed",
          "student_name": "Anuj Sharma",
          "student_profile": null,
          "tags": [
            "kubernetes",
            "ui"
          ],
          "title": "Kubernetes Multitenancy Working Group: Benchmarks"
        },
        {
          "code_url": "https://github.com/SomtochiAma/gsoc-2020-meta-k8s",
          "description": "<p>Cluster Addons are resources that are considered inherently part of the Kubernetes cluster as they help extend the functionality of the cluster. Over time different addons have surfaced with increasing complexity while the tools for managing these addons have not progressed as much. \nThe aim of this proposal is to build and package operators for different popular addons that are easy to use and follow best practices in various clusters.</p>\n",
          "difficulty": "beginner",
          "id": "proj_cncf_2020_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5788464768876544/",
          "proposal_id": null,
          "short_description": "Cluster Addons are resources that are considered inherently part of the Kubernetes cluster as they help extend the functionality of the cluster. Over...",
          "slug": "cluster-addons-package-all-things",
          "status": "completed",
          "student_name": "Somtochi Onyekwere",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "Cluster Addons: Package all things!"
        },
        {
          "code_url": "https://medium.com/@weastel/gsoc-2020-prometheus-cncf-cc38ecfc9482",
          "description": "<h4>Prombench is the automated E2E testing and benchmarking for Prometheus.</h4>\n<p>Prombench uses Kubernetes to benchmark Prometheus using various scalable configurations of fake web servers. Prombench uses Prometheus, Grafana and Loki for monitoring difference between versions.</p>\n<p>Presently Google Kubernetes can only be used for prombench. This creates a scarcity of use of prombench. This problem can be resolved using following :-</p>\n<ul>\n<li>Use of another cloud provider like (AWS)Amazon web services</li>\n</ul>\n<p>Presently, Grafana Dashboard consist of many useful graphs and useful visualization but there is a scope of improvement. Various issues which aims to improve visualizations for grafana are as follows :-</p>\n<ul>\n<li>Refactor the grafana dashboards to show a more consistent memory usage(#324)</li>\n<li>Revisit all current dashboards to add new and remove unneeded to make them more useful for catching bugs(#186)</li>\n<li>Node exported does not get filesystem size metrics from SSD path /mnt/disks/ssd0(#159)</li>\n<li>Add explanations to all panels on the Prombench dashboard(#305)</li>\n<li>Loki not showing previous test prometheus instance logs(#322)</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5847606468542464/",
          "proposal_id": null,
          "short_description": "Prombench is the automated E2E testing and benchmarking for Prometheus.\nPrombench uses Kubernetes to benchmark Prometheus using various scalable...",
          "slug": "prometheus-running-prombench-on-eks-and-update-dashboards",
          "status": "completed",
          "student_name": "Drumil Patel",
          "student_profile": null,
          "tags": [
            "web",
            "ai",
            "kubernetes",
            "cloud"
          ],
          "title": "Prometheus - Running prombench on EKS and update dashboards"
        },
        {
          "code_url": "https://gist.github.com/kushthedude/3233ee0422ad1471aae097c305ebda23",
          "description": "<ul>\n<li>Many performance benchmarks are limited to single instance load generation (single pod load generator). This limits the amount of traffic that can be generated to the output of the single machine that the benchmark tool runs on in or out of a cluster.</li>\n<li>Distributed load testing in parallel poses a challenge when merging results without losing the precision we need to gain insight into the high tail percentiles.</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5873005697171456/",
          "proposal_id": null,
          "short_description": "Many performance benchmarks are limited to single instance load generation (single pod load generator). This limits the amount of traffic that can be...",
          "slug": "distributed-load-testing-of-envoy-data-planes",
          "status": "completed",
          "student_name": "Kush Trivedi",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Distributed Load Testing of Envoy Data Planes"
        },
        {
          "code_url": "https://layer5.io/blog/community/SMI-conformance-testing-with-meshery",
          "description": "<p>Currently, there exists no software solution for checking whether a service mesh implements Service Mesh Interface or not.</p>\n<p>This causes the following problems:-</p>\n<ul>\n<li>For Service mesh maintainers, maintainers need to check whether the service mesh they are creating conforms to service mesh interface</li>\n<li>Users using service mesh don't know whether a feature is supported or not by the particular mesh they are using.</li>\n</ul>\n<p>In this project, aim is to:</p>\n<ul>\n<li>Build meshery as the underlying technology to support  SMI Certification</li>\n<li>Generate a compatibility matrix identifying the SMI features that are supported per service mesh.</li>\n<li>Decide the definition of what behavior is expected and conforms to spec. vs not. Partial conformance could be defined by a minimum requirement. It may be that partial conformance allows for / encourages extensibility</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6269818933608448/",
          "proposal_id": null,
          "short_description": "Currently, there exists no software solution for checking whether a service mesh implements Service Mesh Interface or not.\nThis causes the following...",
          "slug": "smi-conformance-tool",
          "status": "completed",
          "student_name": "Naveen Jain",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "SMI Conformance Tool"
        },
        {
          "code_url": "https://github.com/prometheus/prometheus/pull/7779",
          "description": "<p>Prometheus is a monitoring tool that monitors the specified targets, scrapes the system and application metrics at regular intervals, evaluates rules and performs alerting on condition.</p>\n<p>This project aims to implement the following features:</p>\n<ol>\n<li>Extending promtool in order to support formatting of <strong>YAML structure</strong>, <strong>PromQL expressions</strong> in rules files.</li>\n<li>Preserving custom comments in <strong>PromQL expressions</strong> and <strong>YAML structure</strong> in the rules files.</li>\n<li>Spreading <strong>PromQL expressions</strong> over multiple lines based on conditions, as followed by most linters.</li>\n<li>Solve issues related to promtool. <em>(priority and regular)</em></li>\n</ol>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6306606905556992/",
          "proposal_id": null,
          "short_description": "Prometheus is a monitoring tool that monitors the specified targets, scrapes the system and application metrics at regular intervals, evaluates rules...",
          "slug": "prometheus-extending-promtool-for-formatting-promql-expressions-and-yaml-structure-in-rules-files",
          "status": "completed",
          "student_name": "Harkishen Singh",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Prometheus: Extending promtool for formatting PromQL expressions and YAML structure in rules files"
        },
        {
          "code_url": "https://gist.github.com/prmsrswt/751e0d2894b8f8d8264ce70250162694",
          "description": "<p>So far Thanos has successfully used pieces of old Prometheus UI with some improvements. However, since Prometheus now moved all UI pages to React, it opens new possibilities for Thanos as well. The task is to move all UI to React and enrich them with Thanos features. As mentioned in the proposed idea, I also plan to add UI to every component of Thanos ensuring consistency and improve the experience of using Thanos even more.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2020_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5128917242871808/",
          "proposal_id": null,
          "short_description": "So far Thanos has successfully used pieces of old Prometheus UI with some improvements. However, since Prometheus now moved all UI pages to React, it...",
          "slug": "enriching-and-extending-thanos-uis-with-react-for-awesome-user-experience",
          "status": "completed",
          "student_name": "Prem Saraswat",
          "student_profile": null,
          "tags": [
            "react",
            "ui"
          ],
          "title": "Enriching and Extending Thanos UIs with React for Awesome User Experience"
        },
        {
          "code_url": "https://docs.google.com/document/d/1x0JypxP1QcyLkpKxkwUegMskG4Y9anqfpeH4_8Tt-mE/edit",
          "description": "<p>Resource Provision: Use CRD Operator to invoke the cloud resource and create the resource object.\nResource Binding: Use Service binding to do the resource binding, that is inject data to the resource object.\nMore Detailed Resource Provision: Do more refined resource supply, simplify the complexity of resource application.</p>\n",
          "difficulty": "advanced",
          "id": "proj_cncf_2020_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5206759230144512/",
          "proposal_id": null,
          "short_description": "Resource Provision: Use CRD Operator to invoke the cloud resource and create the resource object.\nResource Binding: Use Service binding to do the...",
          "slug": "do-resource-delivery-around-kubernetes",
          "status": "completed",
          "student_name": "Wangqian Qian",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "cloud"
          ],
          "title": "Do resource delivery around Kubernetes"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2020/organizations/5861737481371648/"
    },
    "year_2021": {
      "num_projects": 16,
      "projects": [
        {
          "code_url": "https://github.com/tikv/tikv/issues/9778",
          "description": "<p>Lightning is a tool used to import large amounts of data into TiDB. In addition to the logic of preparation and improving performance, the main logic of lightning can be divided into two parts:</p>\n<ol>\n<li>Translate SQL files to KV data by different encoders according to different backends.</li>\n<li>Import KV data into TiKV cluster.</li>\n</ol>\n<p>These two steps are in the logical layer. However, in the implementation layer, these two steps are coupled. Therefore, when support for KV database like HBase, lightning still needs to convert KV like data to SQL first, and then translate SQL to KV like data again.</p>\n<p>I will try to implement this feature by enhancing the ability of local backend, refactoring the logic of the import table, and so on.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6350710110683136/",
          "proposal_id": null,
          "short_description": "Lightning is a tool used to import large amounts of data into TiDB. In addition to the logic of preparation and improving performance, the main logic...",
          "slug": "tikv-high-performance-data-import-tool",
          "status": "completed",
          "student_name": "Bingchang Chen",
          "student_profile": null,
          "tags": [
            "ai",
            "database",
            "backend"
          ],
          "title": "TiKV: High-performance Data Import Tool"
        },
        {
          "code_url": "https://gist.github.com/fatiiates/20d6dc3c98add0e8e0428496cef00663",
          "description": "<p>Cloud Native Buildpacks' primary function is to turn source code into a runnable image and because of that it's natural for it to be used within common CI/CD platform pipelines. This project allows you to create a pipeline plugin that makes it easier for users to use Cloud Native Buildpacks within Jenkins.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6383215228485632/",
          "proposal_id": null,
          "short_description": "Cloud Native Buildpacks' primary function is to turn source code into a runnable image and because of that it's natural for it to be used within...",
          "slug": "cncf-cnb-jenkins-plugins",
          "status": "completed",
          "student_name": "Fatih ATES",
          "student_profile": null,
          "tags": [
            "cloud",
            "ui"
          ],
          "title": "CNCF - CNB - Jenkins Plugins"
        },
        {
          "code_url": "https://gist.github.com/zhuo1angT/aeb48e10d4437e076bfdd5a505ec94cc",
          "description": "<p>The goal of this project is to offer a formal verification using TLA+ for TiKV’s new “Async Commit” transaction model, which brings us more confidence in the improved performance.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5653055118245888/",
          "proposal_id": null,
          "short_description": "The goal of this project is to offer a formal verification using TLA+ for TiKV’s new “Async Commit” transaction model, which brings us more...",
          "slug": "tla-spec-for-async-commit",
          "status": "completed",
          "student_name": "Zhuoran He",
          "student_profile": null,
          "tags": [],
          "title": "TLA+ Spec for Async Commit"
        },
        {
          "code_url": "https://gist.github.com/inteon/9dce2403c6946e423c9076b90b195c62",
          "description": "<p>cert-manager can be installed using Helm or with regular Kubernetes manifests, but when using regular manifests it is difficult to customize the deployment. A <code>kubectl cert-manager install</code> command will make it easier for non-Helm users to customize the configuration of cert-manager, it will provide a way to see all the configuration options for a cert-manager deployment from the command line (i.e. by running kubectl cert-manager install --help). It will provide an option to wait for and verify the deployment, perhaps by integrating the code of cert-manager-verifier. And it may become the foundation of a future kubectl cert-manager upgrade command, which will help users safely upgrade and downgrade between cert-manager versions.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5686178510012416/",
          "proposal_id": null,
          "short_description": "cert-manager can be installed using Helm or with regular Kubernetes manifests, but when using regular manifests it is difficult to customize the...",
          "slug": "make-it-easy-to-install-and-verify-the-installation-of-cert-manager",
          "status": "completed",
          "student_name": "Tim Ramlot",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes"
          ],
          "title": "Make it easy to install and verify the installation of cert-manager"
        },
        {
          "code_url": "https://github.com/piyushsingariya/gsoc2021",
          "description": "<p>Currently, SMI doesn’t provide connectivity over multiple Kubernetes clusters. It is becoming common for users of a service mesh to have more than one cluster.</p>\n<p>What if Service Meshes could be connected with associated features like observability, control, and security, etc. even when they are being managed under different organizations.</p>\n<p>This project focuses to provide the ability to discover traffic across different service meshes and authenticate it, where each mesh is in a different and untrusted administrative domain, where each mesh can be of the same or from different vendors, can have the same or different control and data plane implementations, be single or multi-cluster, and can provide the same or different functionality to its customers.</p>\n<p>Extending multi-cluster capabilities mainly depends on two core features, which are required to provide the ability to discover traffic across different service meshes and authenticate it.</p>\n<ol>\n<li>Service Catalog Federation</li>\n<li>Identity Federation</li>\n</ol>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5689363899351040/",
          "proposal_id": null,
          "short_description": "Currently, SMI doesn’t provide connectivity over multiple Kubernetes clusters. It is becoming common for users of a service mesh to have more than...",
          "slug": "smi-support-for-multi-cluster-operations",
          "status": "completed",
          "student_name": "Piyush Singariya",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "SMI Support for Multi-Cluster Operations"
        },
        {
          "code_url": "https://www.cncf.io/blog/2021/08/19/__trashed-2/",
          "description": "<p>The Authentication server of the litmus portal (which resides in the <code>litmus-portal</code> folder of the main litmus repository) is written in golang, uses certain outdated dependencies (such as mgo), and currently does not support third-party OAuth authentication modules such as:</p>\n<ul>\n<li>Google Authentication</li>\n<li>GitHub Authentication</li>\n<li>Local Authentication</li>\n</ul>\n<p>The current implementation of the authentication server also consumes more resources than the litmus portal’s GraphQL server.</p>\n<p>This proposal shall focus on re-writing the Authentication Module of the litmus-portal so that it achieves the following:</p>\n<ul>\n<li>The Authentication Module is Independent (Can be moved to a separate repository)</li>\n<li>The Module is light-weight and makes use of actively maintained dependencies (if any)</li>\n<li>The Authentication Server is robust and flexible to any future addition of features</li>\n<li>The Authentication Server supports OAuth authentication such as Google Auth and GitHub Auth</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5723107746119680/",
          "proposal_id": null,
          "short_description": "The Authentication server of the litmus portal (which resides in the litmus-portal folder of the main litmus repository) is written in golang, uses...",
          "slug": "litmus-portal-authentication-module-refactor-and-oauth-implementation",
          "status": "completed",
          "student_name": "Hemanth Krishna",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "[Litmus Portal] Authentication Module Refactor and OAuth Implementation"
        },
        {
          "code_url": "https://gist.github.com/RinkiyaKeDad/307f54b54fd6ae2aede3ccfd2c7032fa",
          "description": "<p>cert-manager is a Kubernetes add-on used extensively to automate the management and issuance of certificates from various issuers.</p>\n<p>This project aims to capture the problems users often run into when deploying cert-manager on managed Kubernetes solutions on different clouds with the help of improved e2e testing.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/4983164438577152/",
          "proposal_id": null,
          "short_description": "cert-manager is a Kubernetes add-on used extensively to automate the management and issuance of certificates from various issuers.\nThis project aims...",
          "slug": "improve-the-usability-of-cert-manager-on-multiple-cloud-providers",
          "status": "completed",
          "student_name": "Arsh Sharma",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "cloud"
          ],
          "title": "Improve the usability of cert-manager on multiple cloud providers"
        },
        {
          "code_url": "https://mritunjaysharma394.medium.com/summary-of-gsoc21-with-cloud-native-buildpacks-611f1239b12e",
          "description": "<p>Buildpacks are pluggable tools that can be used to transform the source code to OCI compliant images (Docker images) that can run on any cloud. It is a Cloud Native Computing Foundation incubating project that provides a higher level of abstraction compared to Dockerfiles, decoupling the entire operational overhead and automating the process of rendering the applications production-ready. Currently, we don’t have the mechanism to inform the Buildpack Registry Index and Buildpack Registry Namespace repositories if they are updated with the latest Github Actions version or not. Through this project, we aim to accomplish automatically Automating Pull Request to Staging Index - whenever a new version of the github-action repo is released by automating staging tests of new action versions.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5631466431578112/",
          "proposal_id": null,
          "short_description": "Buildpacks are pluggable tools that can be used to transform the source code to OCI compliant images (Docker images) that can run on any cloud. It is...",
          "slug": "cloud-native-buildpacks-cncf-project-automatic-buildpack-registry-action-updates",
          "status": "completed",
          "student_name": "Mritunjay Sharma",
          "student_profile": null,
          "tags": [
            "ai",
            "docker",
            "cloud",
            "ui"
          ],
          "title": "Cloud Native Buildpacks [CNCF] Project: Automatic Buildpack Registry Action Updates"
        },
        {
          "code_url": "https://github.com/kubernetes-sigs/kube-scheduler-simulator",
          "description": "<p>In real Kubernetes, we cannot know the results of scheduling in detail without reading the logs, which usually requires privileged access to the control plane.\nTherefore, we have developed a simulator for kube-scheduler -- you can see the results of each plugin.</p>\n<p>With kube-scheduler simulator, you create resources and see where a new pod goes. And, you can check how scheduling was performed in detail.</p>\n<p>It can be used to learn about the Kubernetes scheduler or to examine the detailed behavior of plugins, etc.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6209298580897792/",
          "proposal_id": null,
          "short_description": "In real Kubernetes, we cannot know the results of scheduling in detail without reading the logs, which usually requires privileged access to the...",
          "slug": "web-based-simulator-for-scheduler-behaviour-project-kubernetes",
          "status": "completed",
          "student_name": "Kensei Nakada",
          "student_profile": null,
          "tags": [
            "web",
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "web-based simulator for scheduler behaviour (Project: Kubernetes)"
        },
        {
          "code_url": "https://github.com/haliliceylan/GSOC-2021-CNCF-Buildpacks-Journey",
          "description": "<p>Buildpacks are a kind of framework for preparing a container environment for your apps. Lifecycle is a particular workload that needs to run one by one in order. A Lifecycle Prepare phase should make it easier for Platform Implementers to achieve parity with features of Pack. Today, features like project.toml are only supported by Pack, and a new platform would need to write it’s own parser. My goal is to create new Lifecycle phase and associated binary should be available to Platform Implementers, and should be executed by Pack.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6047538402033664/",
          "proposal_id": null,
          "short_description": "Buildpacks are a kind of framework for preparing a container environment for your apps. Lifecycle is a particular workload that needs to run one by...",
          "slug": "buildpacks-lifecycle-prepare-phase",
          "status": "completed",
          "student_name": "Halil İbrahim Ceylan",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "Buildpacks Lifecycle Prepare Phase"
        },
        {
          "code_url": "https://github.com/dhruv0000/GSoC2021/blob/main/README.md",
          "description": "<p>Users configuring their Envoy-based data planes don't know how to find the optimal Envoy configuration given their workload's resiliency and performance requirements.\nNighthawk, Envoy's load generator, supports adaptive load control and horizontally distributed scaling of itself.\nUsing distributed load testing and the creation of a set of adaptive load controllers, Envoy users can be empowered with repeatable tooling to automate identification of an optimal Envoy data plane configuration.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/4923784972206080/",
          "proposal_id": null,
          "short_description": "Users configuring their Envoy-based data planes don't know how to find the optimal Envoy configuration given their workload's resiliency and...",
          "slug": "adaptive-load-control-and-distributed-load-testing-of-envoy-data-planes",
          "status": "completed",
          "student_name": "Dhruv P",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Adaptive Load Control and Distributed Load Testing of Envoy Data Planes"
        },
        {
          "code_url": "https://docs.google.com/spreadsheets/d/13Upxx4Awq6ugue_jrw1yrddV7x5BF1FZBFe8geMppNA/edit#gid=0",
          "description": "<p>Open Application Model [OAM] is a runtime-agnostic specification for defining cloud native applications and enabling building app-centric platforms by default. KubeVela is a modern application engine that adapts to your application's needs, not the other way around. KubeVela is now an standard implementation of OAM.  The project is to merge OAM k8s runtime into it and make a difference on a program start option. The final goal is by completing this project, users are able to select any version they want to install.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/4932644952866816/",
          "proposal_id": null,
          "short_description": "Open Application Model [OAM] is a runtime-agnostic specification for defining cloud native applications and enabling building app-centric platforms...",
          "slug": "merge-crossplaneoam-runtime-with-kubevela-by-specify-version",
          "status": "completed",
          "student_name": "Yeshuai Cui",
          "student_profile": null,
          "tags": [
            "cloud",
            "ui"
          ],
          "title": "Merge Crossplane/OAM-Runtime with KubeVela by specify version"
        },
        {
          "code_url": "https://coda.io/@joy/2021-gsoc-story",
          "description": "<p>Description: rebuilderd is a verification system for binary packages. It repeats the build process of a package in an identical environment and verifies that the package is identical. It is part of the Reproducible Builds effort and can currently be used to rebuild Arch Linux packages. The rebuild must optionally generate in-toto link attestations which can be used to verify the entire process. To that end, the nascent in-toto-rs library must be developed to enable this integration with rebuilderd.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5981808222535680/",
          "proposal_id": null,
          "short_description": "Description: rebuilderd is a verification system for binary packages. It repeats the build process of a package in an identical environment and...",
          "slug": "develop-in-toto-rs-rust-for-integration-with-rebuilderd",
          "status": "completed",
          "student_name": "Qijia “Joy” Liu",
          "student_profile": null,
          "tags": [
            "ui",
            "ux"
          ],
          "title": "Develop in-toto-rs (Rust) for integration with rebuilderd"
        },
        {
          "code_url": "https://gist.github.com/z0marlin/84c5c53d82d2972c90dd8fe50ebc6f99",
          "description": "<p>The Node Disk Manager (NDM) daemonset runs on every node in the Kubernetes cluster, discovers and monitors various storage devices connected to the node. It exports these devices as BlockDevice (BD) custom resources on the Kubernetes cluster, which are then used by other OpenEBS stack components. The NDM currently supports the detection of various storage devices connected to the node. However, it cannot detect specific changes that may happen to the block devices while connected to the node. Specifically, the NDM cannot detect changes in the mount-point(s) and the filesystem associated with a device. It also cannot detect a change in the capacity of the block device.</p>\n<p>The mount-point(s) of a block device can easily be changed on a system. It is easy to change the disk size on the cloud too. This causes issues in the Kubernetes cluster using OpenEBS as the changes in the device properties will not be reflected immediately in the BD resource.</p>\n<p>This proposal aims to solve the issue above by adding functionality in the NDM to detect changes in the mount-points and capacity of supported block devices and propagate them immediately to the corresponding BD resource.</p>\n",
          "difficulty": "beginner",
          "id": "proj_cncf_2021_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6293801156476928/",
          "proposal_id": null,
          "short_description": "The Node Disk Manager (NDM) daemonset runs on every node in the Kubernetes cluster, discovers and monitors various storage devices connected to the...",
          "slug": "openebs-update-mount-points-and-capacity-of-block-devices-without-restarting-ndm",
          "status": "completed",
          "student_name": "Z0marlin",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "cloud"
          ],
          "title": "OpenEBS: Update mount-points and capacity of Block Devices without restarting NDM"
        },
        {
          "code_url": "https://github.com/Namanl2001/me/blob/master/content/posts/202108-google-summer-of-code-2021.md",
          "description": "<p>Thanos Querier component supports basic TLS configuration for internal gRPC communication. This works great for basic use cases but it still requires extra forward proxies to make it work for bigger deployments. It’s also hard to rotate certificates automatically and configure safe mTLS. This project aims to remove those simplifications allowing better TLS story for all Thanos metrics APIs!</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6304273729585152/",
          "proposal_id": null,
          "short_description": "Thanos Querier component supports basic TLS configuration for internal gRPC communication. This works great for basic use cases but it still requires...",
          "slug": "automated-granular-tls-client-support-in-thanos",
          "status": "completed",
          "student_name": "Naman Lakhwani",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "ui"
          ],
          "title": "Automated, Granular TLS client support in Thanos"
        },
        {
          "code_url": "https://github.com/bwplotka/mdox",
          "description": "<p>This project aims to build and implement mdox, a documentation automation CLI tool, which can keep project documentation completely up-to-date by validating remote and local links, formatting markdown using GitHub Flavored Markdown guidelines, and generating code thereby making the act of maintaining quality documentation much easier and ensuring that this documentation is readable from GitHub as well as a website.</p>\n",
          "difficulty": null,
          "id": "proj_cncf_2021_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5145457193385984/",
          "proposal_id": null,
          "short_description": "This project aims to build and implement mdox, a documentation automation CLI tool, which can keep project documentation completely up-to-date by...",
          "slug": "smart-automation-for-project-documentation-and-website",
          "status": "completed",
          "student_name": "Saswata Mukherjee",
          "student_profile": null,
          "tags": [
            "web",
            "ai",
            "ui"
          ],
          "title": "Smart automation for project documentation and website"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2021/organizations/5144170817126400/"
    },
    "year_2022": {
      "num_projects": 16,
      "projects": [
        {
          "code_url": "https://onpy.in/posts/gsoc-22/",
          "description": "in-toto framework generates metadata files that are represented as signature wrapper or envelope. in-toto current signature wrapper requires canonicalization, which should be avoided for security reasons. Dead Simple Signing Envelope (DSSE) is a specification for signing methods and formats which removes current dependence on canonicalization and supports more encoding other than JSON. in-toto framework's implementation for signature wrapper must switch to using DSSE.",
          "difficulty": null,
          "id": "proj_cncf_2022_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/ZdFFBdFT/",
          "proposal_id": null,
          "short_description": "in-toto framework generates metadata files that are represented as signature wrapper or envelope. in-toto current signature wrapper requires...",
          "slug": "in-toto-dsse-implementation",
          "status": "completed",
          "student_name": "Pradyumna Krishna",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "in-toto: DSSE Implementation"
        },
        {
          "code_url": "https://github.com/pingcap/tispark/pull/2491",
          "description": "TiSpark maintains a com.pingcap.tikv/tikv-client module. It is a fork of the current official tikv-client legacy version. The difference from the current official tikv-client is that some TiSpark-specific enhancements have been added. This makes enhancements, bug fixes made for TiSpark tikv-client not affecting the official tikv-client and vice versa. We want to normalize the Java client and use the official one. Do not break original functionality and guarantee consistent behavior.",
          "difficulty": null,
          "id": "proj_cncf_2022_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/4AOvJGmH/",
          "proposal_id": null,
          "short_description": "TiSpark maintains a com.pingcap.tikv/tikv-client module. It is a fork of the current official tikv-client legacy version. The difference from the...",
          "slug": "normalize-tikv-java-client-for-tispark",
          "status": "completed",
          "student_name": "ZiJian Ren",
          "student_profile": null,
          "tags": [
            "java",
            "ai"
          ],
          "title": "Normalize TiKV Java client for TiSpark"
        },
        {
          "code_url": "https://github.com/WasmEdge/WasmEdge/issues/1477",
          "description": "WebAssembly has become extremely popular among the developer community lately. It offers near native performance in a browser and is meant to not be a hand written language but to be the compilation target of source languages like C, C++, Rust etc. It provides a way to run code written in multiple languages on the web at near-native speed, with client apps running on the web that previously couldn't have done so. It, being a new language , does not enjoy wide support across platforms. The prospect of having a unified interface for web developers has long been elusive. It has the potential to provide the basis on which many apps can be built and deployed for a huge range of devices from IoT devices to fully fledged servers. But to enable developers to use it we need a WASI runtime ecosystem to support them. WasmEdge is one such project that aims to bring WebAssembly to the edge.\n\nTo provide  a unified  interface accross multiple platforms, a interface between WasmEdge and the host operating system has to be built. This interface is specific to the platform on which the runtime is deployed and has to be built individually and specifically for each platform bearing in mind the features available. The native API provided by the OS should be used to implement many of the common operations like file manipulation, IO etc. These 'host functions' are crucial for the project to succeed and have been defined in WASI - the Web Assembly System Interface which is a modular collection of standardised APIs\n\nCurrently, host specific functions have not been implemented in WasmEdge, for the windows platform. These functions are supposed to be implemented using the Win32 API and have to go rigorous testing before being deployed.",
          "difficulty": null,
          "id": "proj_cncf_2022_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/YRfj0fIn/",
          "proposal_id": null,
          "short_description": "WebAssembly has become extremely popular among the developer community lately. It offers near native performance in a browser and is meant to not be...",
          "slug": "implement-wasi-and-wasmedge_process-host-functions-on-windows",
          "status": "completed",
          "student_name": "Abhinandan Udupa",
          "student_profile": null,
          "tags": [
            "web",
            "api",
            "ai",
            "ui"
          ],
          "title": "Implement WASI and wasmedge_process host functions on Windows"
        },
        {
          "code_url": "https://github.com/chaos-mesh/chaos-mesh/issues/3437",
          "description": "The chaos-daemon component of Chaos Mesh manages many subprocesses to inject faults into other containers(Linux namespaces), and we need to communicate with the subprocesses (to modify configurations or monitor statuses).Currently, chaos-daemon uses stdin/stdout to communicate with rs-tproxy, toda... Therefore, we need to ensure that we do not read and write data in stdin/stdout when writing code, which lays a hidden danger for subsequent development. So this project is going to use abstract unix domain socket instead of stdin/stdout.",
          "difficulty": null,
          "id": "proj_cncf_2022_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/dFZyvm9F/",
          "proposal_id": null,
          "short_description": "The chaos-daemon component of Chaos Mesh manages many subprocesses to inject faults into other containers(Linux namespaces), and we need to...",
          "slug": "rpc-cross-different-namespaces-through-unix-socket",
          "status": "completed",
          "student_name": "shouxunsun",
          "student_profile": null,
          "tags": [
            "ai",
            "ux"
          ],
          "title": "RPC cross different namespaces through unix socket"
        },
        {
          "code_url": "https://medium.com/@imnitish.ng/gsoc-2022-with-cncf-final-report-4bb2522d462a",
          "description": "Introduce a new variadic flag to the Pack CLI that enables configuring different cache types geared towards app developers or operators that are using pack in very specific \nways that require them to configure caching in a more advanced fashion. The proposed solution includes exposing image and volume cache options to the user and implementing a new bind cache feature, for build and launch cache.",
          "difficulty": "advanced",
          "id": "proj_cncf_2022_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/69nLAdPo/",
          "proposal_id": null,
          "short_description": "Introduce a new variadic flag to the Pack CLI that enables configuring different cache types geared towards app developers or operators that are...",
          "slug": "standardize-cache-flag-options-for-pack-cli",
          "status": "completed",
          "student_name": "Nitish Gupta",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Standardize Cache Flag options for pack CLI"
        },
        {
          "code_url": "https://thouse.vercel.app/works/kb",
          "description": "This project aims to provide unified Grafana dashboards to visualize K8s controller/operator status based on Kubebuilder.\nIn general, users have to design and create their own Grafana dashboards to observe their controllers/operators.\nIt would be great if we can provide a unified and comprehensive one, then users may:\n1. easily visualize controller/operator metrics\n2. avoid duplicate creation across different teams\n3. have more insights given by the rich content in the dashboard\n\nBasically, I plan to create a Kubebuilder plugin, that can be simply triggered to provide:\n1. dashboard resource that users can easily apply\n2. selective dashboards to bring more insight in certain fields\n\nAdditionally, this project also covers following features collected from the community:\n1. dashboard auto-installation when controllers are deployed\n2. new metrics to instrument user-defined CR\n3. additional dashboard to observe CR/CRD related resources\n\nIdeally, the project would provide a full-featured yet simple solution for users to monitor their CRs and relative controllers in detail.",
          "difficulty": null,
          "id": "proj_cncf_2022_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/ea988u8M/",
          "proposal_id": null,
          "short_description": "This project aims to provide unified Grafana dashboards to visualize K8s controller/operator status based on Kubebuilder. In general, users have to...",
          "slug": "a-grafana-dashboard-plugin-to-observe-controller-metrics",
          "status": "completed",
          "student_name": "Tianyi(Tony)",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "A Grafana Dashboard Plugin to Observe Controller Metrics"
        },
        {
          "code_url": "https://github.com/in-toto/in-toto-rs/issues/35",
          "description": "Rebuilderd is a verification system for binary packages. It repeates the build process of a package in an identical environment and verifies that the package is identical. It currently generates in-toto link attestations when a package is successfully rebuilt. As part of this task, rebuilderd must be updated to generate in-toto SLSA provenance. To enable this feature, in-toto-rs must be extended to support the provenance specification as well.\n\nWe plan to add a additional json generator, work together with existing generator by extract a abstract interface. By adding a argument, software will dynamic dispatch to right generator. By this way, in-toto-rs can be compatible with newer generators introduced by the future standards.\n\nAfter this, we will update the version in-toto-rs relied by rebuilderd, together with enough testcases to ensure the correctness of the logical.\n\nIf there's time left, we will add a \"Verifylib\"(or part of it) into `in-toto-rs to make up for the current functional defects. This verifylib should be compatible with the attestation of both old and new version.",
          "difficulty": null,
          "id": "proj_cncf_2022_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/EPuhVLxp/",
          "proposal_id": null,
          "short_description": "Rebuilderd is a verification system for binary packages. It repeates the build process of a package in an identical environment and verifies that the...",
          "slug": "add-slsa-provenance-support-to-in-toto-rs-and-rebuilderd",
          "status": "completed",
          "student_name": "Lenery Chen",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Add SLSA provenance support to in-toto-rs and rebuilderd"
        },
        {
          "code_url": "https://docs.google.com/document/d/e/2PACX-1vRvu8wjBTWorgL9vtEYa_uj0g_STUSJKSJ6yCwdB7uXR9cYmpYor5lFJwQI9sKnKo2Tkwb2U6IJ4SVB/pub",
          "description": "This proposal defines a new plugin that allows users to get the scaffold with the required code to have a project that will deploy and manage an image on the cluster following the guidelines and what have been considered good practices.",
          "difficulty": null,
          "id": "proj_cncf_2022_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/kRFUZGhU/",
          "proposal_id": null,
          "short_description": "This proposal defines a new plugin that allows users to get the scaffold with the required code to have a project that will deploy and manage an...",
          "slug": "new-golang-plugin-to-help-operator-authors-skill-up",
          "status": "completed",
          "student_name": "Nikhil Sharma",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "New Golang plugin to help Operator authors skill up"
        },
        {
          "code_url": "https://github.com/chaos-mesh/chaos-mesh/issues/3746",
          "description": "Chaos Mesh supports injecting errors into the physical machine through PhysicalMachineChaos. However, deploying it outside the Kubernetes cluster is too hard for users with little experience in Kubernetes. The traditional way to do this is to deploy a k3s, and run the chaos mesh controller inside it. \n\nThe dependencies and resource consumption can be eliminated further: we don't need the container runtime, proxy, gateway... and only a limited part of the chaos mesh controller should be running. It is possible to only start a Kubernetes apiserver, controller, and Chaos Mesh controller, which could be much lighter than the k3s solution. It would be preferred to integrate them into a single binary.",
          "difficulty": null,
          "id": "proj_cncf_2022_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/yKOpuIZh/",
          "proposal_id": null,
          "short_description": "Chaos Mesh supports injecting errors into the physical machine through PhysicalMachineChaos. However, deploying it outside the Kubernetes cluster is...",
          "slug": "single-binary-deployment-outside-kubernetes-environment",
          "status": "completed",
          "student_name": "Basit Hasan",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "kubernetes"
          ],
          "title": "Single binary deployment outside kubernetes environment."
        },
        {
          "code_url": "https://gist.github.com/lonelyCZ/803a7ad65e3396a8e0ff4060b0731b1d",
          "description": "Design and create Terraform modules framework that is benefit to extension and reusability to easily install and configure cert-manager, associated external dependencies (i.e. Vault, Istio, Traefik) and resources ([Cluster]Issuers, Certificates) to reduce the amount of time maintainers spend figuring out how to setup necessary infrastructure for different scenarios in which cert-manager can be used (i.e. to reproduce user reported bugs).",
          "difficulty": null,
          "id": "proj_cncf_2022_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/DaL4hA2U/",
          "proposal_id": null,
          "short_description": "Design and create Terraform modules framework that is benefit to extension and reusability to easily install and configure cert-manager, associated...",
          "slug": "tooling-to-deploy-and-cross-configure-cert-manager-with-external-dependencies-by-terraform",
          "status": "completed",
          "student_name": "Zhe Cheng",
          "student_profile": null,
          "tags": [
            "ios",
            "ai"
          ],
          "title": "Tooling to deploy and cross-configure cert-manager with external dependencies by Terraform"
        },
        {
          "code_url": "https://docs.google.com/spreadsheets/d/1l-WZiklEYrh_gReJgLVEavl11x2CQt8vivJURKgV1RE/edit?usp=sharing",
          "description": "Running Kubernetes should be done with the utmost security in mind. KubeArmor provides a policy based system to increase the quality of security in a Kubernetes cluster. Users need to define their own policy when implementing KubeArmor. Most users might find it challenging to define the most appropriate and effective security policy based on their use case. Currently there are limited ways for users to actually get observability data that can be used to assist them and provide better reasoning when creating an optimal security policy. The solution to this problem is by providing visibility telemetry events to show pod or container observability data. Observability data can consist of processes executions, file system accesses, and network accesses. This information is expected to assist users to create an optimal security policy. This solution is implemented by developing and deploying a Kubernetes service that will connect to the KubeArmor relay and get the events from the daemonsets. These events will then be aggregated and stored in the database for future use. Users can get the data by using the KubeArmor CLI program which will be extended to accommodate this solution.",
          "difficulty": null,
          "id": "proj_cncf_2022_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/rmHL0Mcl/",
          "proposal_id": null,
          "short_description": "Running Kubernetes should be done with the utmost security in mind. KubeArmor provides a policy based system to increase the quality of security in a...",
          "slug": "kubearmor-observability-and-policy-discovery-helper-tool",
          "status": "completed",
          "student_name": "Nathaniel Jason",
          "student_profile": null,
          "tags": [
            "ai",
            "database",
            "kubernetes"
          ],
          "title": "KubeArmor Observability and Policy Discovery Helper Tool"
        },
        {
          "code_url": "https://github.com/asubedy/GSoC-2022",
          "description": "The Service Mesh Performance standard captures and characterizes infrastructure capacity, service mesh configuration, and workload metadata. When we run a performance test the service mesh performance capture these details as performance profiles and gives the complete analysis of the test run. \n\nI will be working on making a visual representation of these data that gives us a clear understanding of what the characteristics of the test are. It will provide us with a better understanding of the performance profile values sent by the CNCF infrastructure. \nTo facilitate this I will be working on a benchmarking dashboard, where users will be able to analyze and compare the different performance test results. \n\nThe project can be divided into two parts:\n\n1. Working on the backend to fetch the SMP test results and query be able to query it on the  frontend\n\n2. Working on the frontend to discern these values, plot, analyze the data and give the user an ability to view these results and compare the effectiveness of the results.",
          "difficulty": null,
          "id": "proj_cncf_2022_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/GRLPhiag/",
          "proposal_id": null,
          "short_description": "The Service Mesh Performance standard captures and characterizes infrastructure capacity, service mesh configuration, and workload metadata. When we...",
          "slug": "cncf-cluster-performance-benchmarking",
          "status": "completed",
          "student_name": "Aaditya Narayan Subedy",
          "student_profile": null,
          "tags": [
            "ai",
            "frontend",
            "backend"
          ],
          "title": "CNCF Cluster: Performance Benchmarking"
        },
        {
          "code_url": "https://github.com/mariuskimmina/coredns-tlsplus",
          "description": "When using CoreDNS to serve DNS traffic over TLS/HTTPS certificates have to be managed (created and renewed) manually. The goal of my project is to automate this task, using the ACME protocol. If successful, CoreDNS can be hosted on a domain, such as dns.example.com, and automatically obtain a valid certificate (for example from Let's Encrypt) and it will also automatically be renewed before it expires, reducing toil for CoreDNS operators.",
          "difficulty": null,
          "id": "proj_cncf_2022_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/R8SxC38F/",
          "proposal_id": null,
          "short_description": "When using CoreDNS to serve DNS traffic over TLS/HTTPS certificates have to be managed (created and renewed) manually. The goal of my project is to...",
          "slug": "coredns-add-acme-protocol-support-for-certificate-management-into-tls-plugin",
          "status": "completed",
          "student_name": "Marius Kimmina",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "CoreDNS: Add ACME protocol support for certificate management into TLS plugin"
        },
        {
          "code_url": "https://github.com/abs007/GSoC-2022",
          "description": "Implementing version management for TUF’s python reference implementation. The implementation does not currently have a way to migrate TUF repositories or clients to a new TUF version that has breaking changes. This project will be the implementation of a proposal for coordinating specification versions between a repository and a client to prevent interruptions in access to updates after a major version change to the specification.",
          "difficulty": null,
          "id": "proj_cncf_2022_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/k9PsrJcs/",
          "proposal_id": null,
          "short_description": "Implementing version management for TUF’s python reference implementation. The implementation does not currently have a way to migrate TUF...",
          "slug": "implementing-taptuf-augmentation-proposal-14-for-pythons-reference-implementation",
          "status": "completed",
          "student_name": "Abhisman Sarkar",
          "student_profile": null,
          "tags": [
            "python"
          ],
          "title": "Implementing TAP(TUF Augmentation Proposal) 14 for python’s reference implementation"
        },
        {
          "code_url": "https://github.com/lakshya8066/Blogs/blob/main/GSoC-2022.md",
          "description": "In-toto is a framework designed to protect software supply chain integrity. It provides\nsecurity against attackers who can get control of a step in the supply chain and alter the\nproduct for malicious intents like introducing backdoors in the source code and including\nvulnerable libraries in the final product. \nThe goal of this project is to modify the Jenkins plugin to generate the in-toto attestations\nwith the Provenance metadata as well as link metadata depending on what the user chooses.",
          "difficulty": null,
          "id": "proj_cncf_2022_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/mR4u5su7/",
          "proposal_id": null,
          "short_description": "In-toto is a framework designed to protect software supply chain integrity. It provides security against attackers who can get control of a step in...",
          "slug": "in-toto-add-provenance-extension-to-jenkins-plugin",
          "status": "completed",
          "student_name": "Lakshya Gupta",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "in-toto:  Add provenance extension to Jenkins plugin"
        },
        {
          "code_url": "https://github.com/meshery/meshery/tree/meshery-ui-restructuring",
          "description": "Create a centralized catalog of Patterns, WebAssembly filters and eBPF programs which let's the user import, edit and deploy patterns.The Service Mesh Catalog project provides a place for users to consume and publishers share WebAssembly filters, Service Mesh Patterns, eBPF programs",
          "difficulty": null,
          "id": "proj_cncf_2022_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/JUonri8T/",
          "proposal_id": null,
          "short_description": "Create a centralized catalog of Patterns, WebAssembly filters and eBPF programs which let's the user import, edit and deploy patterns.The Service...",
          "slug": "expand-service-mesh-patterns-catalog",
          "status": "completed",
          "student_name": "Yash Kamboj",
          "student_profile": null,
          "tags": [
            "web"
          ],
          "title": "Expand Service Mesh Patterns catalog"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2022/organizations/cncf/"
    },
    "year_2023": {
      "num_projects": 14,
      "projects": [
        {
          "code_url": "https://www.arthursens.dev/posts/created-timestamps",
          "description": "The proposal consists in treating the time series creation time as another metadata. We propose a few incremental improvements that can be released separately, and therefore faster.\n\nWe start by dropping time series when negotiating OpenMetrics format. Then changing the current metadata behavior to be correlated with MetricPoint instead of MetricFamily. The third step is storing the last seen value of _created for each MetricPoint. Lastly, storing a symbolic value each time the _created timestamp minus the scrape timestamp is lower than the scrape interval.",
          "difficulty": null,
          "id": "proj_cncf_2023_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/pmQsJm1C",
          "proposal_id": "E48XhUFa",
          "short_description": "The proposal consists in treating the time series creation time as another metadata. We propose a few incremental improvements that can be released...",
          "slug": "support-openmetrics-_created-timestamp-in-prometheus",
          "status": "completed",
          "student_name": "Arthur Sens",
          "student_profile": null,
          "tags": [],
          "title": "Support OpenMetrics _created timestamp in Prometheus"
        },
        {
          "code_url": "https://github.com/bit-dance/GSoC_Final_Report",
          "description": "CurveBS currently use etcd as metadata storage but etcd has limited scalability, and the amount of metadata that can be stored is limited.So i plan to add a MySQL database as one of the storage engines and let user choose whether the metadata is stored in the kv engine or the sql engine through the configuration file.\nDeliverables:\n1.A new SQL storage client implementation for metadata in CurveBS.\n2.Configuration options to choose between kv engine and SQL engine for metadata storage.\n3.Modifications to the leader election process to support the new SQL storage client.\n4.Documentation on how to configure and use the new SQL storage client.\n5.Tests to ensure the new SQL storage client works as expected and is compatible with existing functionality.\n6.Release notes detailing the changes and improvements made to CurveBS with the addition of the new SQL storage client.",
          "difficulty": null,
          "id": "proj_cncf_2023_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/uEZfWgBc",
          "proposal_id": "ScDiLVhf",
          "short_description": "CurveBS currently use etcd as metadata storage but etcd has limited scalability, and the amount of metadata that can be stored is limited.So i plan...",
          "slug": "add-support-for-sql-database-storage-in-curvebs",
          "status": "completed",
          "student_name": "Bokai Jia",
          "student_profile": null,
          "tags": [
            "ai",
            "database"
          ],
          "title": "Add Support for SQL Database Storage in CurveBS"
        },
        {
          "code_url": "https://github.com/buildpacks/pack/pull/1791",
          "description": "Build out samples and workflows showing how to use Dockerfiles in harmony with a cloud native buildpacks platform. Need to update the pack implementation to be more performant by taking advantage of the available daemon and updating documentation and sample workflows to reflect the changes.",
          "difficulty": null,
          "id": "proj_cncf_2023_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/OL9wVCop",
          "proposal_id": "2jEBM1sG",
          "short_description": "Build out samples and workflows showing how to use Dockerfiles in harmony with a cloud native buildpacks platform. Need to update the pack...",
          "slug": "enhancements-for-dockerfiles",
          "status": "completed",
          "student_name": "Darshan Kumar",
          "student_profile": null,
          "tags": [
            "ai",
            "docker",
            "cloud",
            "ui"
          ],
          "title": "Enhancements for Dockerfiles"
        },
        {
          "code_url": "https://gist.github.com/debasishbsws/5b32514a96c3c516d12e40b26ae019ea",
          "description": "Overview:\r\nIn the current scenario, the Knative Eventing Kafka Broker's data-plane communication with Apache Kafka for consuming and producing records is done via the Vert.x-Kafka-client library which is basically a wrapper for communications with Apache Kafka inside the Vert.x threading model.  \r\nObjictive:\r\nThis project idea aims to implement the Knative Kafka Broker data-plane communication with the native Apache-kafka-client library working on Java 19 and evaluate OpenJDK 19's Project Loom and leverage its virtual threads for efficient and concurrent communication with the Apache Kafka cluster.",
          "difficulty": null,
          "id": "proj_cncf_2023_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/BHsUqzLn",
          "proposal_id": "32EhuB0J",
          "short_description": "Overview: In the current scenario, the Knative Eventing Kafka Broker's data-plane communication with Apache Kafka for consuming and producing records...",
          "slug": "dataplane-migration-for-apache-kafka-communications-leveraging-java19s-project-loom",
          "status": "completed",
          "student_name": "Debasish Biswas",
          "student_profile": null,
          "tags": [
            "java",
            "ai"
          ],
          "title": "Dataplane migration for Apache Kafka communications: Leveraging Java19’s Project Loom."
        },
        {
          "code_url": "https://github.com/Eileen-Yu/Eileen-Yu/blob/main/stories/Empowering%20Kubebuilder%3A%20My%20GSoC%202023%20Journey%20with%20Phase%202%20Plugin.md",
          "description": "The introduction of external plugin extends the functionality of the Kubebuilder CLI tool by allowing users to create and use custom plugins. These plugins can be written in any programming language, as long as they implement the interface specifications to interact with Kubebuilder.\n\nThis proposal aims to provide best practices based on tutorials, testing and documentation. \n\nIt also suggests the kube-state-metrics plugin as a sample project, which would scaffold the configuration for KSM to load and populate metrics for CR/CRD.\n \nThe overall efforts are attempted to guide Kubernetes developers to learn how to write, install, and use their own Kubebuilder plugins.",
          "difficulty": null,
          "id": "proj_cncf_2023_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/N5cWUVl7",
          "proposal_id": "phjike3f",
          "short_description": "The introduction of external plugin extends the functionality of the Kubebuilder CLI tool by allowing users to create and use custom plugins. These...",
          "slug": "kubebuilder-phase-2-plugin",
          "status": "completed",
          "student_name": "Eileen Yu",
          "student_profile": null,
          "tags": [
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "Kubebuilder phase 2 plugin"
        },
        {
          "code_url": "https://docs.google.com/document/d/18OlFF7u0C9Fn25If_M6gEWHghJ1GNtWIL9I1vUrq9HQ/edit?usp=sharing",
          "description": "This project aims at leveraging the current community jaeger-clickhouse storage plugin and making ClickHouse one of the core storage backend for Jaeger, besides Cassandra and ElasticSearch.",
          "difficulty": null,
          "id": "proj_cncf_2023_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/rydbL7aP",
          "proposal_id": "T3clxfRe",
          "short_description": "This project aims at leveraging the current community jaeger-clickhouse storage plugin and making ClickHouse one of the core storage backend for...",
          "slug": "jaeger-make-clickhouse-a-core-storage-backend",
          "status": "completed",
          "student_name": "Ha Anh Vu",
          "student_profile": null,
          "tags": [
            "ai",
            "backend"
          ],
          "title": "Jaeger: Make ClickHouse a core storage backend"
        },
        {
          "code_url": "https://github.com/zhy76/GSoC-2023-CNCF-Report",
          "description": "Our goal is to create a Github Action from KubeArmor, which will be used by other Github projects. This Github Action, using KubeArmor, will be used to identify changes in the application posture.\nFor example, if a project creates v0.1, and then a release v0.2 is made, the Github Action should provide us with a view of all the changes that occurred in the application from v0.1 to v0.2, such as what new processes are being spawned and what new file accesses are being made.",
          "difficulty": null,
          "id": "proj_cncf_2023_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/0EWL96Fd",
          "proposal_id": "AxyimrmD",
          "short_description": "Our goal is to create a Github Action from KubeArmor, which will be used by other Github projects. This Github Action, using KubeArmor, will be used...",
          "slug": "github-actions-for-kubearmor",
          "status": "completed",
          "student_name": "Haiyu Zuo",
          "student_profile": null,
          "tags": [],
          "title": "GitHub Actions for KubeArmor"
        },
        {
          "code_url": "https://link.mgjm.de/gsoc-2023",
          "description": "Running containers with podman using conmon-rs as the container monitor.\n\n\nThis requires additional features to be implemented in conmon-rs and an extension of podman to use the new conmon-rs go client as an alternative to the existing conmon binary executable.",
          "difficulty": null,
          "id": "proj_cncf_2023_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/xwEB63cl",
          "proposal_id": "p6udpQcU",
          "short_description": "Running containers with podman using conmon-rs as the container monitor. This requires additional features to be implemented in conmon-rs and an...",
          "slug": "conmon-rs-support-for-podman",
          "status": "completed",
          "student_name": "mgjm",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Conmon-rs support for podman"
        },
        {
          "code_url": "https://docs.google.com/document/d/1qQI2xe5bJfYz_sXodBi2iqPyYKNJaRtJTNnc1wBy0rk/edit?usp=sharing",
          "description": "Streamlining the OFEP process for enhancing community engagement through automation scripts by doing almost everything they can, from creating proposals by asking questions to users to making the process interactive to assigning and reminding reviewers through Github and Slack. This also involves automating their publishing of the accepted/declined ideas to a newly made website. This would involve me constantly taking feedback from the community to enhance the overall process of contributing the best ideas, hence fostering faster long-term growth of the overall project.",
          "difficulty": null,
          "id": "proj_cncf_2023_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/BuyO59lV",
          "proposal_id": "NUKj6v6O",
          "short_description": "Streamlining the OFEP process for enhancing community engagement through automation scripts by doing almost everything they can, from creating...",
          "slug": "streamlined-openfeature-enhancement-proposal-process",
          "status": "completed",
          "student_name": "none_24",
          "student_profile": null,
          "tags": [
            "web",
            "ml"
          ],
          "title": "Streamlined OpenFeature Enhancement Proposal Process"
        },
        {
          "code_url": "https://github.com/rakshitgondwal/gsoc-2023/blob/main/README.md",
          "description": "Currently, the Metrics Controller in the Keptn Lifecycle Toolkit only allows querying a single value per metric. This project will enable users to define timeframes for metrics and get standardized aggregated results for the given timeframe. The addition of time frames for metrics would provide developers with a lot of flexibility when analyzing their application’s performance as they would be able to easily switch between different timeframes to get a better understanding of how their application is performing. This can be achieved by modifying the structure of the Metric CRD by adding certain fields and then modifying the APIs of our Metric providers to support these newly added fields. The metrics controller would be able to query metrics over a timeframe and then return raw values from the providers which can then be passed to the aggregation functions to calculate the desired aggregated value. These values would be updated in the Metric CRD.",
          "difficulty": null,
          "id": "proj_cncf_2023_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/e7z3n3kH",
          "proposal_id": "G4MKYKuJ",
          "short_description": "Currently, the Metrics Controller in the Keptn Lifecycle Toolkit only allows querying a single value per metric. This project will enable users to...",
          "slug": "timeframe-for-metrics",
          "status": "completed",
          "student_name": "Rakshit Gondwal",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Timeframe for Metrics"
        },
        {
          "code_url": "https://github.com/Rohith-Raju/Gsoc-2023",
          "description": "This project aims to improve Falco's capabilities by adding WebAssembly as a new officially-supported compilation target. The objective is to create a new development environment for security rules in a web single-page application, allowing Falco to run directly inside the browser. The goal is to provide a more versatile and user-friendly tool for developing and testing security rules. The plan is to leverage the Emscripten toolchain to accomplish this. The result will be a web-based application similar to the Go Playground, but without requiring any backend. The deliverables will include a fully functional development environment, a detailed guide for using the application, and documentation for the project.",
          "difficulty": null,
          "id": "proj_cncf_2023_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/urIdU9OC",
          "proposal_id": "YHV6IoyS",
          "short_description": "This project aims to improve Falco's capabilities by adding WebAssembly as a new officially-supported compilation target. The objective is to create...",
          "slug": "falco-web-ide-for-security-rules-with-webassembly",
          "status": "completed",
          "student_name": "Rohith Raju",
          "student_profile": null,
          "tags": [
            "web",
            "ai",
            "ui",
            "backend"
          ],
          "title": "Falco: Web IDE for Security Rules with WebAssembly"
        },
        {
          "code_url": "https://github.com/ShivangShandilya/GSoC-2023",
          "description": "The proposal deals with the problem of the creation of a kubectl plugin for Armada, the creation of the desired plugin will allow users to communicate with Armada via kubectl. The solution this proposal provides is that in order to create a plugin for kubectl we need the help of armadactl i.e. command-line utility for Armada through which users submit their jobs to the Armada server. To develop a plugin for kubectl, we first must develop a base plugin for armadactl in Go that performs basic tasks such as submission and cancellation of jobs, creation of queues, etc. After the necessary coding for the plugin is finished, we now distribute that plugin over at Krew so that it is globally accessible. Once it is distributed at Krew, a user can install this plugin as a kubectl plugin and can interact with the Armada server and perform the aforementioned tasks.",
          "difficulty": null,
          "id": "proj_cncf_2023_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/tQdgYCVe",
          "proposal_id": "UZU64Upd",
          "short_description": "The proposal deals with the problem of the creation of a kubectl plugin for Armada, the creation of the desired plugin will allow users to...",
          "slug": "kubectl-plugin-for-armada",
          "status": "completed",
          "student_name": "Shivang Shandilya",
          "student_profile": null,
          "tags": [],
          "title": "Kubectl plugin for Armada"
        },
        {
          "code_url": "https://gist.github.com/shubham4443/dcbdf72d3311f4e709fbe02a89d0b8c9",
          "description": "The TUF specification provides explicit guidelines for how artifacts should be hashed and later verified to guarantee their integrity. However, Content Addressable Systems like Git, IPFS (InterPlanetary File System) and OSTree have their own mechanisms for ensuring the integrity of artifacts. When TUF is used with these systems, it is redundant for it to also ensure artifact integrity. This project provides solution to this issue by delegating the responsibility of artifact integrity verification to the underlying content addressable systems themselves, while still using TUF to manage the metadata and provide additional security measures.",
          "difficulty": null,
          "id": "proj_cncf_2023_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/vT5PhNL0",
          "proposal_id": "KDKv1yZY",
          "short_description": "The TUF specification provides explicit guidelines for how artifacts should be hashed and later verified to guarantee their integrity. However,...",
          "slug": "prototyping-support-for-content-addressable-systems-like-ipfs-in-tuf",
          "status": "completed",
          "student_name": "Shubham Nazare",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Prototyping Support for Content Addressable Systems like IPFS in TUF"
        },
        {
          "code_url": "https://gist.github.com/swastik959/913bdca221f6f4c5283c4104846d834b",
          "description": "One possible way to use the Kubernetes API to connect to the KubeVela Control Plane in the background and fetch the required information like X-Definitions, ComponentDefinitions, TraitDefinitions, PolicyDefinitions, and WorkflowStepDefinitions. The plugin can then use this information to provide syntax highlighting and autocompletion for these definitions in the YAML files.\n\nTo preview the rendering result of components and traits, the plugin can use the Kubernetes API to create a dry-run of the KubeVela application on the remote cluster. The output can be displayed in the IDE to give users an idea of how the application will look when it's deployed.\n\nTo compare the difference between the current application configuration and the corresponding one on the remote cluster, the plugin can use the Kubernetes API to fetch the current configuration and compare it with the local one. The differences can be highlighted in the IDE for easy identification.\n\nTo preview the selected clusters by the topology policy, the plugin can use the Kubernetes API to fetch the list of clusters and display them in the IDE. The plugin can also use the Kubernetes API to fetch the topology policy and apply it to the list of clusters to display the selected clusters.\n\nFor ComponentDefinition and TraitDefinition, the plugin can use the CUE language to provide validation for the CUE input and preview the rendering result. The plugin can also use the Kubernetes API to fetch the ComponentDefinition and TraitDefinition and display them in the IDE for reference.",
          "difficulty": "beginner",
          "id": "proj_cncf_2023_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/ne8pFt1F",
          "proposal_id": "JOAe9Ocr",
          "short_description": "One possible way to use the Kubernetes API to connect to the KubeVela Control Plane in the background and fetch the required information like...",
          "slug": "ide-plugins-for-editing-vela-applications",
          "status": "completed",
          "student_name": "Swastik Gour",
          "student_profile": null,
          "tags": [
            "api",
            "ml",
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "IDE Plugins for editing vela applications"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/programs/2023/organizations/cncf"
    },
    "year_2024": {
      "num_projects": 11,
      "projects": [
        {
          "code_url": "https://gist.github.com/Devaansh-Kumar/4778e5bb3c61d4c16a20202b5f77aac7",
          "description": "Ingress2gateway is a tool to help users migrate and convert Ingress, and implementation-specific configurations to Gateway API. As we add more conversion logic, and onboard more implementations (essentially Ingress and Gateway controllers like Istio, Kong, etc.), logs become insufficient to report conversion results, warnings and crucial messages regarding the conversion. To improve the tool usability, we need to enable users to know exactly the original resource/s -> new resource/s mapping, PLUS what the tool couldn't convert so they could make the final touches before applying the new resources to the cluster.\n\nI plan to create a new package called notification that can collect these logs and aggregate them for the users in different formats. More details can be found out in my proposal.",
          "difficulty": null,
          "id": "proj_cncf_2024_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/OI4PBxPR/",
          "proposal_id": null,
          "short_description": "Ingress2gateway is a tool to help users migrate and convert Ingress, and implementation-specific configurations to Gateway API. As we add more...",
          "slug": "kubernetes-gateway-api-design-and-develop-notification-mechanism-for-ingress2gateway",
          "status": "completed",
          "student_name": "Devaansh Kumar",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "kubernetes"
          ],
          "title": "Kubernetes Gateway API: Design and develop notification mechanism for ingress2gateway."
        },
        {
          "code_url": "https://github.com/prometheus/prometheus/pull/14904",
          "description": "We propose transitioning from the deprecated gogo/protobuf to Vitess's vtproto as part of an effort to modernize Prometheus's codebase. The migration requires minor changes to the original code structure. However, agent-side performance degrades significantly by around 50% according to cstyan’s experimental results. While manually serializing the data structure can avoid these allocation overheads, we prefer not to maintain hand-written marshal/unmarshal code. The upcoming Remote-write-2.0 (rw2.0) will address these memory allocation overheads. By pushing for rw2.0 alongside migrating to vtproto, we can utilize a better-maintained library and eliminate this allocation if rw2.0 is adopted quickly. Therefore, I propose that we manually marshal/unmarshal protobuf while pushing for rw2.0's publication.",
          "difficulty": null,
          "id": "proj_cncf_2024_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/s9tV51nw/",
          "proposal_id": null,
          "short_description": "We propose transitioning from the deprecated gogo/protobuf to Vitess's vtproto as part of an effort to modernize Prometheus's codebase. The migration...",
          "slug": "move-out-of-gogoprotobuf-to-protobuf-with-vtproto-implementation",
          "status": "completed",
          "student_name": "tonyli233",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Move out of gogo/protobuf to protobuf with vtproto implementation"
        },
        {
          "code_url": "https://github.com/kubearmor/rancherui",
          "description": "This project aims to create a user-friendly way to manage essential KubeArmor security functions from within the Rancher Manager interface. This will make it much easier for Rancher users to protect their Kubernetes environments. As mentioned in the GitHub Issue the key functionalities of this project include “a streamlined process of KubeArmor installation and configure it within a Rancher-managed Kubernetes cluster, Policy management includes viewing and listing and editing existing policies, creating new policies, integrating telemetry for alerts and visualizing security events and metrics, and functionalities to recommend predefined security policies and  automatically discover policies based on the cluster's workload.”",
          "difficulty": null,
          "id": "proj_cncf_2024_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/XjxF687O/",
          "proposal_id": null,
          "short_description": "This project aims to create a user-friendly way to manage essential KubeArmor security functions from within the Rancher Manager interface. This will...",
          "slug": "building-a-kubearmor-extension-for-rancher-manager",
          "status": "completed",
          "student_name": "Krish Aryan",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "Building a KubeArmor Extension for Rancher Manager"
        },
        {
          "code_url": "https://gist.github.com/iam-zoey/d8cf00ee7bf130b20c288ffb30804938",
          "description": "In a single Knative Functions command, we aim to abstract the entire process of building serverless functions using WebAssembly (WASM)—from compiling the source code into WASM and containerizing it, to deploying it in Knative. This approach allows developers to focus solely on their source code, while Knative Functions handles all underlying transformations, ensuring seamless execution across various platforms.\n\nWebAssembly (WASM) significantly enhances performance, security, and flexibility. By compiling code written in languages such as C, C++, Rust, and Go into a bytecode format, WebAssembly ensures consistent execution across different processor architectures (x86, ARM, RISC-V). WASM’s fast execution and platform-independent bytecode format could expand the capabilities of Knative Functions, supporting a broader range of programming languages and processor architectures.\n\nCurrently, there is no support for WASM in Knative Functions, which is why our project focused on pushing the boundaries of what’s possible by exploring WebAssembly support in Knative. During this project, we identified some limitations in fully integrating WASM into Knative Functions. However, by successfully implementing WASM support in Knative Serving, we were able to explore the potential of WASM within Knative and lay the groundwork for future improvements once these limitations are addressed.",
          "difficulty": null,
          "id": "proj_cncf_2024_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/mlXZWw0L/",
          "proposal_id": null,
          "short_description": "In a single Knative Functions command, we aim to abstract the entire process of building serverless functions using WebAssembly (WASM)—from compiling...",
          "slug": "improving-wasm-support-in-knative-functions",
          "status": "completed",
          "student_name": "Zoey_Hong",
          "student_profile": null,
          "tags": [
            "web",
            "ml",
            "ai",
            "ui"
          ],
          "title": "Improving WASM Support in Knative Functions"
        },
        {
          "code_url": "https://github.com/z1ens/GSoC-2024_CNCF_Final_Report.git",
          "description": "Enhance Open Cluster Management (OCM) to efficiently schedule AI workloads across multiple Kubernetes clusters by optimizing the use of GPU/TPU resources.\n\nKey components:\n1. GPU/TPU Resource Evaluation Addon: Extend OCM's placement strategy to include GPU/TPU resource availability. This project introduce an AddonPlacementScore that assesses GPU/TPU resources in cluster sets, which informs scheduling decisions to ensure AI workloads are distributed based on specific GPU/TPU resource requirements.\n2. OCM Kueue Admission Check Controller: Deliver a proposal for the external Kueue Admission Check controller integrating OCM Placement results with MultiKueue. The controller reads OCM Placement decisions and generates corresponding MultiKueueConfig and MultiKueueCluster resources, streamlining the setup of the MultiKueue environment and enabling users to select clusters based on custom criteria.\n\nDeliverables: GPU/TPU Resource Evaluation Addon, OCM Kueue Admission Check Controller, Comprehensive Documentation and User Guides.",
          "difficulty": null,
          "id": "proj_cncf_2024_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/Em6whXe4/",
          "proposal_id": null,
          "short_description": "Enhance Open Cluster Management (OCM) to efficiently schedule AI workloads across multiple Kubernetes clusters by optimizing the use of GPU/TPU...",
          "slug": "open-cluster-management-scheduling-ai-workload-in-multi-clusters",
          "status": "completed",
          "student_name": "Zhe Shen",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "kubernetes",
            "ui"
          ],
          "title": "Open Cluster Management: Scheduling AI workload in multi-clusters"
        },
        {
          "code_url": "https://github.com/WasmEdge/WasmEdge/pull/3521",
          "description": "This project aims to implement wasm-coredump, to enhance the debugging capabilities of WebAssembly by implementing a coredump feature for post-mortem analysis for the wasmedge runtime.\n\nWhen WebAssembly encounters a runtime error, it will start unwinding and initiate a process to collect debugging information, including stack frames, local variable values, and a snapshot of the linear memory. For each stack frame, it will collect the values in locals (includes function parameters) and on the stack. Along with binary offsets to resolve to source file locations. This data is saved in a coredump file, which can be analysed post-mortem to debug the error using tools like wasmgdb",
          "difficulty": null,
          "id": "proj_cncf_2024_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/yHmXWpEL/",
          "proposal_id": null,
          "short_description": "This project aims to implement wasm-coredump, to enhance the debugging capabilities of WebAssembly by implementing a coredump feature for post-mortem...",
          "slug": "implementing-coredump-for-post-mortem-debugging-in-webassembly",
          "status": "completed",
          "student_name": "Siddharth Tewari",
          "student_profile": null,
          "tags": [
            "web",
            "ai"
          ],
          "title": "Implementing Coredump for Post-Mortem Debugging in WebAssembly"
        },
        {
          "code_url": "https://gist.github.com/sratslla/0cb5f82a6d5b31bdf2206a2ad916c037",
          "description": "The project aims to develop an automated benchmarking system for KubeArmor to enhance the efficiency and repeatability of performance evaluations. By automating benchmark execution, metrics collection, and reporting, the system will ensure consistent and rigorous evaluation of KubeArmor's performance across various scenarios.",
          "difficulty": null,
          "id": "proj_cncf_2024_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/aQ2NgLoN/",
          "proposal_id": null,
          "short_description": "The project aims to develop an automated benchmarking system for KubeArmor to enhance the efficiency and repeatability of performance evaluations. By...",
          "slug": "kubearmor-automating-benchmarking-workflow",
          "status": "completed",
          "student_name": "Shubh Gaur",
          "student_profile": null,
          "tags": [
            "ios",
            "ai"
          ],
          "title": "KubeArmor: Automating Benchmarking Workflow"
        },
        {
          "code_url": "https://github.com/meshery/meshery/pulls?q=is%3Apr+author%3AJougan-0",
          "description": "The Objective of this project is to develop IDE plugins that can enhance the \ndeveloper experience while working with Service Mesh Performance \nperformance Profiles. \n\nProject Goals:\nCreate a vs code extension for syntax highlighting and validation for smp models.\n\nTech Stack: Language Server Protocol(LSP), Cloud native Componenets and relationships",
          "difficulty": null,
          "id": "proj_cncf_2024_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/feKg4GCh/",
          "proposal_id": null,
          "short_description": "The Objective of this project is to develop IDE plugins that can enhance the developer experience while working with Service Mesh Performance...",
          "slug": "service-mesh-performance",
          "status": "completed",
          "student_name": "ShlokMishra",
          "student_profile": null,
          "tags": [
            "cloud"
          ],
          "title": "Service Mesh Performance"
        },
        {
          "code_url": "https://docs.google.com/document/d/1-mRsPKzXPQBeDRsAGjzpMqdEfm6W4IsaX-L3DTOVfSI/edit?usp=sharing",
          "description": "The Cloud Native Computing Foundation (CNCF) hosts a diverse ecosystem of cloud-native projects. Ensuring the security of these projects is paramount to maintain trust and reliability within the community.\n\nBy adopting OpenSSF Scorecards, integrating OSS-Fuzz, and implementing enhanced build/release security practices, CNCF projects can strengthen their security posture, mitigate risks, and build trust among users and contributors. This proposal outlines a comprehensive approach to drive security improvements across the CNCF ecosystem, ultimately contributing to the resilience and reliability of cloud-native technologies.\n\nProject Deliverables:\n\nAdoption and integration of OpenSSF Scorecards.\n\nRemediation of Identified Vulnerabilities which includes things like code fixes, configuration changes, and security enhancements.\n\nImprovement of OpenSSF Scorecard Scores by focusing on key security metrics and risk assessments.\n\nIntegration of OSS-Fuzz, Google's continuous fuzzing service, into the CNCF ecosystem to identify and address security vulnerabilities through automated fuzz testing.\n\nEnhanced Build/Release Security.",
          "difficulty": null,
          "id": "proj_cncf_2024_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/58vdBYb3/",
          "proposal_id": null,
          "short_description": "The Cloud Native Computing Foundation (CNCF) hosts a diverse ecosystem of cloud-native projects. Ensuring the security of these projects is paramount...",
          "slug": "cncf-gosst-collaboration-enhancing-security-across-cncf-ecosystem",
          "status": "completed",
          "student_name": "Harshita Sao",
          "student_profile": null,
          "tags": [
            "ai",
            "cloud",
            "ui"
          ],
          "title": "CNCF GOSST Collaboration - Enhancing Security Across CNCF Ecosystem"
        },
        {
          "code_url": "https://github.com/GLVSKiriti/GSoC-2024",
          "description": "This project aims to upgrading the event-generator to improve its testing and bench-marking capabilities, its reliability, and its consistency, and developing new Continuous Integration pipelines based on it.The end goal is to evolve the event-generator and make it the standard tool for systematically assessing the correctness and performance of Falco’s threat detection capabilities at every release and development cycle",
          "difficulty": null,
          "id": "proj_cncf_2024_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/CmNUKI2a/",
          "proposal_id": null,
          "short_description": "This project aims to upgrading the event-generator to improve its testing and bench-marking capabilities, its reliability, and its consistency, and...",
          "slug": "falco-upgrading-event-generator-and-automating-falco-performance-testing",
          "status": "completed",
          "student_name": "GLVS Kiriti",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Falco: Upgrading event-generator and automating Falco performance testing"
        },
        {
          "code_url": "https://docs.google.com/document/d/1FufFdOX2z_8NqX1Jofi4gzx77JA2pRq49iR6OHUi0zE/edit?usp=sharing",
          "description": "This project aims to advance the support for _created lines, or Created Timestamps, in Prometheus. Building on the groundwork laid during GSoC 2023 by @ArthurSens, who introduced this concept, my mentorship will focus on refining the parsing of _created lines from the OpenMetrics (OM) Text format and proposing an optimized solution for their efficient processing. The initial implementation encountered issues with excessive memory usage, so this work will also involve benchmarking and optimizing the OM parser to identify and address potential inefficiencies. Additionally, there is the possibility of calculating or auto-generating created timestamps per scrape job to extend compatibility with OTLP/PRW 2.0.",
          "difficulty": null,
          "id": "proj_cncf_2024_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/OldSbeUU/",
          "proposal_id": null,
          "short_description": "This project aims to advance the support for _created lines, or Created Timestamps, in Prometheus. Building on the groundwork laid during GSoC 2023...",
          "slug": "prometheus-continued-support-for-created-timestamps",
          "status": "completed",
          "student_name": "Manik Rana",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Prometheus: Continued support for created timestamps"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2024/organizations/cncf/"
    },
    "year_2025": {
      "num_projects": 11,
      "projects": [
        {
          "code_url": null,
          "description": "Abstract: This proposal outlines a plan to enhance Meshery's relationship evaluation capabilities by implementing client-side policy evaluation using WebAssembly. By integrating OPA's WebAssembly compilation capabilities into Meshery's UI, I aim to enable real-time evaluation of complex Rego policies, providing users with immediate feedback on configuration changes and policy compliance. This enhancement will significantly improve the user experience when designing their designs and will make the policy evaluation distributed hence reducing load on a meshery server Problem Statement Meshery currently doesn't support evaluating policies in real-time on the client side. The existing approach ( relying on the rest api interface exposed by meshery-server) introduce s latency when policy evaluation occurs server-side, limiting the responsiveness of the UI when users make configuration changes. Additionally, as policies become more complex and numerous, the ability to quickly validate configurations against these policies becomes increasingly important for a smooth user experience. Proposed Solution: Use opas capibilty to compile rego policies directly into wasm plans and then integrate the evaluation process in ui using OPA's JavaScript SDK, which provides a simpler way to load and evaluate Rego policies compiled to WebAssembly. This approach is more lightweight and performant . Deliverables : - Real time evaluation of policies in ui - Keeping the support for both targets of evaluation backend or realtime on frontend - Making the evaluation responsive and performant by implementing webworkers , caching",
          "difficulty": "advanced",
          "id": "proj_cncf_2025_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/2aGkn4JN",
          "proposal_id": "lsBrNb6O",
          "short_description": "Abstract: This proposal outlines a plan to enhance Meshery's relationship evaluation capabilities by implementing client-side policy evaluation using...",
          "slug": "real-time-policy-evaluation-in-meshery-ui-using-opa-webassembly",
          "status": "in-progress",
          "student_name": "Aabid Ali",
          "student_profile": null,
          "tags": [
            "java",
            "javascript",
            "web",
            "api",
            "ai"
          ],
          "title": "Real-Time Policy Evaluation in Meshery UI using OPA WebAssembly"
        },
        {
          "code_url": null,
          "description": "Problem: \nKubeStellar (KS) lacks an automated system to measure and visualize data-plane performance (e.g., sync latencies) under AI workloads, making optimization and debugging challenging.\n\nSolution:\n1. Instrument KS with OpenTelemetry/Prometheus to emit sync latency/error metrics.\n2. Build a pipeline (TimescaleDB + Fluentd) to collect, store, and aggregate metrics.\n3. Embed Grafana dashboards into KS UI for real-time monitoring.\n4. Benchmark AI workloads (e.g., distributed TensorFlow) to validate scalability.\n\nDeliverables:\n1. Go-based metric instrumentation in KS core.\n2. Automated aggregation service (P95, error rates).\n3. Prebuilt Grafana dashboards (latency, throughput).\n4. Documentation + video demo.\n\nImpact: Enables data-driven optimization of KS for large-scale AI workloads.",
          "difficulty": null,
          "id": "proj_cncf_2025_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/6P4Ds9En",
          "proposal_id": "ne9hctjG",
          "short_description": "Problem: KubeStellar (KS) lacks an automated system to measure and visualize data-plane performance (e.g., sync latencies) under AI workloads, making...",
          "slug": "automating-benchmarking-of-kubestellar-data-plane-for-ai-workloads",
          "status": "in-progress",
          "student_name": "Asmit Kumar Rai",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Automating Benchmarking of KubeStellar Data-Plane for AI Workloads"
        },
        {
          "code_url": null,
          "description": "Kubewarden is a universal policy engine for Kubernetes enabling policy-as-code. It allows users to define and enforce policies for their Kubernetes clusters using any programming language that generates WebAssembly binaries. Recently, Bytecode Alliance introduced Javy, a JavaScript to WebAssembly compiler. This makes it possible to write Kubewarden policies in JavaScript. This project aims to create an idiomatic JavaScript SDK that allows users to write Kubewarden policies in JavaScript.\nThis requires several features including Policy Authoring API. Host Capabilities APIs, Host Capabilities Bridge, Compilation Pipeline, Testing and Validation, Documentation and Tutorials",
          "difficulty": null,
          "id": "proj_cncf_2025_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/SFABJqNk",
          "proposal_id": "tRkLWfUo",
          "short_description": "Kubewarden is a universal policy engine for Kubernetes enabling policy-as-code. It allows users to define and enforce policies for their Kubernetes...",
          "slug": "allow-kubewarden-policies-to-be-written-using-javascript",
          "status": "in-progress",
          "student_name": "Esosa Ohangbon",
          "student_profile": null,
          "tags": [
            "java",
            "javascript",
            "web",
            "api",
            "ai"
          ],
          "title": "Allow Kubewarden Policies to be Written using JavaScript"
        },
        {
          "code_url": null,
          "description": "This project aims to enhance the security of WasmEdge plug-ins by exporting key WASI APIs, thereby ensuring a robust and secure virtual filesystem sandbox for file operations. With the rapid growth of AI applications, WasmEdge plug-ins have become indispensable for tasks such as natural language processing, image synthesis, and speech recognition. However, direct file system access in current implementations exposes critical security risks. To address this, our proposal focuses on designing and implementing a dedicated filesystem sandbox API that restricts file read/write operations to pre-authorized directories. The initial phase will concentrate on the WASI-NN plug-in and other simpler file I/O functions, with potential future enhancements to more complex applications like Stable Diffusion’s image-loading functionality.\nOur comprehensive plan includes an in-depth study of the WasmEdge sandbox architecture, API design and integration, modification of internal plugin call patterns, and the development of rigorous test cases to validate sandbox effectiveness. Detailed documentation and developer guidelines will be prepared to facilitate secure plugin development. With a project timeline from June 2 to September 1, this initiative will leverage my background in virtualization, parallel computing and my past contributions to WasmEdge. The expected outcome is a significant improvement in the security and isolation of file operations in WasmEdge plug-ins, paving the way for safer and more reliable deployment of AI-driven applications.",
          "difficulty": "advanced",
          "id": "proj_cncf_2025_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/N7m7gDib",
          "proposal_id": "817rVbuv",
          "short_description": "This project aims to enhance the security of WasmEdge plug-ins by exporting key WASI APIs, thereby ensuring a robust and secure virtual filesystem...",
          "slug": "virtual-filesystem-security-for-wasmedge-plug-ins-with-exporting-wasi-apis-proposal",
          "status": "in-progress",
          "student_name": "grorge",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "ui"
          ],
          "title": "Virtual filesystem security for WasmEdge plug-ins with exporting WASI APIs - Proposal"
        },
        {
          "code_url": null,
          "description": "This project aims to integrate AI agents with Knative Functions by developing tools for an MCP server that allows agents to dynamically create and deploy functions using natural language prompts via MCP-compatible clients.",
          "difficulty": null,
          "id": "proj_cncf_2025_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/llt9vHfu",
          "proposal_id": "JdkGYb6z",
          "short_description": "This project aims to integrate AI agents with Knative Functions by developing tools for an MCP server that allows agents to dynamically create and...",
          "slug": "knative-functions-ai-agent-callbacks",
          "status": "in-progress",
          "student_name": "Kapil Sareen",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Knative: Functions AI Agent Callbacks"
        },
        {
          "code_url": null,
          "description": "Jaeger’s Service Performance Management (SPM) currently requires a complex setup with a separate processor and Prometheus storage to compute RED metrics. This project simplifies SPM by using Elasticsearch/OpenSearch trace storage to directly derive metrics, eliminating extra components. I will implement an ElasticsearchMetricsReader, update configurations, ensure OpenSearch compatibility, and add tests and documentation. Deliverables include a new development environment, simplified configuration, integration tests, OpenSearch support, updated documentation, and load testing for scalability.",
          "difficulty": "advanced",
          "id": "proj_cncf_2025_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/ZTLyi8dO",
          "proposal_id": "7ctlcY5h",
          "short_description": "Jaeger’s Service Performance Management (SPM) currently requires a complex setup with a separate processor and Prometheus storage to compute RED...",
          "slug": "simplified-spm-deployment-with-elasticsearchopensearch-for-jaeger",
          "status": "in-progress",
          "student_name": "Minh Nguyen Dang",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Simplified SPM deployment with ElasticSearch/OpenSearch for Jaeger"
        },
        {
          "code_url": null,
          "description": "etcd is the “source-of-truth” database behind Kubernetes and many other cloud-native systems, but heavy LIST and WATCH traffic can slow it down. Kubernetes solved this inside the API server with a highly-tuned watch-cache; we want to give the same speed-up to everyone who speaks to etcd. \n\nThis project delivers a plug-and-play cache for etcd, available as a Go library and a standalone gRPC proxy. Key features include: (1) Adaptive history buffer that keeps recent updates around so slow clients can rewind without reloading everything, and automatically frees up space when they fall too far behind; (2) B-tree state mirror: in-memory, sorted store that serves range queries and paginated lists in microseconds; (3) Point-in-time snapshots for reading past versions instantly, with seamless fallback to etcd whenever the cache gets out of sync; (4) Built-in consistency: most reads hit the cache; critical reads either wait for the latest data or transparently go back to etcd; (5) Plugins and indexes for custom serialization format and extra searchable fields; (6) Language-agnostic gRPC proxy with TLS and RBAC, so any service, no matter the language, can use it without touching a line of existing code. The deliverables will include comprehensive tests, Prometheus metrics, benchmarks, and integration examples. By reusing this cache, etcd-backed projects and future CNCF tools will slash cluster traffic, cut read latency to microseconds, and avoid bespoke caching code, all with one simple import or one sidecar.",
          "difficulty": null,
          "id": "proj_cncf_2025_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/9A3Z5dv1",
          "proposal_id": "uvQr1JFf",
          "short_description": "etcd is the “source-of-truth” database behind Kubernetes and many other cloud-native systems, but heavy LIST and WATCH traffic can slow it down....",
          "slug": "generic-high-performance-caching-library-for-etcd",
          "status": "in-progress",
          "student_name": "Peter Chang",
          "student_profile": null,
          "tags": [
            "api",
            "ml",
            "ai",
            "database",
            "kubernetes"
          ],
          "title": "Generic High-Performance Caching Library for etcd"
        },
        {
          "code_url": null,
          "description": "This project aims to enable AI training in a multi-cluster environment while ensuring data privacy through federated learning. In a multi-cluster environment, where different clusters need to access data, federated learning is introduced to safeguard sensitive information.\nOur goal is to provide a unified interface that allows existing federated learning frameworks, such as OpenFL, NVIDIA FLARE, and Flower, to operate seamlessly in a multi-cluster environment without modifying their existing workflows. These frameworks will continue handling local model training within their respective clusters while aggregating updates into a global model on the hub cluster.\nTo achieve this, we leverage Open Cluster Management (OCM) APIs, including Placement and ManifestWork, to standardize federated learning workflows. By integrating frameworks through a unified interface, we harness OCM’s capabilities to deliver scalable and privacy-preserving AI training solutions in multi-cluster environments.",
          "difficulty": null,
          "id": "proj_cncf_2025_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/mUzLWY6T",
          "proposal_id": "XwdBY62e",
          "short_description": "This project aims to enable AI training in a multi-cluster environment while ensuring data privacy through federated learning. In a multi-cluster...",
          "slug": "privacy-preserving-and-efficient-ai-model-training-across-multi-cluster",
          "status": "in-progress",
          "student_name": "Shichao",
          "student_profile": null,
          "tags": [
            "api",
            "ml",
            "ai"
          ],
          "title": "Privacy-preserving and efficient AI model training across multi-cluster"
        },
        {
          "code_url": null,
          "description": "The current Vitess RAG chatbot which uses documentation, Slack discussions, and GitHub issues data, has low accuracy. This project aims to improve the accuracy and security of the system by:\n\n- Enhancing retrieval with techniques like query expansion, re-ranking, metadata filtering, inclusion of image data, and summarizing chunks using LLMs before embedding using tools like Langchain\n\n- Automating the embedding of updated documentation into the vector database using Kestra pipelines\n\n-Better benchmarking with tools like Giskard and RAGAS\n\n-Using user feedback to improve relevance \n\n- Content filtering using LLMs safety settings\n\n-Implementing caching for faster responses and lower costs, along with rate limiting for infrastructure stability",
          "difficulty": null,
          "id": "proj_cncf_2025_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/FdTZdTRr",
          "proposal_id": "ojQI5YLr",
          "short_description": "The current Vitess RAG chatbot which uses documentation, Slack discussions, and GitHub issues data, has low accuracy. This project aims to improve...",
          "slug": "enhancements-for-rag-chatbot-for-vitess",
          "status": "in-progress",
          "student_name": "sreehariX",
          "student_profile": null,
          "tags": [
            "ai",
            "database"
          ],
          "title": "Enhancements for RAG Chatbot for Vitess"
        },
        {
          "code_url": null,
          "description": "Lima(LInux MAchines) is a tool that helps to run Linux Virtual Machines on macOS and other hosts, with a focus on running containers on them with auto file sharing and port forwarding. Lima's internal virtual machine backend drivers are tightly connected with the main binary, making maintenance difficult and cluttering the main binary. This makes it difficult to incorporate different virtual machine backends. \n\nThis project seeks to construct and develop a plugin subsystem or framework that offers support for multiple virtual machine backends that can be integrated into the main Lima application via gRPC or built into the main binary.",
          "difficulty": null,
          "id": "proj_cncf_2025_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/0L1g1OFW",
          "proposal_id": "NmzkIsqi",
          "short_description": "Lima(LInux MAchines) is a tool that helps to run Linux Virtual Machines on macOS and other hosts, with a focus on running containers on them with...",
          "slug": "lima-support-for-virtual-machine-plugin-subsystem",
          "status": "in-progress",
          "student_name": "unsuman_",
          "student_profile": null,
          "tags": [
            "ai",
            "ui",
            "ux",
            "backend"
          ],
          "title": "Lima: Support for Virtual Machine Plugin Subsystem"
        },
        {
          "code_url": null,
          "description": "This project aims to create a GitHub Action similar to Dependabot for Kubebuilder, automating the process of regenerating scaffolds and preserving custom code when new versions of Kubebuilder are released. This solution ensures that projects stay updated with best practices, bug fixes, and features, ultimately improving maintainability and adoption by reducing the complexity of manual updates.",
          "difficulty": "advanced",
          "id": "proj_cncf_2025_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/j6huoI3v",
          "proposal_id": "UUryDq23",
          "short_description": "This project aims to create a GitHub Action similar to Dependabot for Kubebuilder, automating the process of regenerating scaffolds and preserving...",
          "slug": "kubebuilder-automating-operator-maintenance-driving-better-results-with-less-overhead",
          "status": "in-progress",
          "student_name": "Vitor Floriano",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Kubebuilder: Automating Operator Maintenance - Driving Better Results with Less Overhead"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/programs/2025/organizations/cncf"
    }
  },
  "first_time": false,
  "contact": {
    "email": "soc@cncf.io",
    "guide_url": "https://github.com/cncf/mentoring",
    "ideas_url": "https://github.com/cncf/mentoring/blob/main/programs/summerofcode/2025.md",
    "irc_channel": "http://slack.cncf.io",
    "mailing_list": "https://github.com/cncf/mentoring/discussions"
  },
  "social": {
    "blog": "https://www.cncf.io/newsroom/blog/",
    "discord": null,
    "facebook": null,
    "github": null,
    "gitlab": null,
    "instagram": null,
    "linkedin": null,
    "mastodon": null,
    "medium": null,
    "reddit": null,
    "slack": null,
    "stackoverflow": null,
    "twitch": null,
    "twitter": "https://twitter.com/cloudnativefdn",
    "youtube": null
  },
  "meta": {
    "version": 1,
    "generated_at": "2026-01-25T15:28:52.991Z"
  }
}