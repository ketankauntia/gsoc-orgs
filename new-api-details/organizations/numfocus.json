{
  "id": "692251de53dd9d7326d33e3f",
  "slug": "numfocus",
  "name": "NumFOCUS",
  "category": "Science and medicine",
  "description": "NumFOCUS promotes open source scientific software.",
  "image_url": "https://summerofcode.withgoogle.com/media/org/numfocus/wimcwc2v6kjlidqc-360.png",
  "img_r2_url": "https://pub-268c3a1efc8b4f8a99115507a760ca14.r2.dev/numfocus.webp",
  "logo_r2_url": null,
  "url": "https://numfocus.org",
  "active_years": [
    2016,
    2017,
    2018,
    2019,
    2020,
    2021,
    2022,
    2023,
    2024,
    2025
  ],
  "first_year": 2016,
  "last_year": 2025,
  "is_currently_active": true,
  "technologies": [
    "python",
    "javascript",
    "r",
    "julia",
    "c",
    "c++"
  ],
  "topics": [
    "data science",
    "graphics",
    "scientific computing",
    "numerical computation",
    "machine learning",
    "data visualization",
    "big data",
    "high performance computing",
    "statistical computing",
    "pydata",
    "numerical computing",
    "ai"
  ],
  "total_projects": 277,
  "stats": {
    "avg_projects_per_appeared_year": 27.7,
    "projects_by_year": {
      "year_2016": 7,
      "year_2017": 10,
      "year_2018": 40,
      "year_2019": 19,
      "year_2020": 28,
      "year_2021": 45,
      "year_2022": 37,
      "year_2023": 24,
      "year_2024": 35,
      "year_2025": 32
    },
    "students_by_year": {
      "year_2016": 7,
      "year_2017": 10,
      "year_2018": 40,
      "year_2019": 19,
      "year_2020": 28,
      "year_2021": 45,
      "year_2022": 37,
      "year_2023": 24,
      "year_2024": 35,
      "year_2025": 32
    },
    "total_students": 270
  },
  "years": {
    "year_2016": {
      "num_projects": 7,
      "projects": [
        {
          "code_url": "http://chrismedrela.github.io/end-of-gsoc",
          "description": "<p>Software Carpentry (SWC) has a workflow for Instructor Trainings. Currently, it uses Etherpads and Google Docs spreadsheets, which slows down SWC Admins and Trainers whose time is already precious. The goal is to extend AMY (Django-base web application for SWC Admins) to manage the process of training people to be instructors, to avoid manual data copying and synchronization and make the entire process smoother.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2016_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2016/projects/5514874910146560/",
          "proposal_id": null,
          "short_description": "Software Carpentry (SWC) has a workflow for Instructor Trainings. Currently, it uses Etherpads and Google Docs spreadsheets, which slows down SWC...",
          "slug": "manage-workflow-for-softwaredata-carpentry-instructor-training",
          "status": "completed",
          "student_name": "Chris Medrela",
          "student_profile": null,
          "tags": [
            "web",
            "ai"
          ],
          "title": "Manage workflow for Software/Data Carpentry instructor training"
        },
        {
          "code_url": "https://github.com/JuliaOpt/MathProgBase.jl/pull/116",
          "description": "<p><strong>Pre-solving</strong> is the process of detecting redundancies in an optimization problem and removing them so that the problems that are fed to solvers are properly formulated. The reduced optimization problem is now solved by the solver. This has the two-fold benefit of speeding up the optimization process, and higher accuracy in solutions. Since smaller problems are fed to the solver (eg. SCS), the bottleneck call to the solver has now become significantly faster.</p>\n<p>Ideally, we would want to remove the types of redundancy which lead to reduction in total solution time. But this isn't always possible. There is also a trade-off between time spent in the pre-solve procedure and the amount of redundancy detected by our procedure.  We take the approach mentioned in the paper by Andersen.</p>\n<p><strong>Motto</strong> - Find simple forms of redundancies and find them quick.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2016_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2016/projects/5278266772422656/",
          "proposal_id": null,
          "short_description": "Pre-solving is the process of detecting redundancies in an optimization problem and removing them so that the problems that are fed to solvers are...",
          "slug": "presolve-routines-for-lp-and-sdp-within-convexjl",
          "status": "completed",
          "student_name": "ramcha24",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Presolve Routines for LP and SDP within Convex.jl"
        },
        {
          "code_url": "http://pkofod.github.io/2016/08/31/gsocfinal/",
          "description": "<p>The purpose of this GSoC project is to work on a variety of loose ends in, and general improvements to, the optimization package <a href=\"https://github.com/JuliaOpt/Optim.jl\" target=\"_blank\">Optim.jl</a>. Optim.jl is written entirely in the <a href=\"https://github.com/JuliaLang/julia\" target=\"_blank\">Julia Language</a>, and organized under the <a href=\"https://github.com/JuliaOpt/\" target=\"_blank\">JuliaOpt</a> organization. Improvements are in the form of a unified documentation effort, performance tests, improved algorithms, unit tests, and general bug fixing. At the end of GSoC Optim.jl should be a relatively well-polished, documented, and tested package for optimization in Julia.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2016_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2016/projects/4535208976056320/",
          "proposal_id": null,
          "short_description": "The purpose of this GSoC project is to work on a variety of loose ends in, and general improvements to, the optimization package Optim.jl. Optim.jl...",
          "slug": "improving-the-state-of-optimjl",
          "status": "completed",
          "student_name": "pkofod",
          "student_profile": null,
          "tags": [],
          "title": "Improving the state of Optim.jl"
        },
        {
          "code_url": "https://github.com/matplotlib/matplotlib/pulls?utf8=%E2%9C%93&q=author%3Astory645%20",
          "description": "<p>While matplotlib 1.5 added direct support for plotting data frames, there are still a few related tasks yet to be done.  An important one is detecting when plotting categorical data (i.e. enumerations) and updating the tick labels accordingly.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2016_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2016/projects/4586869111128064/",
          "proposal_id": null,
          "short_description": "While matplotlib 1.5 added direct support for plotting data frames, there are still a few related tasks yet to be done.  An important one is...",
          "slug": "categorical-axis",
          "status": "completed",
          "student_name": "story645",
          "student_profile": null,
          "tags": [],
          "title": "Categorical Axis"
        },
        {
          "code_url": "https://github.com/prerit2010/Result-aggregation-server/commits/master?author=prerit2010",
          "description": "<p>Software Carpentry has been teaching researchers in science, engineering, medicine, and related disciplines the computing skills they need to get more done in less time and with less pain. Several workshops are held in which students are required to setup their system by installing necessary packages.</p>\n<p>Currently software carpentry provides the <a href=\"https://github.com/wking/swc-setup-installation-test\" target=\"_blank\">installation-test scripts</a> so that, students can check whether they've successfully installed all software required during the workshop. But the results generated by the scripts are not collected anywhere.</p>\n<p>In this project a server is to be written for storing results of installation-testing scripts, and also enhancing the testing scripts by adding an option for users to collect results and send them to the server. It will help in figuring out what all problems students usually face in installations ,and also the packages which need to be deprecated in future.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2016_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2016/projects/6539065964888064/",
          "proposal_id": null,
          "short_description": "Software Carpentry has been teaching researchers in science, engineering, medicine, and related disciplines the computing skills they need to get...",
          "slug": "result-aggregation-server-for-the-installation-test-scripts",
          "status": "completed",
          "student_name": "Prerit Garg",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Result-aggregation server for the installation-test scripts"
        },
        {
          "code_url": "https://goelakash.wordpress.com/2016/08/21/gsoc-blog-wrap-up/",
          "description": "<p>One of the ways the Retriever makes it easy to add new datasets is by allowing datasets to be added using simple plain text descriptions of the data that are then parsed into Python. There is an emerging standard for this kind of metadata called datapackage.json.</p>\n<p>This project would upgrade the EcoData Retriever to use the datapackage.json standard.</p>\n<p>Additionally, I propose to add Python3 support as well as I find that its an easy enough issue to resolve during the 12 weeks of SoC.</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2016_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2016/projects/4850216104624128/",
          "proposal_id": null,
          "short_description": "One of the ways the Retriever makes it easy to add new datasets is by allowing datasets to be added using simple plain text descriptions of the data...",
          "slug": "upgrade-to-datapackagejson-standard",
          "status": "completed",
          "student_name": "goelakash",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "Upgrade to datapackage.json standard"
        },
        {
          "code_url": "https://topicmodel2016.wordpress.com/2016/08/21/gsoc-final-submission/",
          "description": "<p>Dynamic Topic Models are used to model the evolution of topics in a corpus, over time. The Dynamic Topic Model is part of a class of probabilistic topic models, and unlike the previous models developed, takes into account time-series data. The idea behind this project proposal is to implement Dynamic Topic Models while taking care of Gensim's philosophy of being memory-independent and robust.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2016_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2016/projects/4938712832016384/",
          "proposal_id": null,
          "short_description": "Dynamic Topic Models are used to model the evolution of topics in a corpus, over time. The Dynamic Topic Model is part of a class of probabilistic...",
          "slug": "dynamic-topic-models-gensim",
          "status": "completed",
          "student_name": "bhargavvader",
          "student_profile": null,
          "tags": [],
          "title": "Dynamic Topic Models - Gensim"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2016/organizations/4647600753999872/"
    },
    "year_2017": {
      "num_projects": 10,
      "projects": [
        {
          "code_url": "https://katierose1029.github.io/jekyll/update/2017/08/29/Final-Submission-of-Work.html",
          "description": "<p>Serialization is the process in which a data structure or object is translated\nand stored in the format of a file compatible in memory then reconstructed\nin another environment.</p>\n<p>The following link will bring you to a Matplotlib Enhancement Proposal\nconcerning the serialization of Matplotlib figures and widgets.<br>\n<a href=\"https://github.com/matplotlib/matplotlib/wiki/MEP25#id7\" target=\"_blank\">MEP25: Serialization</a></p>\n<p>Jupyter Notebook allow coders to compute data in an web - based interactive\nenvironment.  Ipywidgets is a module that extends Jupyter Notebooks and\nIpython Kernel in that a coder has the ability to create interactive\nHTML - based widgets.  PythreeJS is an extension of Ipywidgets, as it is a\nbridge between Python widget creation and HTML widgets with the incorporation\nof the Javascript 3-D graphics library, ThreeJS.</p>\n<p><strong>What if we had the ability to serialize data from matplotlib figures to json\nobjects then render the data in a PythreeJS widget?</strong></p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/6362677832056832/",
          "proposal_id": null,
          "short_description": "Serialization is the process in which a data structure or object is translated\nand stored in the format of a file compatible in memory then...",
          "slug": "matplotlib-serialization-pythreejs",
          "status": "completed",
          "student_name": "katiec1029",
          "student_profile": null,
          "tags": [
            "python",
            "java",
            "javascript",
            "web",
            "ml"
          ],
          "title": "Matplotlib Serialization & PythreeJS"
        },
        {
          "code_url": "https://github.com/michalhabera/gsoc-summary/blob/master/README.md",
          "description": "<p>XDMF is a file format which is designed for very large simulation datasets. \nThe main file is XML, but there is provision for the \"heavy data\" to be stored in HDF5 using \nMPI-IO in parallel. Datasets may be hundreds of GB in size. In FEniCS we have used XDMF to produce \nvisualisations, but it is also highly desirable to use for checkpointing, i.e. saving the current \nstate of a simulation and reading it back in later. The data structures in FEniCS do not map \ndirectly onto the data structures expected by the current implementation of XDMF. We would like \nto be able to save FEniCS data structures directly in XDMF, and still be able to visualise the data.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/6379340962988032/",
          "proposal_id": null,
          "short_description": "XDMF is a file format which is designed for very large simulation datasets. \nThe main file is XML, but there is provision for the \"heavy data\" to be...",
          "slug": "develop-xdmf-format-for-visualisation-and-checkpointing",
          "status": "completed",
          "student_name": "Michal Habera",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Develop XDMF format for visualisation and checkpointing"
        },
        {
          "code_url": "https://github.com/matplotlib/matplotlib/pull/8738",
          "description": "<p>All of the color mapping in Matplotlib is currently derived from<code>ScalerMappable</code> which as the name suggests maps scalers from <code>R^1 -&gt;R^4</code> RGBA color space.  It is common to want to map a vector tocolors, for example to control the alpha based on a second value in ascatter plot or to show the orientation of a field.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/6396963482238976/",
          "proposal_id": null,
          "short_description": "All of the color mapping in Matplotlib is currently derived fromScalerMappable which as the name suggests maps scalers from R^1 ->R^4 RGBA color...",
          "slug": "2d-color-maps",
          "status": "completed",
          "student_name": "Harshit Patni",
          "student_profile": null,
          "tags": [],
          "title": "2d Color Maps"
        },
        {
          "code_url": "http://nbviewer.jupyter.org/gist/IvanYashchuk/48bff62b155e31f85de975b24b23e4cb",
          "description": "<p>One of the first steps in the finite element method (FEM) is splitting the domain on which the partial differential equation (PDE) is solved into small parts, called cells, which in sum make a mesh. FEniCS has always supported meshes consisting of simplex cells (e.g. triangles and tetrahedrons), but has limited support for meshes consisting of quadrilateral (quad) and hexahedral (hex) cells. Finite element problems solved on quad/hex meshes often have better approximation properties and better robustness to cell distortion than those solved on simplex meshes. The project idea aims at being able to assemble and solve the simplest PDE, a Poisson's equation, in 2D (quad mesh) and 3D (hex mesh) in FEniCS.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/6408302195900416/",
          "proposal_id": null,
          "short_description": "One of the first steps in the finite element method (FEM) is splitting the domain on which the partial differential equation (PDE) is solved into...",
          "slug": "develop-assembly-of-finite-element-forms-on-quadrilateral-and-hexahedral-meshes-fenics",
          "status": "completed",
          "student_name": "Ivan Yashchuk",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Develop assembly of finite element forms on quadrilateral and hexahedral meshes [FEniCS]"
        },
        {
          "code_url": "https://medium.com/data-retriever-gsoc17/data-retriever-final-report-95ef1d6acc59",
          "description": "<p>Data Retriever automates the tasks of finding, downloading, and cleaning up publicly available data, and then stores them in a local database or as .csv files. Simply put, it's a package manager for data. This allows data analysts to spend a majority of their time in analysing rather than in cleaning up or managing data.</p>\n<p>The Data Retriever is written in Python. It currently has a command line interface (CLI) and can also be used through an associated R package that wraps this CLI. Adding a native Python interface and a Julia package wrapping the CLI would provide access to the tools provided by the Data Retriever in the three major open source languages for data oriented computing.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/5402340592975872/",
          "proposal_id": null,
          "short_description": "Data Retriever automates the tasks of finding, downloading, and cleaning up publicly available data, and then stores them in a local database or as...",
          "slug": "python-and-julia-interface-for-data-retriever",
          "status": "completed",
          "student_name": "Shivam Negi",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "database"
          ],
          "title": "Python and Julia Interface for Data Retriever"
        },
        {
          "code_url": "https://drive.google.com/file/d/0B2iiuXZtfXQ_c0g0cXQtUThPblE/view",
          "description": "<p>Gensim<a href=\"http://radimrehurek.com/gensim/\" target=\"_blank\">[1]</a> is a topic-modeling package in Python for <em>unsupervised</em> learning. This implies that to be able to usefully apply it to a real business problem, the output generated must go to a supervised classifier. Presently, the most popular supervised learning packages are scikit-learn<a href=\"http://scikit-learn.org/\" target=\"_blank\">[2]</a> (for simpler data analysis) and Keras<a href=\"https://keras.io\" target=\"_blank\">[3]</a> (for artificial neural networks). Hence, the objective of this project is to create wrappers for scikit-learn and Keras around all Gensim models for seamless integration of Gensim with these libraries.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/6145041907056640/",
          "proposal_id": null,
          "short_description": "Gensim[1] is a topic-modeling package in Python for unsupervised learning. This implies that to be able to usefully apply it to a real business...",
          "slug": "gensim-gensim-integration-with-scikit-learn-and-keras",
          "status": "completed",
          "student_name": "Chinmaya Pancholi",
          "student_profile": null,
          "tags": [
            "python",
            "ml"
          ],
          "title": "Gensim : Gensim integration with scikit-learn and Keras"
        },
        {
          "code_url": "https://rare-technologies.com/paruls-gsoc-2017-summary-training-and-topic-visualizations-in-gensim/",
          "description": "<p>Knowing about the progress and performance of a model, as we train them, could be very helpful in understanding it’s learning process and makes it easier to debug and optimize them. It could also help us affirm the results from our models or inspect them in case of counterintuitive behaviors. Hence, I aim to provide a step-by-step process of visualizing training statistics for people, who want to keep a tab on learning processes of their gensim models, and want to optimize it through experimentation with hyperparameters.</p>\n<p>The next phase of my project would aim to introduce and build a visualization module based on Gensim models and features. This would allow the interactive exploration of applications based on Gensim and would also enable users to do a qualitative assessment of their models and analyze the results. I aim to focus on implementing a visual framework for the exploration of topic models, taking cues from TMVE, pyLDAvis, and add more options to visualize data attributes and compare across the different topic models.</p>\n<p>This work can naturally be extended to various other features in Gensim and to the upcoming ones, to have an associated visualization.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/6231784408743936/",
          "proposal_id": null,
          "short_description": "Knowing about the progress and performance of a model, as we train them, could be very helpful in understanding it’s learning process and makes it...",
          "slug": "training-and-topic-visualizations",
          "status": "completed",
          "student_name": "Parul Sethi",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Training and Topic Visualizations"
        },
        {
          "code_url": "http://utkarshbansal.me/blog/The-Journey/",
          "description": "<p>Testing is crucial to the development of any software and MDAnalysis currently uses nose to test their code. Unfortunately, nose is no longer under active development so the community has decided to shift over to pytest. Another problem is the performance of the current testsuite in terms of execution time. Currently the TravisCI build takes around 45 minutes (50 min. being the cap). This causes builds to fail because they are terminated on exceeding the maximum execution time. The objective of this project is to implement this shift in a way that existing development work is not affected and to improve performance of the existing test cases and to make it more maintainable in general.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/5971269140873216/",
          "proposal_id": null,
          "short_description": "Testing is crucial to the development of any software and MDAnalysis currently uses nose to test their code. Unfortunately, nose is no longer under...",
          "slug": "port-to-pytest",
          "status": "completed",
          "student_name": "Utkarsh Bansal",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Port to pytest"
        },
        {
          "code_url": "https://ferrine.github.io/blog/2017/08/24/final-report/",
          "description": "<p>Variational inference is a great approach for doing really complex, often intractable Bayesian inference in approximate form. Common methods (e.g. ADVI) lack from complexity so that approximate posterior does not reveal the true nature of underlying problem. In some applications it can yield unreliable decisions.</p>\n<p>Recently on NIPS 2017 <a href=\"https://arxiv.org/abs/1610.09033\" target=\"_blank\">OPVI</a> framework was presented. It generalizes variational inverence so that the problem is build with blocks. The first and essential block is Model itself. Second is Approximation, in some cases $log Q(D)$ is not really needed. Necessity depends on the third and forth part of that black box, Operator and Test Function respectively.</p>\n<p>Not only ADVI and Langevin Stein Operator VI are applicable with OPVI framework. Normalizing, Householder Flows fit well for it.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2017_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/5985582387822592/",
          "proposal_id": null,
          "short_description": "Variational inference is a great approach for doing really complex, often intractable Bayesian inference in approximate form. Common methods (e.g....",
          "slug": "extend-variational-inference-methods-in-pymc3",
          "status": "completed",
          "student_name": "Maxim Kochurov",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Extend Variational Inference Methods in PyMC3"
        },
        {
          "code_url": "https://github.com/pymc-devs/pymc3/pull/2444/commits",
          "description": "<p>PyMC3 contains a rich suite of building blocks for probabilistic modeling and inference.  This proposal contains two parts:  first is finishing support for single precision, and second involves finishing Gaussian Process functionality.  I have already submitted a proposal about exploring alternative computation engines, and am open to working with the mentors on mixing and matching projects from each, for example, evaluating PyTorch in addition to the projects in this proposal.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2017_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2017/projects/6297500092727296/",
          "proposal_id": null,
          "short_description": "PyMC3 contains a rich suite of building blocks for probabilistic modeling and inference.  This proposal contains two parts:  first is finishing...",
          "slug": "single-precision-support-and-gaussian-process-functionality",
          "status": "completed",
          "student_name": "Bill Engels",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Single Precision Support and Gaussian Process Functionality"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2017/organizations/6630791836598272/"
    },
    "year_2018": {
      "num_projects": 40,
      "projects": [
        {
          "code_url": "https://eeshan9815.github.io/blog-gsoc/final-report/",
          "description": "<p>Interval arithmetic provides a way to perform computations with continuous sets of real numbers or vectors, for example to bound the range of a function over a given set.</p>\n<p>This can be used to find roots (zeros) of functions in a guaranteed way, by excluding regions where there are no roots and zooming in on roots, but always within a given interval.</p>\n<p>It can also be used to do global optimization of functions in a deterministic way, that is, find the global minimum of a non-convex, nonlinear function. Interval methods for global optimization provide a guaranteed bound for the global optimum, and sets that contain the optimizers.</p>\n<p>This project proposes to significantly improve these methods using techniques found in the interval arithmetic literature.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6348517324881920/",
          "proposal_id": null,
          "short_description": "Interval arithmetic provides a way to perform computations with continuous sets of real numbers or vectors, for example to bound the range of a...",
          "slug": "guaranteed-root-finding-and-global-optimization-with-intervals",
          "status": "completed",
          "student_name": "Eeshan Gupta",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Guaranteed Root Finding and Global Optimization with Intervals"
        },
        {
          "code_url": "https://piever.github.io/simpleblog/post/sputnik5/",
          "description": "<p>We will combine the JuliaDB.jl package, for tabular data manipulations in Julia, with WebIO.jl and InteractNext.jl to build a user-friendly web-based app for data analysis and visualizations.</p>\n<p>We will draw from PlugAndPlot.jl, a previous attempt based on QML and focused on the analysis of population data. The advantages of the new JuliaDB/WebIO based approach are:</p>\n<ul>\n<li>we can exploit JuliaDB's unique features, such as parallel storage and computing, support for online statistical techniques and machine learning techniques</li>\n<li>WebIO allows deploying in a wide variety of frameworks: the Julia IDE Juno's plot pane, Jupyter notebook, an Electron window or a web page via Mux.jl</li>\n</ul>\n<p>The web page deployment is particularly relevant in our view as it allows to make interactive data visualizations easily accessible online.</p>\n<p>Finally, rather than building a monolithic app, we will modularize our design to the extent possible, thus allowing different projects to reuse parts of it to create GUIs with different designs or based on different algorithms and visualization packages.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6580627356778496/",
          "proposal_id": null,
          "short_description": "We will combine the JuliaDB.jl package, for tabular data manipulations in Julia, with WebIO.jl and InteractNext.jl to build a user-friendly web-based...",
          "slug": "a-modern-tool-for-data-exploration-based-on-juliadb-and-webio",
          "status": "completed",
          "student_name": "Pietro Vertechi",
          "student_profile": null,
          "tags": [
            "web",
            "ml",
            "ui",
            "ux"
          ],
          "title": "A modern tool for data exploration based on JuliaDB and WebIO"
        },
        {
          "code_url": "https://maetshju.github.io/finalupdate.html",
          "description": "<p>Details of deep learning models and their performance are, unfortunately, often published without accompanying implementation code. Those models that come from speech recognition seem to be particularly susceptible to this phenomenon. The present project proposes to create a working implementation of a speech recognition model using the Flux library for the Julia programming language and contribute its code to the Flux model zoo. The model to be implemented is Zhang et al.'s (2017) model from their paper \"Towards end-to-end speech recognition with deep convolutional neural networks.\" Due to being implemented using only convolutional layers, this model will be lighter to train than previous models that have used heavier recurrent layers, while still achieving state-of-the-art performance. Having a working implementation of this network will be a step forward in opening the culture of automatic speech recognition. As a result, newcomers to the field will have a recent example to look at for inspiration, which is paramount because there are not many novice-friendly resources available for doing speech recognition research.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6582163948437504/",
          "proposal_id": null,
          "short_description": "Details of deep learning models and their performance are, unfortunately, often published without accompanying implementation code. Those models that...",
          "slug": "speech-recognition-for-the-flux-model-zoo",
          "status": "completed",
          "student_name": "Matthew C. Kelley",
          "student_profile": null,
          "tags": [
            "ai",
            "ux"
          ],
          "title": "Speech recognition for the Flux model zoo"
        },
        {
          "code_url": "https://avik-pal.github.io/blog/2018-08-13-Adding_Newer_Features_and_Speeding_up_Convolutions_in_Flux/",
          "description": "<p>Currently, FluxML/model-zoo has very few examples demonstrating the usage of Flux. In this project, I propose to implement several Convolutional Neural Network Models for Computer Vision Problems. I shall be implementing around 14 Neural Network Architectures. I will train these models on public datasets to demonstrate their performance.  In the process, I will contribute to Flux.jl the layers that are necessary to build those networks so that they can be easily reused.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6584740928815104/",
          "proposal_id": null,
          "short_description": "Currently, FluxML/model-zoo has very few examples demonstrating the usage of Flux. In this project, I propose to implement several Convolutional...",
          "slug": "computer-vision-using-fluxjl",
          "status": "completed",
          "student_name": "Avik Pal",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui",
            "ux"
          ],
          "title": "Computer Vision using Flux.jl"
        },
        {
          "code_url": "https://gist.github.com/AshKelly/9f45a6271a5f76d0b5441fb94005b2da",
          "description": "<p>yt is a package for analyzing and visualizing volumetric data. The current infrastructure of yt is designed to deal with adaptive mesh refinement (AMR) data. However, a wide range of modern N-body hydrodynamics simulations now use smoothed particle hydrodynamics (SPH) which produces data consisting of volume filling fields. The current implementation of yt takes this data fills a global octtree, and then treats it similarly to that of AMR data.</p>\n<p>The disadvantage of this treatment of SPH data is that it is not intuitive to users, it is slow and it does not represent the underlying nature of the data.</p>\n<p>This project aims to develop a yt API for SPH data that ensures all SPH fields return data defined at the locations of the particles. Whilst this would provide a more intuitive way to interact with the data, it is still important to interpolate particle data onto grids, as this is essential in visualisation. This can be achieved by taking inspiration from SPLASH. Thus, at the end of the project SPH fields would be able to be visualised using a \"scatter\" (in technical details) approach, inspired by SPLASH. This would allow the the SPH fields to be interpolated efficiently onto grids.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6622115465789440/",
          "proposal_id": null,
          "short_description": "yt is a package for analyzing and visualizing volumetric data. The current infrastructure of yt is designed to deal with adaptive mesh refinement...",
          "slug": "accessing-sph-data-and-interpolating-onto-grids",
          "status": "completed",
          "student_name": "Ashley Kelly",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "ui"
          ],
          "title": "Accessing SPH data and interpolating onto grids"
        },
        {
          "code_url": "https://justcalamari.github.io/jekyll/update/2018/08/10/worksubmission.html",
          "description": "<p>Conda-forge is a collection of recipes, build infrastructure, and distributions for the conda package manager that makes it easy for developers to make source packages installable via conda. Conda-forge keeps the conda recipes for its packages in separate GitHub repositories called feedstocks. Traditionally, when a package has been updated, it has been the job of the package maintainers to update the recipe in the feedstock with the proper metadata for the most recent version. Not all package maintainers remember to update the feedstock when releasing new versions, however, causing some packages on conda-forge to be out of date. Recently, the conda-forge autotick bot was developed to automatically track out of date feedstocks and open pull requests to bump them to the newest version of the source code. The bot is a work in progress and still in its early stages. This summer I will implement a series of fixes and enhancements to the bot.</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2018_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5649684605435904/",
          "proposal_id": null,
          "short_description": "Conda-forge is a collection of recipes, build infrastructure, and distributions for the conda package manager that makes it easy for developers to...",
          "slug": "conda-forge-bot-for-automatic-updates-of-recipes",
          "status": "completed",
          "student_name": "Justin Calamari",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Conda-Forge Bot for Automatic Updates of Recipes"
        },
        {
          "code_url": "https://nymanlauri.github.io/2018/08/13/LastPost.html",
          "description": "<p>The aim of this project is to implement eigenvalue problem solvers for sparse matrices in Julia in order to reduce the dependency of Julia language on ARPACK. During the GSoC program, my goal is to create a drop-in replacement for the current ’eigs’ function in pure Julia. The focus will be on nonsymmetric matrices, but if there is time, the implementation could be extended to cover symmetric matrices as well. As a part of this project, I will provide benchmarks comparing the performance of the new implementation of ’eigs’ versus the ARPACK’s implementation of ’eigs’ that is currently in use. The aim is to get this new method into the package IterativeSolvers.jl.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5706071888887808/",
          "proposal_id": null,
          "short_description": "The aim of this project is to implement eigenvalue problem solvers for sparse matrices in Julia in order to reduce the dependency of Julia language...",
          "slug": "implementing-eigenvalue-problem-solvers-for-sparse-matrices-in-julia",
          "status": "completed",
          "student_name": "Lauri Nyman",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Implementing Eigenvalue Problem Solvers for Sparse Matrices in Julia"
        },
        {
          "code_url": "http://seaninn.es/gsoc_blog/gsoc/2018/08/12/gsoc-submission.html",
          "description": "<p>This project would bring the mathematical prowess of Julia to the web with the near native performance of WebAssembly. The expected outcome of this project would be in compiling numerical kernels such as GCD and Matrix Multiplication, facilitating the compilation of BLAS-style libraries. In the long term this project could be used to: compile full Julia libraries, with support for running their automated tests; and the ability to bootstrap the compiler, which would enable actual Julia code to be used locally in the browser.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5709395656704000/",
          "proposal_id": null,
          "short_description": "This project would bring the mathematical prowess of Julia to the web with the near native performance of WebAssembly. The expected outcome of this...",
          "slug": "compiling-julia-to-webassembly",
          "status": "completed",
          "student_name": "Sean Innes",
          "student_profile": null,
          "tags": [
            "web"
          ],
          "title": "Compiling Julia to WebAssembly"
        },
        {
          "code_url": "https://github.com/sharanry/gsoc18",
          "description": "<p>PyMC3 is based on Theano, and uses it for creating and computing the graph that comprises the probabilistic model. Given the discontinuation of support for Theano, we are exploring using alternative libraries for future major versions of PyMC. We aim to port or re-implement some of the distributions currently present in PyMC3 using the selected framework while keeping the API, output and performance consistent.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5710094863958016/",
          "proposal_id": null,
          "short_description": "PyMC3 is based on Theano, and uses it for creating and computing the graph that comprises the probabilistic model. Given the discontinuation of...",
          "slug": "alternative-computational-engines-for-pymc3",
          "status": "completed",
          "student_name": "Sharan Yalburgi",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Alternative computational engines for PyMC3"
        },
        {
          "code_url": "https://yingboma.github.io/update/2018/08/13/gsoc.html",
          "description": "<p>Stiff ordinary differential equations (ODEs) and differential algebraic equations (DAEs) with high index number are problems present in physical models like Brusselator and Euler-Lagrange equations with constraints. Stiffness detection and automatic switching algorithms will not only help users choose a near optimal solver for the problem, but it will also greatly improve the efficiency of solving ODEs by switching algorithms within the time domain of interest. Stiffness detection and automatic switching algorithms are not presently implemented for most ODE solvers except <code>LSODA</code>. Also, there is no open source index reduction algorithm for DAEs. Thus, my project aims to implement production ready stiffness detection and automatic switching algorithms, and index reduction algorithms for DAEs by the end of this summer.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5719492789272576/",
          "proposal_id": null,
          "short_description": "Stiff ordinary differential equations (ODEs) and differential algebraic equations (DAEs) with high index number are problems present in physical...",
          "slug": "stiffness-detection-and-automatic-switching-algorithms-for-ordinarydiffeqjl-and-tooling-for-modelingtoolkitjl",
          "status": "completed",
          "student_name": "Yingbo Ma",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Stiffness Detection and Automatic Switching Algorithms for OrdinaryDiffEq.jl and Tooling for ModelingToolkit.jl"
        },
        {
          "code_url": "https://gist.github.com/shubham808/0eaaf9007bb144095c591a63a87f8750",
          "description": "<p>Shogun Machine Learning Toolbox aims at offering a wide range of efficient and unified machine learning algorithms with great accessibility. In this regard, i wish to take up this project which will make it easier to use Shogun and increase its applications. This will also aim to modernize the code base.\nThis project, which is in continuation with the Continuous Detox II, is about providing control and information to the user when an expensive algorithm is called through another interface for instance Python,R etc.\nThe framework for a lot of cool classes is already in place however it need to be systematically implemented shogun wide. Also, I will work on interface for Feature Visualization in TensorBoard.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5461485513867264/",
          "proposal_id": null,
          "short_description": "Shogun Machine Learning Toolbox aims at offering a wide range of efficient and unified machine learning algorithms with great accessibility. In this...",
          "slug": "inside-the-black-box",
          "status": "completed",
          "student_name": "Shubham Shukla",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "Inside the Black Box"
        },
        {
          "code_url": "https://mikhail-vaganov.github.io/gsoc-2018-blog/2018/08/11/final-report.html",
          "description": "<p>A large number of interacting bodies is the key component in explanation of many physical phenomena. From the gravitational interaction of stars and planets to molecular dynamics and electron gas in quantum mechanics, the N-body problem formalism plays an essential role in modeling those systems. The goal of this project is to create tools for conducting N-body simulations in a fast, accurate and reliable manner. Often the interaction of bodies can be described by means of differential equations (DEqs) so that the task of finding the state of the system at a particular time leads to solving those equations. The packages of JuliaDIffEq organization were developed exactly to supply efficient Julia implementations of solvers for various DEqs. The current project describes an extension of DiffEqPhysics.jl package, which will allow researchers to solve the N-body problems in different physical models and applications.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5529132188303360/",
          "proposal_id": null,
          "short_description": "A large number of interacting bodies is the key component in explanation of many physical phenomena. From the gravitational interaction of stars and...",
          "slug": "tooling-for-n-body-simulations-in-julia",
          "status": "completed",
          "student_name": "Mikhail Vaganov",
          "student_profile": null,
          "tags": [],
          "title": "Tooling for N-body Simulations in Julia"
        },
        {
          "code_url": "http://apoorvapandey.me/2018/08/12/the-culmination/",
          "description": "<p>Data retriever provides a number of publicly available datasets. These datasets are not stored at a single\nlocation but are downloaded from various publically available data repositories.\nNew datasets are being added to retriever regularly so it becomes crucial to check the <strong>availability</strong> and <strong>installation</strong> of all datasets. This is a tedious task so the process needs to\nbe automated.</p>\n<p>The goal of this project is to create a status server and dashboard where maintainers and users\ncan see the status of datasets i.e. whether the datasets are installing properly or not and the changes that have been made to the dataset.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5531854258044928/",
          "proposal_id": null,
          "short_description": "Data retriever provides a number of publicly available datasets. These datasets are not stored at a single\nlocation but are downloaded from various...",
          "slug": "status-server-and-dashboard",
          "status": "completed",
          "student_name": "Apoorva Pandey",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Status Server and Dashboard"
        },
        {
          "code_url": "https://gist.github.com/git-abhishek/3bcccb4de59afcf53f499785ffa981d5",
          "description": "<p>This project focuses to improve yt's test framework. At present, yt's Python code coverage is only 25% (unit and answer testing) and the test runtime is approximately 45 minutes. The aim of this project is to increase code coverage and reduce test runtime.</p>\n<p>First, I propose the use of <a href=\"https://coveralls.io/\" target=\"_blank\">Coveralls</a>, which is a tool to monitor the code coverage and is free for open source repositories. This would not only help in analyzing the key areas that need immediate attention for coverage but will also help in maintaining higher code coverage for future developments.</p>\n<p>yt's test suite could be divided into three areas, namely, Python unit tests, Cython test cases and answer testing. I will enhance the yt test suite by writing test cases for the flows that are not being tested currently. Runtime of tests could be improved by optimizing (or reducing) answer testing and image comparisons tests for visualization and volume rendering modules. This project also focuses on streamlining test cases for different geometries and data styles to improve the runtime of tests. Furthermore, the runtime of test suites varies on Linux and OSX, thereby giving us a scope of improvement.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4966182234882048/",
          "proposal_id": null,
          "short_description": "This project focuses to improve yt's test framework. At present, yt's Python code coverage is only 25% (unit and answer testing) and the test runtime...",
          "slug": "improve-test-coverage-and-test-performance",
          "status": "completed",
          "student_name": "Abhishek  Singh",
          "student_profile": null,
          "tags": [
            "python",
            "ml",
            "ai",
            "ui",
            "ux"
          ],
          "title": "Improve Test Coverage and Test Performance"
        },
        {
          "code_url": "https://github.com/aneesh-joshi/Similarity-Learning-Evaluation-Scripts",
          "description": "<p>Reseachers and Industry experts alike turn to gensim for easy-to-pick up and production ready code. Recently, Deep Learning techniques have taken the fore front in apparent \"state of the art\" performances, however, these techniques haven't made their way into production due to unreproducability and lack of availability. This project will evaluate these newer techniques, justify their benefit in reproducible manners and integrate  them into the gensim toolkit.</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2018_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4967403280662528/",
          "proposal_id": null,
          "short_description": "Reseachers and Industry experts alike turn to gensim for easy-to-pick up and production ready code. Recently, Deep Learning techniques have taken the...",
          "slug": "neural-networks-for-similarity-learning",
          "status": "completed",
          "student_name": "Aneesh Yogesh Joshi",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Neural Networks for Similarity Learning"
        },
        {
          "code_url": "https://anthony-wang.github.io/gsoc_blog/gsoc/julia/makie/final/progress/report/2018/08/08/final-update.html",
          "description": "<p><code>Makie.jl</code> is a <a href=\"https://github.com/JuliaPlots/Makie.jl\" target=\"_blank\">new plotting library for Julia</a>, providing an interface for <code>GLVisualize</code>, with emphasis on interactivity and speed. The <a href=\"https://github.com/SimonDanisch/MakieDocs\" target=\"_blank\">current documentation</a> is in need of a rewrite, to ensure that it is understandable and illustrative, and example code snippets and outputs need to be added to the documentation where necessary.</p>\n<p>Additionally, there is a database containing example code snippets and example data that can be used to make plots with <code>Makie</code>. It is a working point of this project to programmatically integrate these code snippets including the <code>Makie</code>-generated output plots into the documentation pages. In addition, tests for the plotting need to be written to verify plotting functionality after coding changes.</p>\n<p>Another goal of this project is to create more impressive and creative <a href=\"https://www.r-graph-gallery.com/all-graphs/\" target=\"_blank\">plotting examples</a> for the examples gallery to showcase the power and flexibility of the <code>Makie.jl</code> library.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4971135942787072/",
          "proposal_id": null,
          "short_description": "Makie.jl is a new plotting library for Julia, providing an interface for GLVisualize, with emphasis on interactivity and speed. The current...",
          "slug": "makiejl-gsoc-2018-proposal",
          "status": "completed",
          "student_name": "Anthony Wang",
          "student_profile": null,
          "tags": [
            "ai",
            "database"
          ],
          "title": "Makie.jl – GSoC 2018 Proposal"
        },
        {
          "code_url": "https://github.com/ropensci/rdataretriever/commits?author=pranita-s",
          "description": "<p>Augment R API for Data Retriever with a versatile install function, robust Python detection and visualization widgets.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5109380672389120/",
          "proposal_id": null,
          "short_description": "Augment R API for Data Retriever with a versatile install function, robust Python detection and visualization widgets.",
          "slug": "synchronize-r-api-with-the-python-data-retriever-api-and-improve-usability-of-r-package",
          "status": "completed",
          "student_name": "Pranita Sharma",
          "student_profile": null,
          "tags": [
            "python",
            "api"
          ],
          "title": "Synchronize R API with the Python Data Retriever API and improve usability of R package"
        },
        {
          "code_url": "https://gist.github.com/IgorBaratta/c7ca5252834f2c70efe0d233a3acecb4",
          "description": "<p>In many fields of science and engineering (such as electrodynamics, acoustics, and quantum mechanics), the partial differential equations (PDEs) can be complex-valued. Currently, the finite element solver of the FEniCS Project, DOLFIN, supports only real floating-point arithmetic limiting the scope of application on these fields. The primary goal of this project is to extend the capabilities of DOLFIN to support complex numbers, and thus to directly represent complex-valued fields, opening up the possibility of the solution of large-scale complex-valued PDEs using FEniCS.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2018_018",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5117785856278528/",
          "proposal_id": null,
          "short_description": "In many fields of science and engineering (such as electrodynamics, acoustics, and quantum mechanics), the partial differential equations (PDEs) can...",
          "slug": "complex-number-support-in-fenics",
          "status": "completed",
          "student_name": "Igor Baratta",
          "student_profile": null,
          "tags": [],
          "title": "Complex Number support in FEniCS"
        },
        {
          "code_url": "https://gist.github.com/MSeeker1340/486400990a6d5e367059c0ec7ac128f6",
          "description": "<p>Exponential integrators have received a lot of attention in recent years as a viable alternative to implicit schemes for stiff systems. In particular, there has been a surge of interest in the exponential propagation iterative Runge-Kutta (EPIRK) framework. However, open source implementation of the algorithms is lacking at the moment. This project aims to add state-of-the-art exponential Runge-Kutta integrators to JuliaDiffEq's solver repertoire, which can benefit both algorithm developers and researchers who need efficient solvers for stiff problems. Main challenges for the project include the evaluation of high-order phi-functions, the transition from semilinear to generic systems and time step adaptation for the integrators.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_019",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5273374267801600/",
          "proposal_id": null,
          "short_description": "Exponential integrators have received a lot of attention in recent years as a viable alternative to implicit schemes for stiff systems. In...",
          "slug": "native-julia-implementation-of-exponential-runge-kutta-integrators",
          "status": "completed",
          "student_name": "Xingjian Guo",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Native Julia Implementation of Exponential Runge-Kutta Integrators"
        },
        {
          "code_url": "https://gist.github.com/ayushsuhane/fd114cda20e93b0f61a8acb6d25d3276",
          "description": "<p>With the capability of multiple MD codes to easily handle milions of atoms, a major roadblock to analysis of this vast amount of data corresponding to positions of each atoms at every timestep is the time to evaluate pairwise distance between multiple atoms. Almost every operation requires the distance between the pair of atoms, fast calculation of pairwise distance is of utmost importance. Multiple basic analysis functions like Radial Distribution Function, Contact Matrices, depepend very heavily on fast distance evaluations. \nApart from naive approach for pairwise calculations which scale as O(N^2), other forms of data structures like KDTree, Octree are sugested for faster calulations based on the requirements. Based on the MDAnalysis, two use cases are identified as highly used in majority of the analysis algorithms. \nThe goal of the project is to identify the data structure based on the requirements of the use case and implement in the MDAnalysis library along with clear documentations and test cases.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_020",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5361697921433600/",
          "proposal_id": null,
          "short_description": "With the capability of multiple MD codes to easily handle milions of atoms, a major roadblock to analysis of this vast amount of data corresponding...",
          "slug": "improve-distance-search-methods-in-mdanalysis",
          "status": "completed",
          "student_name": "Ayush Suhane",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Improve Distance Search Methods in MDAnalysis"
        },
        {
          "code_url": "https://agustinaarroyuelo.github.io/jekyll/update/2018/08/08/final_evaluation.html",
          "description": "<h3>Module for Approximate Bayesian Computation</h3>\n<p>Approximate Bayesian Computation (ABC) algorithms, also called likelihood free inference techniques, are a family of methods that can render virtually impossible models to feasible scale. Additionally, the ABC approach has proven to be successful over likelihood based methods in several instances and is conceptually linked to recent and very innovative Deep Learning developments such as Generative Adversary Nets.   We propose to implement a module for ABC in PyMC3, specifically Sequential Monte Carlo-ABC (SMC-ABC).  Our work will signify a meaningful increase in the\nspectrum of models that PyMC3 will be able to perform.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_021",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5594656209371136/",
          "proposal_id": null,
          "short_description": "Module for Approximate Bayesian Computation\nApproximate Bayesian Computation (ABC) algorithms, also called likelihood free inference techniques, are...",
          "slug": "module-for-approximate-bayesian-computation",
          "status": "completed",
          "student_name": "Agustina Arroyuelo",
          "student_profile": null,
          "tags": [],
          "title": "Module for Approximate Bayesian Computation"
        },
        {
          "code_url": "https://github.com/yuj056/yuj056.github.io",
          "description": "<p>In this proposal, the governing equations and boundary conditions of the plug flow reactor with surface chemistry are discussed (Details see Section 2). The coding part will start with the simple boundary condition (pressure constant, adiabatic, etc.). SUNDIALS IDA solver for differential-algebraic equations will be employed to solve the governing equations, further research will be done on the coding part. Timeline is also neatly showed in Section 3, and previous related projects and courses are listed in Section 4. The reasons for the project choosing are also listed in Section 5.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_022",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5613849881346048/",
          "proposal_id": null,
          "short_description": "In this proposal, the governing equations and boundary conditions of the plug flow reactor with surface chemistry are discussed (Details see Section...",
          "slug": "implement-a-plug-flow-reactor-model-with-surface-chemistry",
          "status": "completed",
          "student_name": "Yuanjie Jiang",
          "student_profile": null,
          "tags": [
            "react",
            "ai"
          ],
          "title": "Implement a Plug Flow Reactor Model with Surface Chemistry"
        },
        {
          "code_url": "https://pfitzseb.github.io/blogposts/gsoc-final-2018",
          "description": "<p>Julia is capable of delivering very good performance (in many cases on par with optimized C), but some of the concepts that enable this performance are not obvious for programmers new to the language. Base contains some tools to inspect code for performance problems, but those are not very beginner friendly and hard to integrate into an IDE.\nDisplaying performance lint warnings directly in the source code will make it much easier to spot and correct performance problems for new and seasoned programmers alike. In some cases it might even be possible to offer automated fixes for common performance issues (e.g. changing the type of a local variable or using non-const globals).</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2018_023",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6239403278073856/",
          "proposal_id": null,
          "short_description": "Julia is capable of delivering very good performance (in many cases on par with optimized C), but some of the concepts that enable this performance...",
          "slug": "performance-linting-for-juno",
          "status": "completed",
          "student_name": "Sebastian Pfitzner",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Performance Linting for Juno"
        },
        {
          "code_url": "https://ayush1999.github.io/blog/blog6.html",
          "description": "<p>In the upcoming summers, I aim to achieve six objectives in three different fields. These are:</p>\n<h3>1. Model Import :</h3>\n<p>I plan on making a reader for machine learning models in Julia. This will help us in loading and running models made using different frameworks into Julia. This involves making a reader for ONNX models, and Keras models. I collaborated with the mentor, Mike Innes to work on this and the code can be found in the ONNX.jl repository under FluxML organization.</p>\n<h3>2. Model Export :</h3>\n<p>I will work on demos for the FluxJS.jl model zoo. This will make Machine Learning in Julia more dynamic and flexible, as it would help us in visualizing models in the browser. I'll also work on the main FluxJS package, as it still needs a lot of code tracing.</p>\n<h3>3. Computer Vision :</h3>\n<p>I propose to work on two different projects in this direction. The first project involves integrating Metalhead.jl with ONNX.jl . This will help in expanding the functionalities offered by Metalhead. The second part would include loading and running as many ONNX models as possible.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_024",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6242927298740224/",
          "proposal_id": null,
          "short_description": "In the upcoming summers, I aim to achieve six objectives in three different fields. These are:\n1. Model Import :\nI plan on making a reader for...",
          "slug": "model-import-export-and-computer-vision-in-julia",
          "status": "completed",
          "student_name": "Ayush Shridhar",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ux"
          ],
          "title": "Model Import, Export and Computer Vision in Julia"
        },
        {
          "code_url": "https://biona001.github.io/GSoC-Summary/",
          "description": "<p>Recent advances in molecular biotechnologies demand fast and innovative algorithms to analyze\nthem effectively. One promising proximal-type algorithm is iterative hard thresholding (IHT). It is\nespecially well suited to the analysis of modern high-dimensional datasets common in genomics,\nand was recently implemented in Julia as IHT.jl for both numeric and genomic data. Compared to\nrelated packages, the current IHT implementation excels in aspects such as memory management\nand model selection, but lacks important analysis features such as group selection relevant to\ngenomic analysis. Hence, IHT.jl is ripe for improvement.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_025",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4589298720440320/",
          "proposal_id": null,
          "short_description": "Recent advances in molecular biotechnologies demand fast and innovative algorithms to analyze\nthem effectively. One promising proximal-type algorithm...",
          "slug": "iterative-hard-thresholding-for-genetic-analysis",
          "status": "completed",
          "student_name": "Benjamin Chu",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Iterative Hard thresholding for Genetic Analysis"
        },
        {
          "code_url": "http://wuwei.io/post/2018/08/gsoc18-summary-page/",
          "description": "<p>Shogun is a powerful machine learning toolkit. The project has a long history and a huge codebase. Some parts are very outdated and not well-designed. Polishing the codebase and bringing Shogun to modern design will make it much easier to developers, and as such make the project more attractive for scientists to implement their work in. This GSoC project aims at re-designing Shogun’s data representation and some APIs, including features, labels and preprocessors, and bringing novel un-templated data classes with support for lazy evaluation to Shogun. By the end of this project, we expect an improvement of maintainability, stability, and beauty to the codebase of Shogun.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_026",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4732080479010816/",
          "proposal_id": null,
          "short_description": "Shogun is a powerful machine learning toolkit. The project has a long history and a huge codebase. Some parts are very outdated and not...",
          "slug": "continuous-detoxification",
          "status": "completed",
          "student_name": "Wuwei Lin",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Continuous Detoxification"
        },
        {
          "code_url": "https://gist.github.com/bwengals/46a9d79a93e58ee9eaa8b2d3c8904832",
          "description": "<p>This main focus of this project will be to extend the functionality of the\nPyMC3 Gaussian process module.  I plan to focus my contribution on extending\nfunctionality for handling larger data sets.  A secondary goal is to understand\nmore about the maintenance and release cycle of PyMC3, with the intention of\nassisting in this work going forward.  In a similar vein, I am also interested\nin helping port existing PyMC3 code to PyMC4 if a backend decision is made\nbefore the close of GSoC.</p>\n<p>The PyMC3 GP module is broken into multiple implementations The Gaussian\nprocess module currently contains one larger-data (referred to as \"sparse\")\napproximation method that applies to data observed with normally distributed\nnoise.  An additional implementation exploits Kronecker structure in the \ncovariance matrix to obtain efficiency gains, but also only applies to\ndata observed with normally distributed noise.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_027",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4751040008159232/",
          "proposal_id": null,
          "short_description": "This main focus of this project will be to extend the functionality of the\nPyMC3 Gaussian process module.  I plan to focus my contribution on...",
          "slug": "extending-gaussian-process-functionality-in-pymc3",
          "status": "completed",
          "student_name": "Bill Engels",
          "student_profile": null,
          "tags": [
            "ai",
            "backend"
          ],
          "title": "Extending Gaussian Process Functionality in PyMC3"
        },
        {
          "code_url": "https://tejank10.github.io/jekyll/update/2018/08/06/GSoC-Final-Summary.html",
          "description": "<p>I propose to add a wide variety of models in the model zoo of Flux. Currently, the model zoo lacks the latest architectures and algorithms in Reinforcement Learning. I will fill this gap by including:</p>\n<ul>\n<li>Dueling Deep Q Network</li>\n<li>Actor-Critic algorithm</li>\n<li>AlphaGo </li>\n</ul>\n<p>Apart from these, I will implement some interesting research papers which will cover below models:</p>\n<ul>\n<li>DCGAN</li>\n<li>Decoupling Neural Interfaces</li>\n<li>Spatial Transformer Networks</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_028",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6561667827630080/",
          "proposal_id": null,
          "short_description": "I propose to add a wide variety of models in the model zoo of Flux. Currently, the model zoo lacks the latest architectures and algorithms in...",
          "slug": "enriching-model-zoo-of-fluxjl",
          "status": "completed",
          "student_name": "Tejan Karmali",
          "student_profile": null,
          "tags": [
            "ux"
          ],
          "title": "Enriching Model Zoo of Flux.jl"
        },
        {
          "code_url": "https://vaibhavdixit02.github.io/Final-Blog-Post-For-Google-Summer-of-Code/",
          "description": "<p>A differential equation model of a dynamical system is a nonlinear parameterized model that is created to match realistic scenarios and occasionally it might be associated with some data, obtained from the system or through simulation. Once there is reasonable level of confidence in the correctness of the model, the task that remains is to estimate the parameters of the model. Due to the structure of parameter estimation problems in dynamical models, statistics and machine learning techniques are an ideal choice for determining the parameters. During the course of the summer I will be implementing some statistical algorithms, including Stochastic Approximation Expectation Maximization(SAEM) and Maximum A Posteriori Estimation (MAP), for parameter estimation of a dynamic model. I will also work on extending support for parameter estimation in Stochastic Differential Equations (SDEs) by adding first differences distribution to generalized Log-Likelihood. These would be quite important additions to the suite of methods in JuliaDiffEq and would be of great use to scientific community involved in systems biology, HIV-AIDS study, and drug dosage estimation.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_029",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6073710955986944/",
          "proposal_id": null,
          "short_description": "A differential equation model of a dynamical system is a nonlinear parameterized model that is created to match realistic scenarios and occasionally...",
          "slug": "parameter-estimation-for-nonlinear-dynamical-models",
          "status": "completed",
          "student_name": "Vaibhav Dixit",
          "student_profile": null,
          "tags": [
            "ios",
            "ai",
            "ui"
          ],
          "title": "Parameter estimation for nonlinear dynamical models."
        },
        {
          "code_url": "https://roboneet.github.io/blog/posts/final.html",
          "description": "<p>FluxJS is a tool to export Flux models to javascript using deeplearn.js. Since Flux is a new library, it is essential to have lots of examples demonstrating its use. This would make it easy for new users to pick it up. Along with the great features of flux, its website should showcase good demos. It is important that the demos be appealing to clients. Hence, the projects listed include applying AI on visual art and games through Flux models.</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2018_030",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4849182426791936/",
          "proposal_id": null,
          "short_description": "FluxJS is a tool to export Flux models to javascript using deeplearn.js. Since Flux is a new library, it is essential to have lots of examples...",
          "slug": "fluxjs-demos",
          "status": "completed",
          "student_name": "Neethu Mariya Joy",
          "student_profile": null,
          "tags": [
            "java",
            "javascript",
            "web",
            "ai",
            "ux"
          ],
          "title": "FluxJS Demos"
        },
        {
          "code_url": "https://github.com/JuliaDiffEq/FEniCS.jl",
          "description": "<p>We continue work done on a FEniCS wrapper in Julia. We further optimize it, and add more functionality, so users can access a richer API, and solve harder and more complex problems. We will also create some toolboxes for common PDE - problems, such that it makes it easier, for people to use straight out of the box to get a solution, without relying on knowing the necessary mathematical background, to derive the variational form.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2018_031",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/4902861196492800/",
          "proposal_id": null,
          "short_description": "We continue work done on a FEniCS wrapper in Julia. We further optimize it, and add more functionality, so users can access a richer API, and solve...",
          "slug": "a-fenics-wrapper-in-julia",
          "status": "completed",
          "student_name": "Yiannis Simillides",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "A FEniCS wrapper in Julia"
        },
        {
          "code_url": "https://flgsoc18.wordpress.com/2018/08/06/final-review/",
          "description": "<p>In the solution process of problems discretized using FEM, the assembly of element level tensors to the global matrix often contributes a significant amount of computational time relative to the overall process. The goal of this GSoC 2018 project is to improve the performance of the FEniCS framework in the assembly phase. To achieve this, the FEniCS Form Compiler (FFC) should be enhanced such that the generated code can fully utilize data-level parallelism (SIMD) functionality of modern CPUs.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_032",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5811828210794496/",
          "proposal_id": null,
          "short_description": "In the solution process of problems discretized using FEM, the assembly of element level tensors to the global matrix often contributes a significant...",
          "slug": "fenics-maximizing-performance-on-modern-architectures-with-data-level-parallelism",
          "status": "completed",
          "student_name": "Fabian Löschner",
          "student_profile": null,
          "tags": [],
          "title": "[fenics] Maximizing performance on modern architectures with data-level parallelism"
        },
        {
          "code_url": "https://medium.com/@shubhamsipah00/final-report-f3e3993fe5aa",
          "description": "<p>I propose to implement Variable Step Size Multistep Methods, Variable Order Variable Step Size Multistep Methods, IMEX Multistep Methods and IMEX Runge-Kutta Methods.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_033",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5881053487038464/",
          "proposal_id": null,
          "short_description": "I propose to implement Variable Step Size Multistep Methods, Variable Order Variable Step Size Multistep Methods, IMEX Multistep Methods and IMEX...",
          "slug": "native-julia-solvers-for-ordinary-differential-equations-and-algebraic-differential-equations",
          "status": "completed",
          "student_name": "Shubham Maddhashiya",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Native Julia solvers for ordinary differential equations and algebraic differential equations"
        },
        {
          "code_url": "https://davidercruz.github.io/gsoc2018/2018/11/13/End-of-GSOC.html",
          "description": "<p>Implement trajectory transformations on the MDAnalysis API, to be called on-the-fly by the user, eliminating the requirement for multiple intermediate steps of modifying and saving the trajectory, and giving users a more efficient and simple workflow for simulation data analysis.</p>\n",
          "difficulty": "medium",
          "id": "proj_numfocus_2018_034",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5895324858056704/",
          "proposal_id": null,
          "short_description": "Implement trajectory transformations on the MDAnalysis API, to be called on-the-fly by the user, eliminating the requirement for multiple...",
          "slug": "implementing-on-the-fly-coordinate-transformations",
          "status": "completed",
          "student_name": "Davide Cruz",
          "student_profile": null,
          "tags": [
            "api",
            "ui"
          ],
          "title": "Implementing on-the-fly coordinate transformations"
        },
        {
          "code_url": "https://arijitkar98.github.io/2018/08/13/final.html",
          "description": "<p>Object tracking is the process of locating a moving object (or multiple objects) over time using a camera. It has a variety of uses, some of which are: human-computer interaction, security and surveillance, video communication and compression, augmented reality, traffic control, medical imaging and video editing.</p>\n<p>I propose to add object tracking modules in Julia either as a part of ImageFeatures.jl or as a standalone repository. Therefore, I propose to add the following algorithms:</p>\n<pre><code>1. Optical Flow Algorithms\n    1.1. Lucas-Kanade method\n    1.2. Farneback Dense Optical Flow method\n2. Tracking Algorithms\n    2.1. Boosting Tracking\n    2.2. Multiple Instance Learning\n    2.3. MedianFlow Tracking\n    2.4. Tracking Learning Detection framework\n</code></pre>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_035",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5996673603993600/",
          "proposal_id": null,
          "short_description": "Object tracking is the process of locating a moving object (or multiple objects) over time using a camera. It has a variety of uses, some of which...",
          "slug": "object-tracking-in-julia",
          "status": "completed",
          "student_name": "Arijit Kar",
          "student_profile": null,
          "tags": [],
          "title": "Object Tracking in Julia"
        },
        {
          "code_url": "https://github.com/RaRe-Technologies/gensim/pull/2127",
          "description": "<p>Gensim is an NLP library which claims to be highly effective during training and produce linear performance growth with increasing the number of threads.</p>\n<p>Currently, that is not true on machines with a large number of cores (&gt;10) and large data files. The reason of this is that almost all Gensim models which support multithreaded training work in the following way. There is <strong>single job producer</strong> -- worker which reads the data and pushes the chunks into the job queue. Also, there are <strong>many job consumers</strong> -- workers which pull the chunks and update the model parameters in parallel.</p>\n<p>The problem is that consumers'  code is optimized well, so this leads to <strong>workers starvation</strong> problem. Job producer just can't fill the queue at such a high pace. This is the case even using fastest <code>read the line, split it and yield</code> corpus iterator.</p>\n<p>This problem could be solved by allowing users to pass <code>K</code> data streams (currently only single-stream == single job producer thread is supported), e.g. which point to <code>K</code> large files and use <code>K</code> job producers to fill the job queue.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_036",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6004414544347136/",
          "proposal_id": null,
          "short_description": "Gensim is an NLP library which claims to be highly effective during training and produce linear performance growth with increasing the number of...",
          "slug": "multi-stream-api",
          "status": "completed",
          "student_name": "Dmitry Persiyanov",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Multi-stream API"
        },
        {
          "code_url": "https://mohamed82008.github.io/ScienceLounge/text/2018/08/12/Final-GSoC-report/",
          "description": "<p>In this project, I will implement the locally optimal block preconditioned conjugate gradient (LOBPCG) algorithm for finding extremal generalized eigenvalues and their corresponding eigenvectors. The package will be interfaced in IterativeSolvers.jl. Additionally, parallel algebraic multigrid preconditioners will be implemented extending AMG.jl. Common preconditioners will then be grouped into a package and further interfaced in IterativeSolvers.jl. Testing wil be done using buckling problems defined with the help of JuAFEM.jl. The methods developed in this project will be benchmarked against Base.eigs and JacobiDavidson.jl, and results will be published on Github. Finally, the packages developed will be documented and ported to Julia 1.0 when it is released.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_037",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6272345610125312/",
          "proposal_id": null,
          "short_description": "In this project, I will implement the locally optimal block preconditioned conjugate gradient (LOBPCG) algorithm for finding extremal generalized...",
          "slug": "fast-extremal-eigenvalue-iterative-solver-with-preconditioners",
          "status": "completed",
          "student_name": "Mohamed Mohamed",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Fast Extremal Eigenvalue Iterative Solver with Preconditioners"
        },
        {
          "code_url": "https://github.com/iewaij/GSoC-2018",
          "description": "<p>Improvements for JuliaNLSolvers could be made in three parts: documentation, benchmarks and functionality.</p>\n<p>Currently, <code>LsqFit.jl</code>, and <code>NLsolve.jl</code> only have example codes in their READMEs. Documentation for these projects will be good references for users. Beginner’s guide would dramatically reduce the learning curve for new users. Examples are also needed for <code>Optim.jl</code>, <code>LsqFit.jl</code> and <code>NLsolve.jl</code> to show people the Julia “pipeline” in areas such as Machine Learning, Statistics and Economics. Meanwhile, codes in documentation and examples can be used for testing.</p>\n<p>Benchmarks are essential to show the advantage of Julia and therefore may persuade outside users to switch. By comparing with <code>SciPy</code>, it will also help guide development and find bugs.</p>\n<p><code>LsqFit.jl</code> is still on an early development stage and has large potential to improve. For example, allowing non-vectorized functions for <code>LsqFit.jl</code> will help it apply to more problems.</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2018_038",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/6282442742693888/",
          "proposal_id": null,
          "short_description": "Improvements for JuliaNLSolvers could be made in three parts: documentation, benchmarks and functionality.\nCurrently, LsqFit.jl, and NLsolve.jl only...",
          "slug": "improvements-for-julianlsolvers",
          "status": "completed",
          "student_name": "Jiawei Li",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Improvements for JuliaNLSolvers"
        },
        {
          "code_url": "https://github.com/JuliaBerry/PiCraft.jl/pulls?utf8=✓&q=is%3Apr+is%3Aclosed+author%3AEllipse0934+updated%3A%3C2018-08-12+",
          "description": "<p>A package which uses the Minecraft Pi API and corresponding mod for Java version to build <em>cool</em> stuff. Accompanied with documentation and tutorials to help out people with little to no programming experience. Includes scripts to build everything from spheres and cubes to Calculator internals.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_039",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5168618539057152/",
          "proposal_id": null,
          "short_description": "A package which uses the Minecraft Pi API and corresponding mod for Java version to build cool stuff. Accompanied with documentation and tutorials to...",
          "slug": "julia-package-for-minecraft-api",
          "status": "completed",
          "student_name": "Aditya Puranik",
          "student_profile": null,
          "tags": [
            "java",
            "api",
            "ui"
          ],
          "title": "Julia package for Minecraft API"
        },
        {
          "code_url": "https://sohamtamba.github.io/GSoC/",
          "description": "<p>LightGraphs is a Julia package that implements several commonly used graph algorithms. The objective of the package is to provide the functionality of robust network and graph analysis libraries such as NetworkX while maintaining efficiency and user-friendliness. Keeping this objective in mind, my proposal is to produce a parallel implementation of the graph algorithms already available in LightGraphs, as well as implement commonly used heuristics and approximation algorithms for certain graph problems.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2018_040",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2018/projects/5193483178475520/",
          "proposal_id": null,
          "short_description": "LightGraphs is a Julia package that implements several commonly used graph algorithms. The objective of the package is to provide the functionality...",
          "slug": "parallel-graph-development",
          "status": "completed",
          "student_name": "Soham Tamba",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Parallel Graph Development"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2018/organizations/6485922656813056/"
    },
    "year_2019": {
      "num_projects": 19,
      "projects": [
        {
          "code_url": "http://www.apoorvapandey.com/2019/08/24/the-pinnacle/",
          "description": "<p><strong>The Data Retriever is a package manager for data. It downloads, cleans, and stores publicly available data, so that analysts spend less time cleaning and managing data, and more time analyzing it. The automation of this process reduces the time for a user to get most large datasets up and running by hours, and in some cases days.</strong></p>\n<p>Currently, it is hard to reproduce previous installations of a dataset using Data Retriever due to updates in the dataset and Data Retriever itself. This project aims to add provenance capabilities to Data Retriever so that it becomes easier to reproduce previous installations of a dataset at a later date.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6362246035275776/",
          "proposal_id": null,
          "short_description": "The Data Retriever is a package manager for data. It downloads, cleans, and stores publicly available data, so that analysts spend less time cleaning...",
          "slug": "retriever-provenance",
          "status": "completed",
          "student_name": "Apoorva Pandey",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Retriever Provenance"
        },
        {
          "code_url": "https://github.com/qutip/qutip/pull/1066",
          "description": "<p>The following functionality is aimed at:\nChoice of Model (lattice dimensionality, Boson/Fermion, Hubbard, XXZ, Boundary conditions etc.).\nNon-interacting/Mean Field Models:<br>\nBand Structure and Eigen-state calculations. (Canonical diagonalization of Fermions/Bosons). Ability to take band structures as inputs directly for subsequent calculations.\nVisualization of iso-energy surfaces in the band-structure.\nBerry Curvature (From dynamics/Gauge potential).\nChern numbers.\nInteracting models:\nExact diagonalization.\nGround state and Entanglement Spectrum calculation with DMRG.\nDynamics with td-DMRG.\nCalculation of Conductivity</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6475272981839872/",
          "proposal_id": null,
          "short_description": "The following functionality is aimed at:\nChoice of Model (lattice dimensionality, Boson/Fermion, Hubbard, XXZ, Boundary conditions etc.)....",
          "slug": "development-of-qutip-functions-for-analysis-of-bosonicfermionic-lattices",
          "status": "completed",
          "student_name": "Saumya Biswas",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Development of Qutip Functions for analysis of Bosonic/Fermionic Lattices"
        },
        {
          "code_url": "https://github.com/OriolAbril/gsoc2019/blob/master/final_work_submission.md",
          "description": "<p>ArviZ is a Python package for exploratory analysis of Bayesian models, from diagnostics to visualization. It is designed as a backend-agnostic tool with the goal to reach the widest user base and thus contribute to extend best practices among Bayesian inference practitioners.</p>\n<p>Two key problems in this field are model comparison and convergence analysis. Model comparison is not trivial because of the different structures and number of parameters of each model. Fortunately, there are some information criteria (i.e. leave-one-out cross-validation) that can be used for this task. Even though convergence is proven for infinite iterations, it is not the case for finite MCMC runs, which can be arbitrarily bad. Convergence assessment must take into account both intra- and inter-chain correlations.</p>\n<p>ArviZ implements many of these algorithms for diagnostic and comparison, at least at a preliminary level, but it still lacks plots and tools to ease and improve its interpretation. This project seeks to design and implement these tools. Moreover, it will pay special attention to testing and documentation with examples not only of the new functionalities, but also of the already implemented ones.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5675481620283392/",
          "proposal_id": null,
          "short_description": "ArviZ is a Python package for exploratory analysis of Bayesian models, from diagnostics to visualization. It is designed as a backend-agnostic tool...",
          "slug": "information-criteria-and-convergence-assessment-tools-for-arviz",
          "status": "completed",
          "student_name": "Oriol Abril Pla",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "backend"
          ],
          "title": "Information criteria and convergence assessment tools for ArviZ"
        },
        {
          "code_url": "https://jmloyola.github.io/posts/2019/08/gsoc-2019-final-evaluation",
          "description": "<p>Bayesian Additive Regression Trees (BART) is a Bayesian nonparametric approach to estimating functions using regression trees. A BART model consist on a sum of regression trees with (homoskedastic) normal additive noise. Regression trees are defined by recursively partitioning the input space, and defining a local model in each resulting region of input space in order to approximate some unknown function. BARTs are useful and flexible model to capture interactions and non-linearities and have been proved useful tools for variable selection.</p>\n<p>Bayesian Additive Regression Trees will allow PyMC3 users to perform regressions with a “canned” non-parametric model. By simple calling a method, users will obtain the mean regressor plus the uncertainty estimation in a fully Bayesian way. This can be used later to predict on hold-out data. Furthermore, the implemented BART model will allow experience users to specify their own priors for the specific problem they are tackling, improving performance substantially.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5713417321578496/",
          "proposal_id": null,
          "short_description": "Bayesian Additive Regression Trees (BART) is a Bayesian nonparametric approach to estimating functions using regression trees. A BART model consist...",
          "slug": "bayesian-additive-regression-trees-in-pymc3",
          "status": "completed",
          "student_name": "Juan Martín Loyola",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Bayesian Additive Regression Trees in PyMC3"
        },
        {
          "code_url": "https://gsoc2019-boxili.blogspot.com/2019/08/final-submission-of-project.html",
          "description": "<p>QuTiP is best known for solving open quantum system dynamics. At the same time, it also has a Quantum Information Processing (QIP) submodule representing ideal quantum circuits. A tempting ideal to combine them is introducing random noise into the circuit by linking the circuit back to the Hamiltonian driving the evolution of the qubits. This could then be used to study the possible noise occurring in the experiments and how it will influence the result.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5714583002546176/",
          "proposal_id": null,
          "short_description": "QuTiP is best known for solving open quantum system dynamics. At the same time, it also has a Quantum Information Processing (QIP) submodule...",
          "slug": "qutip-project-noise-models-in-qip-module",
          "status": "completed",
          "student_name": "Boxi Li",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "QuTiP Project: Noise Models in QIP Module"
        },
        {
          "code_url": "https://gist.github.com/IvanYashchuk/5655fec951a1b3749a9b6fa57246842c",
          "description": "<p>ChainerX is a versatile <code>ndarray</code> implementation with special support of deep learning-specific operations. Therefore, it is important to support many fundamental operators usually available for <code>ndarray</code> libraries (e.g. those provided by NumPy and SciPy) as well as special operators focusing deep learning applications (e.g. convolution, pooling, activation functions, etc.). While Chainer implements many of these operators, ChainerX still has low coverage. Full coverage of Chainer’s operators (<code>chainer.functions</code>) and more coverage of NumPy APIs is needed.\nLinear algebra operations form the backbone for most of the computation components for many machine learning methods and simulations of physical systems. This project aims at extending ChainerX capability for common numerical linear algebra routines.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5736101006802944/",
          "proposal_id": null,
          "short_description": "ChainerX is a versatile ndarray implementation with special support of deep learning-specific operations. Therefore, it is important to support many...",
          "slug": "expand-chainerx-ops-differentiable-linear-algebra",
          "status": "completed",
          "student_name": "Ivan Yashchuk",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Expand ChainerX Ops: Differentiable Linear Algebra"
        },
        {
          "code_url": "https://dpananos.github.io/posts/2019/08/blog-post-21/",
          "description": "<p>Parameter estimation and uncertainty propagation are salient aspects of applied dynamical systems of practical interest.  Both parameter estimation and uncertainty propagation are handled elegantly in the Bayesian framework, and made easy by PyMC3.  Current numerical integrators in the scipy ecosystem do not return gradients with respect to the parameters of the system’s solution, preventing PyMC3 from using these integrators in the No U-Turn Sampler.  This project seeks to implement methods for computing gradients for use in PyMC3’s MCMC capabilities, thereby allowing applied researchers to analyze their systems in the Bayesian framework through PyMC3.</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2019_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5738105397575680/",
          "proposal_id": null,
          "short_description": "Parameter estimation and uncertainty propagation are salient aspects of applied dynamical systems of practical interest.  Both parameter estimation...",
          "slug": "ordinary-differential-equations",
          "status": "completed",
          "student_name": "Demetri Pananos",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Ordinary Differential Equations"
        },
        {
          "code_url": "https://harshitbansal05.github.io/2019/08/24/final-coding-blog.html",
          "description": "<p>The Data Retriever is a package manager for data. The Data Retriever automatically finds, downloads and pre-processes publicly available datasets and it stores these datasets in a ready-to-analyze state. The Retriever project, however, suffers from some drawbacks which require attention:</p>\n<ol>\n<li>Currently the core software ships with json script metadata. However, this metadata must be shifted in a separate project location to help with organization, maintenance, and testing.</li>\n<li>Retriever downloads all the json scripts at once during installation, or whenever the scripts folder in the home directory is empty. This would become increasingly inefficient as the number of the scripts in the upstream repository increase. We must remove this step and instead download the scripts from the upstream repository only when specifically needed.</li>\n<li>Presently, Retriever does not check for newer versions of scripts upstream and continues to use the scripts present in the home directory. These scripts may become quite outdated as compared to the newer scripts. Thus, we must check whether a newer version of a script is available upstream, when needed and accordingly download it.</li>\n</ol>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5386781703274496/",
          "proposal_id": null,
          "short_description": "The Data Retriever is a package manager for data. The Data Retriever automatically finds, downloads and pre-processes publicly available datasets and...",
          "slug": "data-retriever-extract-scripts-into-separate-system",
          "status": "completed",
          "student_name": "harshitbansal05",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Data Retriever: Extract Scripts into Separate System"
        },
        {
          "code_url": "https://naresh-bachwani.github.io/",
          "description": "<p>YellowBricks is an open source python data visualization library aiding both exploratory data analysis and machine learning tasks. As my Google Summer of Code project, I would like to propose building a new visualizer “Effect Plot” to help in interpreting linear model. Along with effect plots, secondary aim for the project would be to extend PCA visualizer by adding features like optional heatmap, colorbar, alpha params, and many other hyperparameters. Also, I would build test classes for Grid Search during this period. Effect plot tells the user about the effect various features of a dataset would have when a dataset is trained upon a particular linear model. A effect plot is basically a boxplot explaining the variance and medians of the effect of each feature. The purpose of this project is to cater to need of user by providing them control over various aspects of effect plots like face color, line color, linewidth, and shape and color of outliers along with many others hyperparameter to tune.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5489186272968704/",
          "proposal_id": null,
          "short_description": "YellowBricks is an open source python data visualization library aiding both exploratory data analysis and machine learning tasks. As my Google...",
          "slug": "effect-plot-and-pca-visualizer",
          "status": "completed",
          "student_name": "Naresh Bachwani",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Effect Plot and PCA Visualizer"
        },
        {
          "code_url": "https://ninadbhat.github.io/gsoc-posts/2019/08/blog-post-5/",
          "description": "<p>Molecular simulations are predominantly ran under periodic boundary conditions, i.e., upon leaving one face of the simulation volume, you re-enter in the opposite face. This can lead to molecules being split over the periodic boundary, which requires rectification before performing calculations. This project would involve defining wrapping and unwrapping functionality in the various AtomGroup methods which are based upon the position of particles, e.g., center of mass. Due to performance considerations, the functionality of these\nmethods will also require translation into Cython.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5499385360678912/",
          "proposal_id": null,
          "short_description": "Molecular simulations are predominantly ran under periodic boundary conditions, i.e., upon leaving one face of the simulation volume, you re-enter in...",
          "slug": "better-periodic-boundary-handling",
          "status": "completed",
          "student_name": "Ninad Bhat",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Better Periodic Boundary Handling"
        },
        {
          "code_url": "https://medium.com/@adidolkar123/gsoc-2019-summary-building-rnns-for-chainerx-cbe0bcfa13ab",
          "description": "<p>In this project, I propose to add Recurrent Neural Networks to ChainerX. RNNs are a very integral part of deep learning research. ChainerX is faster as compared to other frameworks (eg: Chainer, PyTorch) since its core code is completely implemented in C++. It currently lacks implementations of RNNs. In this project, I will provide C++ implementations of RNN models (LSTM, GRU). This will bring the fast speed of ChainerX to RNN models. I aim to replicate all RNN-related chainer ops in ChainerX. I will also provide sufficient code examples on how to use the RNN models of ChainerX.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5123441420664832/",
          "proposal_id": null,
          "short_description": "In this project, I propose to add Recurrent Neural Networks to ChainerX. RNNs are a very integral part of deep learning research. ChainerX is faster...",
          "slug": "recurrent-neural-networks-for-chainerx",
          "status": "completed",
          "student_name": "Aniket Didolkar",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Recurrent Neural Networks for ChainerX"
        },
        {
          "code_url": "https://piyush-555.github.io/final-report/",
          "description": "<p>NumPy is the fundamental and most widely used library in Python for scientific computation. But it is executed over CPU only. So, we have CuPy with same API as NumPy to leverage the power of GPUs. But current problem with CuPy is that, it contains many methods provided by NumPy, but not all of them. \nSo, in this project I want to implement a <code>fallback_mode</code> for CuPy. That is, whenever a method is called by the user that is not yet implemented in CuPy, it will automatically call respective NumPy method and get the result.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/4602167011311616/",
          "proposal_id": null,
          "short_description": "NumPy is the fundamental and most widely used library in Python for scientific computation. But it is executed over CPU only. So, we have CuPy with...",
          "slug": "cupy-automatic-fallback-to-numpy",
          "status": "completed",
          "student_name": "Piyush Raikwar",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai"
          ],
          "title": "CuPy automatic fallback to NumPy"
        },
        {
          "code_url": "https://github.com/iitrabhi/GSoC2019/blob/master/Demo/GSoC2019_Summary.md",
          "description": "<p>Finite element methods require a discretization of a domain into small elements, called a mesh. Typically, users of DOLFIN use an external mesh generation package, such as gmsh to construct meshes, before reading them into DOLFIN. In this project, we will work to ensure that gmsh, DOLFIN, and our preferred visualization package, Paraview work seamlessly together. This will be a huge usability improvement for users working with very complex geometries.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2019_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/4659097339691008/",
          "proposal_id": null,
          "short_description": "Finite element methods require a discretization of a domain into small elements, called a mesh. Typically, users of DOLFIN use an external mesh...",
          "slug": "gmshxdmfdolfin-mesh-processing-pipeline",
          "status": "completed",
          "student_name": "Abhinav Gupta",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "GMsh/XDMF/DOLFIN mesh processing pipeline"
        },
        {
          "code_url": "https://josephwillard.github.io/updates-and-the-end-of-gsoc.html",
          "description": "<p>The pymc project is an open source collaboration that focuses on providing\nBayesian modeling as well as probabilistic machine learning. The current\napproach most of the API utilizes makes use of Markov chain Monto Carlo.\nIn particular this project has been used successfully in research ranging from\npsychology to climate science.\nCurrently the pymc group is transitioning to TensorFlow as a back end\nover the previously used theano back end present in pymc3. On top of the\nback end changing there is also an effort to include symbolic computation as\na means to bring more functionality to the table. This creates new hurdles to\novercome such as converting pymc4 models to their corresponding symbolic-\npymc meta objects and adding more functionality to the symbolic-pymc\npackage.\nThis project is aimed at accomplishing the following tasks: (1) Setup conversion of pymc4 models to symbolic-pymc meta objects. (2) Improve symbolic-pymc codebase. (3) Setup Gibbs Sampling.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/4788238147911680/",
          "proposal_id": null,
          "short_description": "The pymc project is an open source collaboration that focuses on providing\nBayesian modeling as well as probabilistic machine learning. The current...",
          "slug": "symbolic-pymc-and-pymc4-integration",
          "status": "completed",
          "student_name": "Joseph Willard",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Symbolic PyMC and PyMC4 Integration"
        },
        {
          "code_url": "https://gist.github.com/Rishav1/eb2ddb5d7fee46d26ef9680181bdfbe9",
          "description": "<p>Elichika and ch2o are python to ONNX experimental compilers for Chainer ML framework (Elichika would eventually replace ch2o). Given a Chainer model, it parses the python source to get Abstract Syntax Tree and uses it to generate ML framework independent ONNX graphs. Currently neither of the compilers support parsing python jump statements. Moreover, several Chainer functions supported by ch2o are currently unavailable in Elichika. The objective of this project is to extend support for parsing break, continue and pass statements in both Elichika and ch2o. Additionally, it also involves adding Elichika support for Chainer functions and links existing in ch2o but not in Elichika such as sigmoid, max_pooling_2d, BatchNormalization, etc.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/6488684688310272/",
          "proposal_id": null,
          "short_description": "Elichika and ch2o are python to ONNX experimental compilers for Chainer ML framework (Elichika would eventually replace ch2o). Given a Chainer model,...",
          "slug": "extending-elichika-ch2o-parsing-jump-statements-and-more",
          "status": "completed",
          "student_name": "Rishav Chourasia",
          "student_profile": null,
          "tags": [
            "python",
            "ml",
            "ai"
          ],
          "title": "Extending Elichika & ch2o: Parsing jump statements and more"
        },
        {
          "code_url": "https://gist.github.com/barpit20/4b98c274f7d30dd872ebece45423ff8f",
          "description": "<p>Ecosystem issues such as improvements to tutorials and examples are an important milestone on the road map to JuMP 1.0. This project aims to improve the current JuMP ecosystem through the development of a JuMPTutorials.jl package, automating testing for new and old examples, updating old JuMP v0.18 code to v0.19, and standardizing naming and structuring of examples to enforce style guidelines.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5809395949109248/",
          "proposal_id": null,
          "short_description": "Ecosystem issues such as improvements to tutorials and examples are an important milestone on the road map to JuMP 1.0. This project aims to improve...",
          "slug": "ecosystem-improvements-and-a-jumptutorialsjl-package",
          "status": "completed",
          "student_name": "Arpit Bhatia",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Ecosystem Improvements and a JuMPTutorials.jl Package"
        },
        {
          "code_url": "https://github.com/Ban-zee/GSoC_2019/blob/master/final_submission.md",
          "description": "<p>Numba is a JIT(just in time) compiler that compiles a given section of the code(specified by the user) at a given time instead of compiling the entire code at once. \nThe aim of the project is to identify the possible bottlenecks in the code in order to speed up the overall code execution by applying numba project wide . Another part of this project is to vectorize the functions(specifically for stats and diagnostics) using xarray ufuncs to broadcast across xarrays.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5918784890601472/",
          "proposal_id": null,
          "short_description": "Numba is a JIT(just in time) compiler that compiles a given section of the code(specified by the user) at a given time instead of compiling the...",
          "slug": "apply-numba-project-wide",
          "status": "completed",
          "student_name": "Aniruddha Banerjea",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Apply Numba Project Wide"
        },
        {
          "code_url": "https://github.com/JuliaOpt/Dualization.jl",
          "description": "<p>We will implement a MathOptInterface feature that allows JuMP to take an optimization problem in its primal form and return the dual form in terms of Lagrangian duality. The primary project goal is that this feature should work with linear optimization problems and conic optimization problems that can be written in pure JuMP (JuMP extensions will be a bonus).</p>\n<p>The project does not depend on any other Julia packages; it should be a pure implementation that builds on top of the existing MathOptInterface.jl package.</p>\n<p>The main project benefits are:</p>\n<ul>\n<li>Easily enabling all the users to exploit the dual formulation of an optimization problem (potentially gaining performance for the user application)</li>\n<li>Getting one step closer to allowing users to write the KKT conditions of a problem.</li>\n</ul>\n<p>These two benefits are strong building blocks for the academic optimization community. They should bring long-term benefits to research in optimization.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_018",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5195472317186048/",
          "proposal_id": null,
          "short_description": "We will implement a MathOptInterface feature that allows JuMP to take an optimization problem in its primal form and return the dual form in terms of...",
          "slug": "jump-automatic-dualization",
          "status": "completed",
          "student_name": "Guilherme Bodin",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "JuMP Automatic Dualization"
        },
        {
          "code_url": "https://gist.github.com/IgorBaratta/038747f9aff44eb844c0913614bf0c03",
          "description": "<p>One of the main ingredients in DOLFIN’s native support of parallel computations is the mesh partitioner. The mesh partitioner seeks to ensure a load balance among processing elements and reduce the number of shared elements on partition boundaries, in order to minimize the communication overhead.  Currently, the users can pick from SCOTCH or ParMETIS partitioners, neither of which are actively maintained.\nThe KaHIP partitioner is an alternative that is being actively maintained and promises more scalable and higher quality results than the state-of-the-art partitioners such as ParMetis or PT-Scotch. The purpose of this project is to add the KaHIP partitioner to DOLFIN's graph wrappers and mesh partitioning and investigate whether the promised improvements will reflect on the dolfin's parallel toolchain.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2019_019",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2019/projects/5213659171651584/",
          "proposal_id": null,
          "short_description": "One of the main ingredients in DOLFIN’s native support of parallel computations is the mesh partitioner. The mesh partitioner seeks to ensure a load...",
          "slug": "interface-to-kahip-partitioner",
          "status": "completed",
          "student_name": "Igor Almeida Baratta",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Interface to KaHIP partitioner"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2019/organizations/5617300198129664/"
    },
    "year_2020": {
      "num_projects": 28,
      "projects": [
        {
          "code_url": "https://agustinaarroyuelo.github.io/jekyll/update/2020/08/23/GSoC-with-ArviZ-2020-Final-Evaluation.html",
          "description": "<p>This Google Summer of Code 2020 project aims to increase support for circular and discrete variables in the ArviZ library. ArviZ currently provides tools  and diagnosis for Bayesian data analysis and it is very well supported for continuous variables. However, there is plenty of space for new developments when it comes to discrete and circular variables. As a result of this project, several new plots will be incorporated into ArviZ, for example: mosaic plot,  agreement plot, circular KDE, circular histogram. On the other hand, ArviZ current implementations will be revised and extended for the circular and discrete variable setting.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6436002761015296/",
          "proposal_id": null,
          "short_description": "This Google Summer of Code 2020 project aims to increase support for circular and discrete variables in the ArviZ library. ArviZ currently provides...",
          "slug": "increase-support-for-circular-and-discrete-variables-in-arviz",
          "status": "completed",
          "student_name": "Agustina Arroyuelo",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Increase support for circular and discrete variables in ArviZ"
        },
        {
          "code_url": "http://www.imakshay.com/post/24",
          "description": "<p>Differentiable optimization is a promising field of convex optimization and has many potential applications in game theory, control theory and machine learning. Unlike <code>cvxpy</code>, <code>JuMP</code> currently lacks the feature to differentiate solutions of disciplined convex optimization problems and render them as layers in machine learning libraries. I propose to develop this feature and make it accessible from the <code>JuMP</code> interface.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5474790959218688/",
          "proposal_id": null,
          "short_description": "Differentiable optimization is a promising field of convex optimization and has many potential applications in game theory, control theory and...",
          "slug": "optimization-problem-differentiation",
          "status": "completed",
          "student_name": "AkshaySharma",
          "student_profile": null,
          "tags": [],
          "title": "Optimization problem differentiation"
        },
        {
          "code_url": "https://percygautam.github.io/gsoc/final_eval.html",
          "description": "<p>ArviZ is a Python package for exploratory analysis of Bayesian models, intending to provide backend-agnostic tools for diagnostics and visualizations of Bayesian inference in Python. Generally, Bayesian inference generates numerous datasets that represent different aspects of the model. To simplify the handling, referencing, and serialization of data generated during Bayesian analysis, ArviZ uses a couple of data structures: <em>xarray.Dataset</em>, <em>arviz.InferenceData</em> and <em>netCDF</em>.</p>\n<p>InferenceData objects are central to ArviZ and most ArviZ functions take InferenceData as input. However, its functionality is still quite limited. The main aim of the project is to extend some methods from <em>xarray.Dataset</em> and to create specific InferenceData methods. Special attention would be given to test and document these new functionalities with examples.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6143921631002624/",
          "proposal_id": null,
          "short_description": "ArviZ is a Python package for exploratory analysis of Bayesian models, intending to provide backend-agnostic tools for diagnostics and visualizations...",
          "slug": "extend-inferencedata-capabilities",
          "status": "completed",
          "student_name": "Piyush Gautam",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui",
            "backend"
          ],
          "title": "Extend InferenceData Capabilities"
        },
        {
          "code_url": "https://ramantehlan.github.io/blog/post/2020/gsoc/final-report/",
          "description": "<p>This project aims to support reproducible computing using nteract and Binder—the ability to start an interactive session via a unique URL, with content provided by any version control system and executed in a remote environment. To begin with, Github API can be used to fetch and save content, but the scope of the project can be adjusted to deal with different VCS. The Github repo can be launched on a binder instance, and the code samples can run on it.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4967515626668032/",
          "proposal_id": null,
          "short_description": "This project aims to support reproducible computing using nteract and Binder—the ability to start an interactive session via a unique URL, with...",
          "slug": "reproducible-computing-with-nteract-play",
          "status": "completed",
          "student_name": "Raman Tehlan",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Reproducible computing with nteract play"
        },
        {
          "code_url": "https://matplotlib.org/matplotblog/posts/gsoc_2020_final_work_product/",
          "description": "<p>This is a proposal to help with the difficulty in adding/modifying tests which require a baseline image.  The idea is to actually not store baseline images in the repo. The fundamental idea here is <strong>instead of comparing against a fixed baseline, compare a commit to the next</strong>.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5108894776426496/",
          "proposal_id": null,
          "short_description": "This is a proposal to help with the difficulty in adding/modifying tests which require a baseline image.  The idea is to actually not store baseline...",
          "slug": "baseline-images-problem",
          "status": "completed",
          "student_name": "Sidharth Bansal-1",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Baseline Images Problem"
        },
        {
          "code_url": "https://ashishpriyadarshicic.github.io/jekyll/update/2020/08/30/GSoC-blog-final.html",
          "description": "<p>The Data Retriever is a package manager for data. The Data retriever automatically finds, downloads and pre-processes publicly available datasets and it stores these datasets in a ready-to-analyse state. The Data Retriever handles tabular data and spatial data forms. The goal of the project is to add support that will enable the Data Retriever platform to have the capability of ingesting other forms of raw data. The project will introduce the support for raw data formats of XML, JSON, NetCDF, HDF, Excel, SQlite and Geojson data sources.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5110925658423296/",
          "proposal_id": null,
          "short_description": "The Data Retriever is a package manager for data. The Data retriever automatically finds, downloads and pre-processes publicly available datasets and...",
          "slug": "data-retriever-add-support-for-more-raw-data-formats",
          "status": "completed",
          "student_name": "AshishPriyadarshi",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Data Retriever: Add support for more raw data formats"
        },
        {
          "code_url": "https://morty.tech/notes/gsoc-final-report/",
          "description": "<p><code>aiida-core</code> uses <code>plumpy</code> as its workflow backend and uses <code>circus</code> to daemonize its workflow manager process. However, the <code>plumpy</code> workflow library, and the circus process &amp; socket manager have not kept up with recent developments, forcing libraries of AiiDA ecosystem to run with outdated versions of <code>tornado</code>, and making it incompatible with the latest python web technology. In this project, I will replace <code>tornado</code> dependencies of <code>plumpy</code> and <code>aiida-core</code> by <code>asyncio</code> to  enable full support of <code>asyncio</code> in <code>aiida-core</code>. If the goals and deliverables are reached before the end of the project, I will also migrate <code>circus</code>, which is also used by many other open-source projects besides AiiDA, from <code>tornado</code> to <code>asyncio</code>.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5283081100984320/",
          "proposal_id": null,
          "short_description": "aiida-core uses plumpy as its workflow backend and uses circus to daemonize its workflow manager process. However, the plumpy workflow library, and...",
          "slug": "aiida-full-support-of-asyncio-in-aiida-core",
          "status": "completed",
          "student_name": "Jason Yu",
          "student_profile": null,
          "tags": [
            "python",
            "web",
            "ai",
            "backend"
          ],
          "title": "AiiDA: Full support of asyncio in aiida-core"
        },
        {
          "code_url": "https://www.codingpaths.com/gsoc/work-summary/",
          "description": "<p>Variational Inference is a powerful algorithm that turns the task of computing the posterior(p(z|x)) into an optimization problem.  This project is about implementing two inference algorithms Mean Field ADVI and Full Rank ADVI based on <a href=\"https://arxiv.org/pdf/1603.00788.pdf\" target=\"_blank\">ADVI</a> paper in PyMC4. Mean Field ADVI posits a spherical Gaussian family and Full Rank ADVI posits a Multivariate Gaussian family to minimize KL divergence. The implementation will use <code>tf</code> and <code>tfp</code> libraries.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6215347071352832/",
          "proposal_id": null,
          "short_description": "Variational Inference is a powerful algorithm that turns the task of computing the posterior(p(z|x)) into an optimization problem.  This project is...",
          "slug": "add-variational-inference-interface-to-pymc4",
          "status": "completed",
          "student_name": "Sayam Kumar",
          "student_profile": null,
          "tags": [],
          "title": "Add Variational Inference Interface to PyMC4"
        },
        {
          "code_url": "https://gist.github.com/OmarWagih1/5d10ec006f09ccab138d5e5ff2ff07e7",
          "description": "<p>Colour, an affiliated project of NumFOCUS, a 501(c)(3) nonprofit in the United States currently uses NumPy for most of its calculations, while NumPy is a highly flexible library, it only runs on the CPU which makes it a little slow when running your code on an array of high quality images, this calls for an option to use the GPU so we can make parallel processing a possibility.</p>\n<p>Before adding more libraries and possibly making the maintenance of Colour harder, we should measure where we are at to figure out if increase in speed is worth it, we can only do this by benchmarking the most critical parts of our package, benchmarking is really important as it makes sure that you have an objective measure of how your function performs under simple and intensive ways.</p>\n<p>In this project we're going to implement a partial benchmarking suite using ASV (airspeed velocity) and then search for options to use the GPU for calculations instead of numpy to get the functions to perform better, some of the options to research is using CuPy or Bohrium.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6217568139870208/",
          "proposal_id": null,
          "short_description": "Colour, an affiliated project of NumFOCUS, a 501(c)(3) nonprofit in the United States currently uses NumPy for most of its calculations, while NumPy...",
          "slug": "colour-suborganization-the-need-for-speed",
          "status": "completed",
          "student_name": "Omar Wagih",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Colour suborganization - The Need for Speed"
        },
        {
          "code_url": "https://github.com/qgrad/qgrad",
          "description": "<p>Proposal to add machine learning modules in QuTiP</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6236825565265920/",
          "proposal_id": null,
          "short_description": "Proposal to add machine learning modules in QuTiP",
          "slug": "gsoc-machine-learning-with-qutip",
          "status": "completed",
          "student_name": "Asad",
          "student_profile": null,
          "tags": [],
          "title": "GSoC: Machine Learning with QuTiP"
        },
        {
          "code_url": "https://signac.io/gsoc/2020/08/21/gsoc-vishav-blog-6.html",
          "description": "<p>Signac is a data management framework named after the painter Paul Signac, whose colourful pointillist style resembles a collection of data \"points\". The signac framework is designed to help researchers design, manage, and execute computational studies. The core data management package signac helps users track data and metadata for file-based workflows (e.g. large molecular simulations) with features for searchability, collaboration, reproducibility, and archival. It stores the data in a JSON file using SyncedAttrDict and JSONDict classes.\nCurrently, Signac uses SyncedAttrDict to store the statepoints and JSONDict to store the documents. In this project, the aim will be to unify the synced collection classes and improve buffering, synchronization and support to different data structures. Also, this project will deal with refractoring the statepoint loading to be lazy.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4562441154854912/",
          "proposal_id": null,
          "short_description": "Signac is a data management framework named after the painter Paul Signac, whose colourful pointillist style resembles a collection of data \"points\"....",
          "slug": "signac-improve-sync-data-structures",
          "status": "completed",
          "student_name": "Vishav Sharma",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Signac: Improve Sync Data Structures"
        },
        {
          "code_url": "https://gist.github.com/alanlujan91/cee20f796a33acd86a090fd62fbb2ec7",
          "description": "<p>Initial GPU support for HARK models</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4594702063501312/",
          "proposal_id": null,
          "short_description": "Initial GPU support for HARK models",
          "slug": "econark-proposal",
          "status": "completed",
          "student_name": "Alan Lujan",
          "student_profile": null,
          "tags": [],
          "title": "EconArk Proposal"
        },
        {
          "code_url": "http://redman.xyz/gsoc-2020-work-product-submission",
          "description": "<p>Traditional rendering is based on the idea that light can be decomposed into three basic components: red, green and blue (RGB). In some areas this is a vast oversimplification of the physical reality; light exists on a continuous spectrum of wavelengths. Spectral rendering achieves better accuracy by taking that into account. The major drawback is that it cannot use widely available color data for surfaces such as photographs. The process of gathering usable spectral data is significantly more time- and resource-intensive.</p>\n<p>Spectral upsampling is the process of extrapolating spectral information from RGB color data. This is possible because, in practice, spectral reflectivities, which describe how a surface interacts with incident light on a wavelength-by-wavelength basis, tend to fit relatively simple patterns. The goal would be to add support for several newly published algorithms to Colour, a color science library for Python. With the rising popularity of spectral rendering, the library would greatly benefit from the work.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4720131147563008/",
          "proposal_id": null,
          "short_description": "Traditional rendering is based on the idea that light can be decomposed into three basic components: red, green and blue (RGB). In some areas this is...",
          "slug": "new-spectral-upsampling-methods",
          "status": "completed",
          "student_name": "Paweł Redman",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "New Spectral Upsampling Methods"
        },
        {
          "code_url": "https://discourse.effective-quadratures.org/t/google-summer-of-code-review-implementing-polynomial-regression-trees-in-effective-quadratures/74",
          "description": "<p>Effective Quadratures is an open source library used to generate polynomials for parametric computational studies. Among the applications of the library is the ability to perform polynomial regression on a dataset. I propose an implementation of a polynomial regression tree class in Effective Quadratures which will offer greater accuracy when extrapolating compared to the current polynomial regression class.</p>\n<p>By implementing a polynomial regression tree class I believe that I will help demonstrate some of the benefits of using orthogonal polynomials in the context of model trees. For example users of the library will be able to calculate sensitivity indices and moments over subdomains of functions and datasets. This has the benefit of providing more information about the dataset than was previously possible in the library.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4827419799715840/",
          "proposal_id": null,
          "short_description": "Effective Quadratures is an open source library used to generate polynomials for parametric computational studies. Among the applications of the...",
          "slug": "implementing-polynomial-regression-trees-in-effective-quadratures",
          "status": "completed",
          "student_name": "Barney Hill",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Implementing polynomial regression trees in Effective Quadratures"
        },
        {
          "code_url": "https://sarsid.wordpress.com/2020/08/24/a-gsoc-summary/",
          "description": "<p>The primary motivation of the project is to enhance quantum circuit (qutip.qip.circuit) and noise simulation capabilities of the QuTIP package. By adding a number of features to the quantum circuit module, we hope to be able to further extend the NISQ (Noisy-Intermediate Scale Quantum) capabilities first introduced by Boxi Li in GSOC 2019 project.</p>\n",
          "difficulty": "medium",
          "id": "proj_numfocus_2020_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4828150850125824/",
          "proposal_id": null,
          "short_description": "The primary motivation of the project is to enhance quantum circuit (qutip.qip.circuit) and noise simulation capabilities of the QuTIP package. By...",
          "slug": "quantum-circuits-improvement-for-qutip",
          "status": "completed",
          "student_name": "Sidhant Saraogi",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Quantum Circuits Improvement for QUTIP"
        },
        {
          "code_url": "https://gist.github.com/MgeeeeK/15426217eb5f368ca0ff12f66c2b5823",
          "description": "<p>PySAL was designed with the focus of performing vector-based spatial analysis and therefore it didn't have tools to handle input-output of large raster data. In recent years several geographic data organizations started releasing data in raster format which earlier came in vector format mostly because of advancement in computational capabilities and high storage availability. This led to an increase in the demand for the functionality offered by PySAL to make it work with raster data.</p>\n<p>Taking this into consideration, my main aim is to design and implement a lightweight interface which will provide the functionality for streamlining raster data access and making it more accessible to build the data structure accepted by the analytical methods of the PySAL library (mainly <code>libpysal.weights.W/WSP</code> objects) from accessed raster data (which will be an instance of <code>xarray.DataArray</code>). Ultimately, this functionality will open up the use of analytical methods like <code>esda</code>, <code>spatial regression</code> over raster data.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6547799585325056/",
          "proposal_id": null,
          "short_description": "PySAL was designed with the focus of performing vector-based spatial analysis and therefore it didn't have tools to handle input-output of large...",
          "slug": "raster-awareness-in-pysal",
          "status": "completed",
          "student_name": "Mragank Shekhar",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "Raster awareness in PySAL"
        },
        {
          "code_url": "https://tirthasheshpatel.github.io/gsoc2020/gsoc-final-report",
          "description": "<p>My goal for GSoC 2020 is to implement, test, and maintain a higher-level API for Gaussian Processes in PyMC4 using TensorFlow and TensorFlow Probability and write tutorials/articles and notebooks explaining their usage.</p>\n<p>My work consists of implementing Gaussian Process Modes and writing optimization methods like Newton's Method and Powell's Method to find the maximum a-posteriori of the models. My goal is also to implement at least one approximation technique when full GP modelling becomes impractical.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6568118874275840/",
          "proposal_id": null,
          "short_description": "My goal for GSoC 2020 is to implement, test, and maintain a higher-level API for Gaussian Processes in PyMC4 using TensorFlow and TensorFlow...",
          "slug": "adding-gaussian-processes-and-optimization-methods-in-pymc4",
          "status": "completed",
          "student_name": "Tirth Patel",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Adding Gaussian Processes and Optimization Methods in PyMC4"
        },
        {
          "code_url": "https://gist.github.com/paulblum/851fb7ce80b7acf30aa8a31b0950f386",
          "description": "<p>Combustion has enabled our technologies in electricity production, heating, transportation, and industry. Advancements in combustion technologies depend on computer simulation software; one such software is Cantera, an open-source chemical kinetics program. This project proposes the development of a new solver for Cantera to equip users with a tool to simulate and analyze 0-D steady-state combustion systems. These types of systems are idealized theoretical models that are used as good approximations of certain real combustion systems, or as building blocks towards more complex ones. The development of this solver will begin with mathematical modeling of the physical laws that define 0-D steady state combustion systems. It will require the application of numerical analysis techniques to quickly approximate accurate solutions. Then, it will be coded into the Cantera source code and thoroughly tested before release as a new feature in the next official version of Cantera.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2020_018",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6013790295949312/",
          "proposal_id": null,
          "short_description": "Combustion has enabled our technologies in electricity production, heating, transportation, and industry. Advancements in combustion technologies...",
          "slug": "developing-a-0-d-steady-state-combustion-solver-for-cantera",
          "status": "completed",
          "student_name": "Paul Blum",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Developing a 0-D Steady-State Combustion Solver for Cantera"
        },
        {
          "code_url": "https://github.com/jeffcsauer/GSOC2020/blob/master/blog_drafts/Sauer_GSOC2020_Summary.md",
          "description": "<p>The goal of this project is to add several recently developed spatial estimators to the exploratory spatial data analysis (esda) submodule of PySAL, the Python Spatial Analysis Library. This project will allow researchers to easily deploy these estimators in existing spatial workflows. Specifically, this project will contribute implementation, docstrings, tests, and example notebooks for (1) bivariate local join count statistics, (2) multivariate local join count statistics, and (3) local spatial heteroskedasticity (LOSH) statistics. In the first phase of this project, each estimator will be reviewed and pseudo-coded to identify areas of optimization. In the second phase, the estimators will be implemented with tests, with performance assessed against spatial datasets of different sizes. In the final phase, example notebooks will be drafted and polished to a quality ready for external (e.g. workshop) use.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_019",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6017890244886528/",
          "proposal_id": null,
          "short_description": "The goal of this project is to add several recently developed spatial estimators to the exploratory spatial data analysis (esda) submodule of PySAL,...",
          "slug": "pysal-esda-enhancements-local-join-count-and-losh-statistics",
          "status": "completed",
          "student_name": "Jeffery Sauer",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "PySAL ESDA Enhancements: Local join count and LOSH statistics"
        },
        {
          "code_url": "https://hackmd.io/@YByKuO31SAe98_0pwNZEdA/S1oURR_7w",
          "description": "<p>The project is to add more comprehensive support for mcmc sampler methods in PyMC4. Currently there is no support for discrete distributions in model, support for gradient-free samplers, etc. The goal of the project is to expand the support for mcmc sampling, add various samplers, including SMC, etc.. Also, from the design perspective there is a need for compound step/Gibbs sampling. We need to collaborate with the Tensorflow Probability team developers to implement the most effective solution.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_020",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4878343515668480/",
          "proposal_id": null,
          "short_description": "The project is to add more comprehensive support for mcmc sampler methods in PyMC4. Currently there is no support for discrete distributions in...",
          "slug": "support-more-than-one-sampler-in-pymc4",
          "status": "completed",
          "student_name": "Rasul Karimov",
          "student_profile": null,
          "tags": [],
          "title": "Support more than one sampler in PyMC4"
        },
        {
          "code_url": "https://signac.io/gsoc/2020/08/22/gsoc-hardik-blog-6.html",
          "description": "<p>This project enhances the workflow system of the signac framework by allowing the users to aggreagate over group(s) of jobs.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_021",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4911841005797376/",
          "proposal_id": null,
          "short_description": "This project enhances the workflow system of the signac framework by allowing the users to aggreagate over group(s) of jobs.",
          "slug": "aggregation-workflows-on-groups-of-jobs-signac-flow",
          "status": "completed",
          "student_name": "Hardik Ojha",
          "student_profile": null,
          "tags": [],
          "title": "Aggregation: Workflows on Groups of Jobs (signac-flow)"
        },
        {
          "code_url": "https://tomasfmg.github.io/jekyll/update/2020/08/31/firstpost.html",
          "description": "<p>The idea is to update ParameterJuMP.jl to enable users to add parameters to JuMP arithmetics in linear mode. By doing so, users will be able to modify constraints as the parameter values changes, as well as extract useful information. This is allow a more efficient implementation for Stochastic Optimization methods, expanding JuMP's flexibility.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_022",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/4959861055422464/",
          "proposal_id": null,
          "short_description": "The idea is to update ParameterJuMP.jl to enable users to add parameters to JuMP arithmetics in linear mode. By doing so, users will be able to...",
          "slug": "adding-parameters-to-jump-and-mathoptinterface",
          "status": "completed",
          "student_name": "Tomás Gutierrez",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Adding parameters to JuMP and MathOptInterface"
        },
        {
          "code_url": "https://docs.google.com/document/d/1q-XAzllxxgY6YDtoyjotv26adeJtZMlcA4YBxps-A6s/edit?usp=sharing",
          "description": "<p>Implementing the polynomial set of NumPy functions that are not yet supported in CuPy with a better performance and speedup. These functions are NumPy-compatible to allow drop-in replacement but with GPUs' parallel computing advantages.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_023",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5856911817179136/",
          "proposal_id": null,
          "short_description": "Implementing the polynomial set of NumPy functions that are not yet supported in CuPy with a better performance and speedup. These functions are...",
          "slug": "cupy-coverage-of-numpy-functions",
          "status": "completed",
          "student_name": "Dahlia Shehata",
          "student_profile": null,
          "tags": [],
          "title": "CuPy coverage of NumPy functions"
        },
        {
          "code_url": "https://binhbar.com/posts/2020/08/qutip-data-layer-summer-of-code-round-up/",
          "description": "<p>The core Qobj class in QuTiP specifically uses a custom scipy-derived sparse-matrix format for data storage, which allows simulation and optimisations on large open quantum systems but causes significant memory and computational overhead on smaller-dimensioned systems, and the 32-bit index size can prevent even extremely sparse systems of high numbers of qubits from being representable.  This project will decouple the low-level data manipulation procedures from the algebraic manipulations performed within the rest of QuTiP, encapsulating the low-level data manipulation into a higher-level interface, which will allow multiple storage formats to be used at the appropriate situations transparently.  Overall, QuTiP will be able to spread its impressive performance to all problem-size domains without compromising on future maintainability or extensibility as demands for numerical quantum simulations increase.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_024",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5879076230791168/",
          "proposal_id": null,
          "short_description": "The core Qobj class in QuTiP specifically uses a custom scipy-derived sparse-matrix format for data storage, which allows simulation and...",
          "slug": "abstraction-of-linear-algebra-data-structures-in-qutip",
          "status": "completed",
          "student_name": "Jake Lishman",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Abstraction of Linear Algebra Data Structures in QuTiP"
        },
        {
          "code_url": "https://viniciusdc.github.io/Work%20product/",
          "description": "<p>Conda-forge, an umbrella project of NumFOCUS, is a community effort that provides conda packages for a wide range of software. As an important part of its structure the conda forge \"auto-tick\" bot enables automatic maintenance of conda-forge packages. This project aims at the improvement of the conda-forge \"auto-tick\" bot structure, more specifically, separating the version updates structure to its own microservice, creating a more organic environment for the bot, which in return will simplify the process of its migration to other data structures like Dynamodb.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_025",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5995276604538880/",
          "proposal_id": null,
          "short_description": "Conda-forge, an umbrella project of NumFOCUS, is a community effort that provides conda packages for a wide range of software. As an important part...",
          "slug": "improved-automatic-maintenance-of-conda-forge",
          "status": "completed",
          "student_name": "Vinicius Cerutti",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Improved automatic maintenance of conda-forge"
        },
        {
          "code_url": "https://rohitsanjay.com/gsoc/final-report",
          "description": "<p><a href=\"https://github.com/nteract/testbook\" target=\"_blank\">testbook</a> is a unit testing framework extension for testing code in Jupyter Notebooks.</p>\n<p>Previous attempts at unit testing notebooks involved writing the tests in the notebook itself. However, testbook will allow for unit tests to be run against notebooks in separate test files, hence treating .ipynb files as .py files.</p>\n<p>testbook helps you set up conventional unit tests for your Jupyter Notebooks.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_026",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6007405021757440/",
          "proposal_id": null,
          "short_description": "testbook is a unit testing framework extension for testing code in Jupyter Notebooks.\nPrevious attempts at unit testing notebooks involved writing...",
          "slug": "testbook-unit-test-framework-for-jupyter-notebooks",
          "status": "completed",
          "student_name": "Rohit Sanjay",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "testbook - unit test framework for Jupyter notebooks"
        },
        {
          "code_url": "https://gist.github.com/pabloestradac/ec7b50ab1d3772be63df9ba56278e9df",
          "description": "<p>This project aims to extend the functionality of pysal.spreg to deal with panel data econometric models. Spatial panels refer to data containing time series observations of a number of geographical units. Specifically, this project will focus on static panel models with fixed and random effects. Also, I will develop a framework to test the spatial lag, the spatial error model, and the spatial Durbin model against each other, as well as a framework to choose among fixed effects, random effects or a model without fixed/random effects. Thus, this project will handle panel data, estimate panel models and provide specification tests.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_027",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/6329474586509312/",
          "proposal_id": null,
          "short_description": "This project aims to extend the functionality of pysal.spreg to deal with panel data econometric models. Spatial panels refer to data containing time...",
          "slug": "pysal-project-on-panel-data-spatial-econometrics",
          "status": "completed",
          "student_name": "Pablo Estrada C",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "PySAL Project on Panel Data Spatial Econometrics"
        },
        {
          "code_url": "https://gist.github.com/njwardhan/1ce173488240455cf2bf2a0fa5ff8199",
          "description": "<p>The lookup table (LUT) is supported by Colour-Science fairly well. However, there are several improvements which can be made to its input and output (I/O) capabilities by adding new features and improving the already existing ones. This is what this project primarily aims at!</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2020_028",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2020/projects/5183963422785536/",
          "proposal_id": null,
          "short_description": "The lookup table (LUT) is supported by Colour-Science fairly well. However, there are several improvements which can be made to its input and output...",
          "slug": "lut-io-improvements",
          "status": "completed",
          "student_name": "Nishant Joywardhan",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "LUT IO Improvements"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2020/organizations/6692416771325952/"
    },
    "year_2021": {
      "num_projects": 45,
      "projects": [
        {
          "code_url": "https://kc611.github.io/blog_posts/2021/gsoc-work-summary.html",
          "description": "<p>PyMC is currently developing the new PyMC3 4.x version. Core changes involve the use of the new RandomVariable class to simplify/speed up random sampling and emphasis on using dynamic shapes during pre-sampling analysis. The main aim of this project is to assist the conversion of the remaining PyMC3 codebase.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6353283836280832/",
          "proposal_id": null,
          "short_description": "PyMC is currently developing the new PyMC3 4.x version. Core changes involve the use of the new RandomVariable class to simplify/speed up random...",
          "slug": "new-version-refactoring",
          "status": "completed",
          "student_name": "Kaustubh Chaudhari",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "New Version Refactoring"
        },
        {
          "code_url": "https://medium.com/@a.bharambe123/gsoc-2021-numfocus-final-report-2b2f32b63492",
          "description": "<p>NeuralPDE.jl is a Julia package that employs neural networks to obtain a solution of high dimensional differential equations and hence overcoming the curse of dimensionality.One of the techniques that uses Scientific Machine Learning to solve PDEs is Physics Informed Neural Networks (PINNs). The project aims at extending the application of the PINN algorithm to integro- differential equations. The project also propose to add support for constrained equations and different geometry for PINNs.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6368910135263232/",
          "proposal_id": null,
          "short_description": "NeuralPDE.jl is a Julia package that employs neural networks to obtain a solution of high dimensional differential equations and hence overcoming the...",
          "slug": "adding-integro-differential-equations-and-improving-symbolic-representation-of-geometry-in-pinns",
          "status": "completed",
          "student_name": "Ashutosh Bharambe",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Adding Integro Differential Equations and Improving symbolic representation of geometry in PINNs"
        },
        {
          "code_url": "https://utkarsh-maheshwari.medium.com/gsoc-2021-time-series-and-regression-plots-final-report-f8a416c1b3cb",
          "description": "<p>ArviZ is a Python package for exploratory analysis of Bayesian models, intending to provide backend-agnostic tools for diagnostics and visualizations of Bayesian inference in Python. There are currently no specific plots in arviz to visualize time series or regression models.\nMy proposal is to add time series plots including line and scatter plots to the library to visualize the uncertainty in the actual data vs the range of predicted data. Dataset is assumed to be provided by the user. The project includes the documentation of functions implemented and examples for each of them.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6405518859436032/",
          "proposal_id": null,
          "short_description": "ArviZ is a Python package for exploratory analysis of Bayesian models, intending to provide backend-agnostic tools for diagnostics and visualizations...",
          "slug": "increase-support-for-time-series-and-regressions-python",
          "status": "completed",
          "student_name": "Utkarsh Maheshwari",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "backend"
          ],
          "title": "Increase support for time-series and regressions (Python)"
        },
        {
          "code_url": "https://lenkahas.com/post/gsoc.html",
          "description": "<p>Competing Destination (CD) models, which are an extension of Spatial Interaction (SI)  models, has been around since 1980's  and are often used within Economic and Social Sciences  . CD models involve the analysis of flows from an origin to a destination similarly to traditional SI models, however, CD includes the ‘Competing Destination’ term also known as ‘Accessibility’ term, which accounts for the spatial-structure effect of the flows from behavioural perspective.\nAlthough the SI models are established within Python and R modules already (SpInt, simR),  specification for deriving Accessibility term for CD estimation is missing. \nThis project aims to fill this gap by developing a Competing Destination class that will include the computation of the accessibility term and will be binded to the existing SpInt module. The main challenge here is the scaling of the accessibility computation for large datasets. This is an important aspect of the project as flow datasets often have hundred thousands and even millions records.\nThis project will extend the use of the SpInt module and PySAL library for high level analysis of spatial flows.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6570342927040512/",
          "proposal_id": null,
          "short_description": "Competing Destination (CD) models, which are an extension of Spatial Interaction (SI)  models, has been around since 1980's  and are often used...",
          "slug": "competing-destination-for-spatial-interaction-models-spintpysal",
          "status": "completed",
          "student_name": "Lenka Hasova",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "Competing destination for Spatial Interaction models, SpInt/PySal"
        },
        {
          "code_url": "https://gist.github.com/villirion/d9cbbcf07f9604aaaa06191aa8ba2011",
          "description": "<p>My project is divided into three parts:</p>\n<ul>\n<li>What is the Space of Spectral Sensitivity Functions for Digital Color Cameras</li>\n<li>Implementation of new colour.appearance model</li>\n<li>Color.models sub-package in \"object\"</li>\n</ul>\n<p>For the first two parts, my work will consist in studying scientific publications with the aim of recovering the mathematical formulas of the models to port them in python and for the third part my work consists in refactoring the python code in \"object\".</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6587463841087488/",
          "proposal_id": null,
          "short_description": "My project is divided into three parts:\n\nWhat is the Space of Spectral Sensitivity Functions for Digital Color Cameras\nImplementation of new...",
          "slug": "colour-science-for-python",
          "status": "completed",
          "student_name": "Cédric Dollet",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "Colour-Science for python"
        },
        {
          "code_url": "https://mjsheikh.github.io/blog/post/final_report/",
          "description": "<p>The SciML DiffEqOperators.jl library allows to solve PDEs by transforming them into ODEs via finite difference discretizations and carries support for automated discretizations of symbolically defined PDEs. Basic Linear Operators for derivative computations and common boundary conditions handling exist but others relating to Vector calculus computations are still required for more realistic problem handling. The symbolic handling using MOL discretizations works for preliminary setups and craves for a lot of Add-ons like higher dimension handling etc. Apart from these, enhancements with respect to memory allocation and concretizations of new operators would be a plus. This project would aim to provide these functionalities so that the package caters more generic problems with an enhanced interface.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5648079365079040/",
          "proposal_id": null,
          "short_description": "The SciML DiffEqOperators.jl library allows to solve PDEs by transforming them into ODEs via finite difference discretizations and carries support...",
          "slug": "sciml-discretizations-of-partial-differential-equations",
          "status": "completed",
          "student_name": "Mohammed Jeeshan Sheikh",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "SciML : Discretizations of partial differential equations"
        },
        {
          "code_url": "https://github.com/noilreed",
          "description": "<p>GSoC Proposal: Multi-Start Optimization Methods</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5668720843685888/",
          "proposal_id": null,
          "short_description": "GSoC Proposal: Multi-Start Optimization Methods",
          "slug": "gsoc-proposal-multi-start-optimization-methods",
          "status": "completed",
          "student_name": "Ping Zhang",
          "student_profile": null,
          "tags": [],
          "title": "GSoC Proposal: Multi-Start Optimization Methods"
        },
        {
          "code_url": "https://github.com/noahbouchier/GSoC-PySAL-21/blob/master/NoahBouchier_GSoC21_NumFOCUS_PySAL_Summary.md",
          "description": "<p>This project is focused on incorporating a multiscalar segregation metric into the Python Spatial Analysis Library (<a href=\"https://pysal.org/\" target=\"_blank\">PySAL</a>) toolset.</p>\n<p>Following on from the suggestion of a methodology to provide <a href=\"https://doi.org/10.1073/pnas.1900192116\" target=\"_blank\">“Segregation through the multiscalar lens” (Olteanu et al., 2019)</a>, it has been the goal of the PySAL community to create a convenient function to undertake this methodology; computing the levels of divergence between different sub-areas and the total population of the area, using the <a href=\"https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\" target=\"_blank\">Kullback-Leiber (KL)</a> technique (also referred to as relative entropy).</p>\n<p>Building on the work of this paper, the pre-existing <a href=\"https://github.com/pysal/segregation/issues/142\" target=\"_blank\">discussions within the PySAL community</a> regarding this function, and the code contributed by <a href=\"https://github.com/ceciledebezenac/segregation_index\" target=\"_blank\">Cécile de Bézenac</a> to compute this measure, this project will provide an efficient, easy-to-use function to compute this divergence-based metric of segregation. It will provide workbooks that walkthrough how the function can be ran, as well as examples of how to use the output to produce informative visualisations that help unpick the complex patterns of segregation between multiple groups.</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2021_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5669900315525120/",
          "proposal_id": null,
          "short_description": "This project is focused on incorporating a multiscalar segregation metric into the Python Spatial Analysis Library (PySAL) toolset.\nFollowing on from...",
          "slug": "implementing-a-multiscalar-segregation-metric-pysal",
          "status": "completed",
          "student_name": "Noah Bouchier",
          "student_profile": null,
          "tags": [
            "python",
            "ui"
          ],
          "title": "Implementing a multiscalar segregation metric | PySAL"
        },
        {
          "code_url": "https://gist.github.com/Saransh-cpp/5f61540819b8c8d552c12b1609915f5d",
          "description": "<p>This project aims to build an automated Twitter bot, using PyBaMM's wide range of abilities, that</p>\n<ol>\n<li>Generates battery degradation simulations with random conditions, models, and experiments using PyBaMM.</li>\n<li>Tweets them at regular intervals of time.</li>\n<li>Is able to read humanly tweets and respond to them if required.</li>\n<li>Can plot and reply with any simulation that is requested by a Twitter user.</li>\n</ol>\n<p>This, in turn, will be beneficial for the ever-developing PyBaMM's codebase by making it more efficient and bug-free.</p>\n<p>This will also improve our understanding of degradation mechanisms by generating random simulations and will be beneficial for the publicity and the overall visibility of PyBaMM.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5684737045168128/",
          "proposal_id": null,
          "short_description": "This project aims to build an automated Twitter bot, using PyBaMM's wide range of abilities, that\n\nGenerates battery degradation simulations with...",
          "slug": "automated-twitter-bot-to-run-pybamm-simulations",
          "status": "completed",
          "student_name": "Saransh Chopra",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Automated Twitter bot to run PyBaMM Simulations"
        },
        {
          "code_url": "https://povinsahu1909.github.io/blog/GSoC'21-Final-Report.html",
          "description": "<p>Scipy is the fundamental library in Python for scientific and technical computation. CuPy is currently supporting many functions provided by SciPy. But there are many functions that are still not supported in CuPy. My primary aim was to improve the sparse matrix module. Therefore, I plan to do the following during this summer.</p>\n<ul>\n<li>Implement unimplemented function of SciPy for Sparse Linear Algebra.</li>\n<li>Update dependent modules to work with new methods.</li>\n<li>Add random distribution to Generator API.</li>\n<li>Implement functions for linear algebra.</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5686473654796288/",
          "proposal_id": null,
          "short_description": "Scipy is the fundamental library in Python for scientific and technical computation. CuPy is currently supporting many functions provided by SciPy....",
          "slug": "cupy-extending-cupy-coverage-of-scipy-functions",
          "status": "completed",
          "student_name": "Praveen Sahu",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai"
          ],
          "title": "CuPy: Extending CuPy coverage of SciPy functions"
        },
        {
          "code_url": "https://github.com/equadratures/EQ-uq",
          "description": "<p>Equadratures is a powerful open-source library assisting the user to make the use of orthogonal polynomials for uncertainty quantification, machine learning, numerical integration and dimension reduction. The upcoming version of \nEquadratures adds more functionalities such as plotting functions (Sobol Indices, Zonotopes), scaling functions (min-max scaling, mean-var scaling) etc. The main aim of this project is to enhance the visualization capability of Equadratures and creating an application for uncertainty quantification for computational simulation. The application would help users with no prior coding experience in python to dive deep into statistics using Equadratures. Dash framework would be used for the creation of this application. The application would provide operations for uncertainty quantification and various plotting functions helping the user to gain insights from the model.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5692882282872832/",
          "proposal_id": null,
          "short_description": "Equadratures is a powerful open-source library assisting the user to make the use of orthogonal polynomials for uncertainty quantification, machine...",
          "slug": "equadratures-web-application-based-on-uncertainty-quantification",
          "status": "completed",
          "student_name": "Simardeep Singh Sethi",
          "student_profile": null,
          "tags": [
            "python",
            "web",
            "ai"
          ],
          "title": "Equadratures: Web Application based on Uncertainty Quantification"
        },
        {
          "code_url": "https://github.com/qutip/qutip-cupy",
          "description": "<p>QuTiP's data layer provides the mathematical operations needed to work with quantum states and operators, i.e. <code>Qobj</code>s,. As part of Google Summer of Code 2020, the data layer was rewritten to allow new backends to be added more easily. Backends using in-memory spares and dense matrices already exist, and we would like to add a backend that runs on GPU, either through Cupy or TensorFlow.  This will decrease the computation time thus making it feasible to work on larger qubit systems.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5725917996908544/",
          "proposal_id": null,
          "short_description": "QuTiP's data layer provides the mathematical operations needed to work with quantum states and operators, i.e. Qobjs,. As part of Google Summer of...",
          "slug": "gpu-backend-for-qutip",
          "status": "completed",
          "student_name": "felipe bivort haiek",
          "student_profile": null,
          "tags": [
            "backend"
          ],
          "title": "GPU backend for QuTip"
        },
        {
          "code_url": "https://gist.github.com/gegen07/576dcdfad046cc91246bdb3ea3a47ce1",
          "description": "<p>The goal of this project is to develop a facility location modeling module that supports various distance measures and returns an optimal solution to the problem. The <a href=\"https://pysal.org/spaghetti/notebooks/facility-location.html\" target=\"_blank\">example</a> provided will serve as a base for this project. This module proposed will support four models:</p>\n<ul>\n<li>Location Set Coverage Model</li>\n<li>Maximal Set Covering Model</li>\n<li>p-Median Model</li>\n<li>p-Center Model</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5746198429827072/",
          "proposal_id": null,
          "short_description": "The goal of this project is to develop a facility location modeling module that supports various distance measures and returns an optimal solution to...",
          "slug": "pysal-open-source-facility-location-modeling-spopt-development",
          "status": "completed",
          "student_name": "Germano dos Santos",
          "student_profile": null,
          "tags": [
            "ml"
          ],
          "title": "PySal: Open Source Facility Location Modeling (spopt) Development"
        },
        {
          "code_url": "https://github.com/kn27/posteriordb",
          "description": "<p>Under guidance from the mentors, the student will develop a suite of models for benchmarking Bayesian computation. That involves gathering data/models with a variety of inferential structure for coding and optimization in Stan. The resulting canonical models and posteriors will be submitted for inclusion in the posteriorDB database to serve as reference points against which new approaches to Bayesian computation can be compared.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5748407083204608/",
          "proposal_id": null,
          "short_description": "Under guidance from the mentors, the student will develop a suite of models for benchmarking Bayesian computation. That involves gathering...",
          "slug": "gsoc-stan-proposal-bayesian-computation-benchmark",
          "status": "completed",
          "student_name": "Khanh-Tung Nguyen-Ba",
          "student_profile": null,
          "tags": [
            "ai",
            "database",
            "ui"
          ],
          "title": "GSOC Stan Proposal - Bayesian Computation Benchmark"
        },
        {
          "code_url": "https://gist.github.com/czgdp1807/dd4c89d485a5cfa6ee966ca40f60a1f5",
          "description": "<p>This project aims to add support for arrays and allocatables in LFortran. Specifically, features to be added for arrays are as follows,</p>\n<ul>\n<li>Declaring Arrays</li>\n<li>Operations on Arrays</li>\n<li>Indexing Arrays</li>\n<li>Passing Arrays as Functions/Subroutines Arguments</li>\n<li>Array Initializer Expressions</li>\n<li>Slicing Arrays</li>\n<li>Intrinsic Functions for Arrays</li>\n</ul>\n<p>For supporting allocatables, the main focus would be on generating instructions to allocate memory in heap using <code>malloc</code>. There are some miscellaneous goals as well, such as improving support for pointers and kinds and some bug fixes discovered along the way.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5420723492880384/",
          "proposal_id": null,
          "short_description": "This project aims to add support for arrays and allocatables in LFortran. Specifically, features to be added for arrays are as follows,\n\nDeclaring...",
          "slug": "supporting-arrays-and-allocatables-in-lfortran",
          "status": "completed",
          "student_name": "Gagandeep Singh",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Supporting Arrays and Allocatables in LFortran"
        },
        {
          "code_url": "https://mjhajharia.com/posts/2021/08/summing-up-summer/",
          "description": "<p>PyMC3 is a probabilistic programming language that uses Bayesian statistics to specify models and estimate unknown quantities. PyMC3 has about seven time-series distributions, an important class of models in Probabilistic Programming. This project works on extending this class in a few ways: Firstly, the addition of a new model - namely Auto-Regressive Integrated Moving Average(ARIMA). Expansion of the existing distributions(and their respective documentation), including Time-Series analysis functions. Thirdly, state-space implementation of possibly a time-varying linear and Gaussian time series model, based on Aesara. Additionally, I believe that Programming can be an efficient way of understanding applied mathematics, motivating me to focus on more pedagogical or explanatory notebooks about Probabilistic Programming (Time-Series in this case). Explanatory Notebooks for ARIMA and state-space model usage, exploring their Econometric applications will be a small step towards fostering an interdisciplinary bond between academia and the open-source community, mutually benefiting both.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5431531543199744/",
          "proposal_id": null,
          "short_description": "PyMC3 is a probabilistic programming language that uses Bayesian statistics to specify models and estimate unknown quantities. PyMC3 has about seven...",
          "slug": "extending-time-series-models",
          "status": "completed",
          "student_name": "Meenal Jhajharia",
          "student_profile": null,
          "tags": [],
          "title": "Extending Time-Series Models"
        },
        {
          "code_url": "https://github.com/optuna/optuna-dashboard",
          "description": "<p>The fastly developing hyperparameter tuning framework Optuna has gained much attention in the machine learning community due to its high flexibility and rich features. One of the most important features in Optuna is the visualization module, which provides various APIs to help users to analyze the optimization process and possibly adjust or early stop the process correspondingly. However, currently, these APIs are called by the user manually and thus makes the monitoring process hard. In this project, we aim to develop a web dashboard for Optuna (Optuna-dashboard) to monitor various optimization processes, which will greatly simplify the monitoring process by automatically visualizing the optimization “study” in optuna in real-time.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5466534989791232/",
          "proposal_id": null,
          "short_description": "The fastly developing hyperparameter tuning framework Optuna has gained much attention in the machine learning community due to its high flexibility...",
          "slug": "a-full-featured-web-dashboard-for-optuna-to-monitor-optimization-history",
          "status": "completed",
          "student_name": "Huzi Cheng",
          "student_profile": null,
          "tags": [
            "web",
            "api",
            "ai"
          ],
          "title": "A Full-featured Web Dashboard  for Optuna to Monitor Optimization History"
        },
        {
          "code_url": "https://freyam.medium.com/report-my-contributions-to-dask-9330cc698674",
          "description": "<p>Dask's primary job is building task graphs and optimizing them before decorating the functions to operate lazily. Task graphs are a visual representation of the order and dependencies of each task within a dask computation. They are a handy diagnostic tool. However, task graphs can currently be daunting when dealing with complex computations and do not provide a clear picture of job feasibility. There is room for improvement here.</p>\n<p>I redesigned the task graph visualizations by introducing <strong>colors</strong> and enhancing the illustration of information. I worked on making them more illustrative, engaging, and informative. The <a href=\"https://docs.dask.org/en/latest/graphviz.html\" target=\"_blank\">Graphviz</a> library boasts a great set of attributes that can be modified to create a more visually appealing output. My work also involved pushing more metadata to the user-end of the task graphs in a creative way.</p>\n<p>These new features would enable users to learn more about their program's performance characteristics and find room for optimizations easily.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2021_018",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/4961535251709952/",
          "proposal_id": null,
          "short_description": "Dask's primary job is building task graphs and optimizing them before decorating the functions to operate lazily. Task graphs are a visual...",
          "slug": "visualizing-the-performance-characteristics-of-computations-dask",
          "status": "completed",
          "student_name": "Freyam Mehta",
          "student_profile": null,
          "tags": [
            "ml",
            "ui"
          ],
          "title": "Visualizing the Performance Characteristics of Computations (Dask)"
        },
        {
          "code_url": "https://iliailmer.github.io/2021/08/google-summer-of-code-final-results.html#google-summer-of-code-final-results",
          "description": "<p>The problem of identifiability is ubiquitous among experimental scientific research. The core idea is in one's ability to recover parameter values from the inputs and outputs (measurements). If such recovery is theoretically possible then the model is called structurally identifiable. This problem is commonly solved via symbolic computation. In this project, the aim is to augment the existing ModelingToolkit.jl package with algorithms that solve the problem of structural local and global identifiability analyses.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_019",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5003664049045504/",
          "proposal_id": null,
          "short_description": "The problem of identifiability is ubiquitous among experimental scientific research. The core idea is in one's ability to recover parameter values...",
          "slug": "parameter-identifiability-with-modelingtoolkitjl",
          "status": "completed",
          "student_name": "Ilia Ilmer",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Parameter Identifiability with ModelingToolkit.jl"
        },
        {
          "code_url": "https://docs.google.com/document/d/1EX-K2GsZBKgaj7AyirPnHpaMMTJR3RsdHuRLC1YVkII/edit?usp=sharing",
          "description": "<p>AiiDA currently has a REST API, built on the flask framework, to provide access to the provenance graphs in the database. The REST API is limited to queries to AiiDA databases. It does not provide any support for workflow management.</p>\n<p>This problem can currently be circumvented using python dashboarding tools like plotly.dash or by developing a specialized API for it like aiida-post. While these alternatives have their own advantages, they come at the cost of either mixing data, visualization and controlling logic or investing time to implement a custom API and client.\nThe objective of this project is to extend the AiiDA REST API by:</p>\n<ul>\n<li>Adding POST methods to users, computer, nodes and groups endpoints. This will allow the addition of new AiiDA entities to the database.</li>\n<li>Implementing a new /processes endpoint supporting GET, PUT and DELETE for workflow management</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_020",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5065342262444032/",
          "proposal_id": null,
          "short_description": "AiiDA currently has a REST API, built on the flask framework, to provide access to the provenance graphs in the database. The REST API is limited to...",
          "slug": "extending-the-aiida-rest-api-towards-workflow-management",
          "status": "completed",
          "student_name": "Ninad Bhat",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai",
            "database",
            "ui"
          ],
          "title": "Extending the AiiDA REST API towards workflow management"
        },
        {
          "code_url": "https://matplotlib.org/matplotblog/posts/gsoc_2021_final/",
          "description": "<p>Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations, which has become a de-facto Python plotting library. It allows user text to be rendered on the canvas, includes extensive support for mathematical expressions, raster and vector outputs, arbitrary rotations, and supports Unicode. Much of the inspiration behind its font manager is inspired from W3C compliant algorithms, allowing users to interact with font properties like font-size, font-weight, font-family, etc.</p>\n<p>However, the current way Matplotlib handles fonts and general text layout is not ideal, which is what this proposal aims to tackle.</p>\n<p>It is divided into three subgoals, such that by the end of the project completion, TeX exporting mechanisms would use the same structural layout for most backends, and every exported PS/PDF would contain embedded glyphs which are subsetted from the whole font. This would be done with an implementation of a redesigned text-first font interface, essentially enabling a font-fallback mechanism, such that all font-family members will be parsed before rendering a “tofu”.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_021",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5084422319112192/",
          "proposal_id": null,
          "short_description": "Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations, which has become a de-facto Python plotting...",
          "slug": "matplotlib-revisiting-textfont-handling",
          "status": "completed",
          "student_name": "Aitik Gupta",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "backend"
          ],
          "title": "Matplotlib: Revisiting Text/Font Handling"
        },
        {
          "code_url": "https://purva-thakre.github.io/purva-blog/gsoc/qutip/final-gsoc/",
          "description": "<p>A known quantum gate can be decomposed into an already declared sequence of universal quantum gates in QuTip.  If the desired decomposition is different from this predefined sequence then the functions proposed for this project could be used as an instance of <em>n_qubit_decomposition class</em>.  Any arbitrary quantum gate can be decomposed into a product of universal gates via different methods.  The proposed methods differ due to the type of gates chosen to form the universal gate set.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_022",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5100142167851008/",
          "proposal_id": null,
          "short_description": "A known quantum gate can be decomposed into an already declared sequence of universal quantum gates in QuTip.  If the desired decomposition is...",
          "slug": "quantum-gate-decomposition-for-qutip",
          "status": "completed",
          "student_name": "Purva Thakre",
          "student_profile": null,
          "tags": [],
          "title": "Quantum Gate Decomposition for QuTip"
        },
        {
          "code_url": "https://hesamshaelaie.github.io/gsoc/2021/08/21/week11.html",
          "description": "<p>This GSOC will add support for the solution of a much wider class of bilevel optimization problems to JuMP. Currently, support for bilevel optimization is through BilevelJuMP.jl, which is primarily capable of solving problems for which there is a compact, strong dual for the lower-level problem. The aim of this project is to allow the integer variables and possibly even stochasticity to be included at both upper and lower levels. For this purpose, we propose two approaches. \n1- Integrate the well-developed open-source solver into BilevelJuMP.jl.\n2- As a stretch goal, extend Dualization.jl to include concepts from the duality of integer programming.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_023",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5104063204556800/",
          "proposal_id": null,
          "short_description": "This GSOC will add support for the solution of a much wider class of bilevel optimization problems to JuMP. Currently, support for bilevel...",
          "slug": "expanding-support-for-the-solution-of-bilevel-optimization-problems-in-jump",
          "status": "completed",
          "student_name": "Mohammad Hesam Shaelaie",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Expanding support for the solution of bilevel optimization problems in JuMP."
        },
        {
          "code_url": "https://ricardov94.github.io/topics/gsoc-2021/completed_work/",
          "description": "<p>PyMC3 provides state-of-the-art tools to specify rich mathematical probabilistic models and algorithms to efficiently approximate the posterior distribution of such models conditioned on observed data. One such algorithm is the Sequential Monte Carlo (SMC) sampler which is capable of drawing samples from complex posterior distributions (e.g., multimodal distributions).</p>\n<p>In addition to traditional Bayesian inference, SMC can also be used to perform Approximate Bayesian Computation (ABC), which allows one to define models without a pure mathematical likelihood term, which is difficult to derive in many complex real world problems. To achieve this, SMC-ABC makes use of a “Simulator” function that is capable of returning simulated observed data given different unobserved parameters.</p>\n<p>This project seeks to extend the documentation, performance and flexibility of SMC and SMC-ABC sampling in PyMC3, to make it competitive with specialized libraries while remaining accessible to the large user-base of the PyMC3 library.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2021_024",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5257315321643008/",
          "proposal_id": null,
          "short_description": "PyMC3 provides state-of-the-art tools to specify rich mathematical probabilistic models and algorithms to efficiently approximate the posterior...",
          "slug": "pymc3-make-smc-abc-faster-and-more-flexible",
          "status": "completed",
          "student_name": "ricardoV94",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "[PyMC3] Make SMC-ABC faster and more flexible"
        },
        {
          "code_url": "https://gist.github.com/SGeetansh/79341cad9c337117fcdb796a82e18507",
          "description": "<p>Colour is an open-source python package providing a comprehensive number of algorithms and datasets for colour-science. It also has support for different colour models, allowing easy conversion from one colourspace to another. A colour model is a way to define colour. It describes how a colour will appear on a computer screen or paper. I plan to work on improving this feature by implementing new colour models that are required and at the same time improving the existing ones.</p>\n",
          "difficulty": "beginner",
          "id": "proj_numfocus_2021_025",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5281448977760256/",
          "proposal_id": null,
          "short_description": "Colour is an open-source python package providing a comprehensive number of algorithms and datasets for colour-science. It also has support for...",
          "slug": "colour-adding-new-colour-models",
          "status": "completed",
          "student_name": "Geetansh Saxena",
          "student_profile": null,
          "tags": [
            "python",
            "ui"
          ],
          "title": "COLOUR: Adding new colour models"
        },
        {
          "code_url": "https://priyanshuone6.hashnode.dev/project-report-gsoc",
          "description": "<p>PyBaMM offers a way to compare new models by implementing models as expression trees that can be specified independently of the user's preference. This allows the model to be defined independently of the user's choice of parameters, spatial discretization, numerical methods and so on, which are plugged in during model processing. This project aims to use LaTeX to render the expression tree into a human-readable format using SymPy and also generate a file of the model equations to visualize the equations easily.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_026",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5566614002466816/",
          "proposal_id": null,
          "short_description": "PyBaMM offers a way to compare new models by implementing models as expression trees that can be specified independently of the user's preference....",
          "slug": "pybamm-printing-formatted-equations",
          "status": "completed",
          "student_name": "Priyanshu_Agarwal",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "PyBaMM - Printing Formatted Equations"
        },
        {
          "code_url": "https://github.com/gridap/GridapMakie.jl/pull/24",
          "description": "<p>This project aims to integrate the Makie plotting ecosystem for the Julia programming language within the library Gridap, used to approximate partial differential equations, thus creating GridapMakie. The implementation will entail an improvement in workflow, not relying on external software for grid or data visualization. Moreover, the interactive features of  Makie make it the suitable choice to observe any changes of parameters in real-time. Such integration will be performed employing Plot Recipes, a macro defined to customize plotting commands. Therefore, the goal of the project is to develop, document, and release the GridapMakie package under the Julia official registry verification.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_027",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5637150787239936/",
          "proposal_id": null,
          "short_description": "This project aims to integrate the Makie plotting ecosystem for the Julia programming language within the library Gridap, used to approximate partial...",
          "slug": "gridap-visualizing-pde-approximations-in-julia-with-gridapjl-and-makiejl",
          "status": "completed",
          "student_name": "Pau Riera i Portillo",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "[Gridap] Visualizing PDE approximations in Julia with Gridap.jl and Makie.jl"
        },
        {
          "code_url": "https://vdshk.github.io/posts/2021/08/gsoc-2021-final/",
          "description": "<p>NetworkX has <a href=\"https://networkx.org/documentation/latest/reference/algorithms/index.html#algorithms\" target=\"_blank\">a wide variety of algorithms</a> implemented. Although the algorithms are well documented, explanations of the ideas behind the algorithms are often lacking.</p>\n<p>The goal of this project is to create Jupyter notebooks that will become detailed and intuitive tutorials containing the ideas behind algorithms, explanations of the algorithms, and experimental analysis of these algorithms.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_028",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6226328663097344/",
          "proposal_id": null,
          "short_description": "NetworkX has a wide variety of algorithms implemented. Although the algorithms are well documented, explanations of the ideas behind the algorithms...",
          "slug": "networkx-pedagogical-interactive-notebooks-for-algorithms-implemented-in-networkx",
          "status": "completed",
          "student_name": "Vadim Abzalov",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "[NetworkX] Pedagogical Interactive Notebooks for Algorithms Implemented in NetworkX"
        },
        {
          "code_url": "https://agalicia.netlify.app/post/gsoc_6/",
          "description": "<p>Qutip is a python package that presents a comprehensive toolbox to simulate the dynamics of open\nquantum systems. Its core class is <code>Qobj</code> and it is used to represent a variety of Quantum objects such as kets or Hamiltonians, which has been improved in the last Google Summer of Code to extend its flexibility. It can now handle multiple representations of its data efficiently, for instance dense or sparse matrices. Here we propose to extend the implementation of this class allowing it to handle TensorFlow’s data type which will allow to store and manipulate the data of Qobj using a Graphical Processing Unit (GPU). In this way, QuTiP will be able to take advantage of the computing capabilities that the GPU offers.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_029",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6259142213238784/",
          "proposal_id": null,
          "short_description": "Qutip is a python package that presents a comprehensive toolbox to simulate the dynamics of open\nquantum systems. Its core class is Qobj and it is...",
          "slug": "tensorflow-data-backend-for-qutip",
          "status": "completed",
          "student_name": "Asier Galicia",
          "student_profile": null,
          "tags": [
            "python",
            "backend"
          ],
          "title": "TensorFlow data backend for QuTiP"
        },
        {
          "code_url": "https://github.com/pvlib/pvlib-python/issues/1289",
          "description": "<p>Solar resource data is fundamental to designing and assessing solar energy systems, however, accessing such data is often a complex and time-consuming process, as each data provider has different file formats, methods of access, and naming conventions. The aim of this project is to extend pvlib python’s current iotools functionalities to include harmonized functions for allowing seamless access to all major open-source solar resource databases. This will strengthen the pvlib python library by making it a one-stop source for all types of open-source solar resource data and will be a huge benefit to solar energy researchers and scientists.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2021_030",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/4721538720333824/",
          "proposal_id": null,
          "short_description": "Solar resource data is fundamental to designing and assessing solar energy systems, however, accessing such data is often a complex and...",
          "slug": "making-pvlib-python-a-one-stop-source-for-solar-resource-data",
          "status": "completed",
          "student_name": "Adam R. Jensen",
          "student_profile": null,
          "tags": [
            "python",
            "ml",
            "ai",
            "database"
          ],
          "title": "Making pvlib python a one-stop source for solar resource data"
        },
        {
          "code_url": "https://z3y50n.github.io/gsoc/journal/2021/08/19/A-Journey-Full-Of-Graphs.html",
          "description": "<p>NetworkX is a Python library used for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.</p>\n<p>One very interesting field of networks is community detection, that is to group different nodes together based on similar characteristics or the number of edges between inner and outer nodes. Networkx has already implemented a few algorithms that perform community detection, but currently there is no implementation for the Louvain Community Detection algorithm which is a very efficient greedy algorithm for community detection.</p>\n<p>The goal of the project is to implement Louvain Algorithm into NetworkX by the end of summer.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2021_031",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6106949510234112/",
          "proposal_id": null,
          "short_description": "NetworkX is a Python library used for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.\nOne very...",
          "slug": "networkx-louvain-community-detection-algorithm",
          "status": "completed",
          "student_name": "Dimitris Papageorgiou",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "NetworkX - Louvain Community Detection Algorithm"
        },
        {
          "code_url": "https://mjschwenne.github.io/2021/08/16/my-summer-of-code-2021.html",
          "description": "<p>This project seems to implement the asymmetric traveling salesman problem developed by Asadpour et al, originally published in 2010 and revised in 2017. The project is broken into multiple methods, each of which has a set timetable during the project. We start by solving the Held-Karp relaxation using the Ascent method from the original paper by Held and Karp. Assuming the result is fractional, we continue into the Asadpour algorithm (integral solutions are optimal by definition and immediately returned). We approximate the distribution of spanning trees on the undirected support of the Held Karp solution using a maximum entropy rounding method to construct a distribution of trees. Roughly speaking, the probability of sampling any given tree is proportional to the product of all its edge lambda values. We sample 2 log <em>n</em> trees from the distribution using an iterative approach developed by V. G. Kulkarni and choose the tree with the smallest cost after returning direction to the arcs. Finally, the minimum tree is augmented using a minimum network flow algorithm and shortcut down to an <em>O(log n / log log n)</em> approximation of the minimum Hamiltonian cycle.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_032",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/4847324890660864/",
          "proposal_id": null,
          "short_description": "This project seems to implement the asymmetric traveling salesman problem developed by Asadpour et al, originally published in 2010 and revised in...",
          "slug": "networkx-implementing-the-asadpour-asymmetric-traveling-salesman-problem-algorithm",
          "status": "completed",
          "student_name": "Matt Schwennesen",
          "student_profile": null,
          "tags": [],
          "title": "NetworkX: Implementing the Asadpour Asymmetric Traveling Salesman Problem Algorithm"
        },
        {
          "code_url": "https://gist.github.com/KickItLikeShika/4f1279b6e9d9db259a09494cf10f22cc",
          "description": "<p>In this project we are trying to provide a High-level API for the Deep Learning engineers and researchers to help them train their models faster, and provide them many other various features:</p>\n<ul>\n<li>Users can train/evaluate/test models with this API.</li>\n<li>Users can train multiple models/optimizers on multiple datasets.</li>\n<li>We provide a lot of features like (integration of experiment tracking systems, auto-batching, auto-checkpointing, automatic-mixed-precision, train GANs, Semi-supervised learning, DDP, etc....)</li>\n<li>We provide examples for using each and every feature in this API.</li>\n<li>We provide good documentation.</li>\n</ul>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_033",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/4898613980823552/",
          "proposal_id": null,
          "short_description": "In this project we are trying to provide a High-level API for the Deep Learning engineers and researchers to help them train their models faster, and...",
          "slug": "pytorch-ignite-development-of-a-higher-level-api",
          "status": "completed",
          "student_name": "Ahmed-1",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "PyTorch-Ignite: Development of a Higher-level API"
        },
        {
          "code_url": "https://tcapretto.netlify.app/post/2021-08-17-gsoc-2021-final-evaluation/",
          "description": "<p>This project aims to work on two related problems. On one hand, I would like to implement new family of generalized linear models, such as beta regression, robust linear regression (i.e. linear model with error following a T-Student distribution) as well as multinomial regression. On the other hand, it is also necessary to incorporate more automatic prior distribution alternatives that do not make use of the GLM module in statsmodels so new models can work smoothly without requiring the user to manually specify priors.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_034",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/4945908952727552/",
          "proposal_id": null,
          "short_description": "This project aims to work on two related problems. On one hand, I would like to implement new family of generalized linear models, such as beta...",
          "slug": "extend-available-models-and-default-priors-in-bambi",
          "status": "completed",
          "student_name": "Tomas Capretto",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Extend available models and default priors in Bambi"
        },
        {
          "code_url": "https://gist.github.com/Aakash3101/cdc1cc775a672b96a46d3ef8ea366df9",
          "description": "<p>The Data Retriever is a package manager for publicly accessible data. The Data retriever automatically finds, downloads, and pre-processes publicly available datasets and it stores these datasets in a ready-to-analyze state. A number of data providers require the use of an account with an associated Login or API key to access data programmatically. The Data Retriever currently has support for the Kaggle API allowing users to securely use the Data Retriever to install datasets hosted by Kaggle. The goal of this project is to find sources of public Data which require a Login/API key to access the data and integrate them into Data Retriever. Two APIs (Socrata and CKAN) have been thoroughly researched and can be added. The users will place the appropriate credentials in a file in their home directory. The Data Retriever will automatically identify the required credential files and handle the login/API request to download the dataset.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_035",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5761819360100352/",
          "proposal_id": null,
          "short_description": "The Data Retriever is a package manager for publicly accessible data. The Data retriever automatically finds, downloads, and pre-processes publicly...",
          "slug": "data-retriever-support-for-loginapi",
          "status": "completed",
          "student_name": "Aakash Chaudhary",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "ui"
          ],
          "title": "[Data Retriever]: Support for Login/API"
        },
        {
          "code_url": "https://rishabh-lfs.medium.com/gsoc21-new-plots-final-report-6fce16da399d",
          "description": "<p>ArviZ is a python package for exploratory analysis of Bayesian models. It is designed as a backend agnostic tool and supports different backends for visualisation and diagnostics. Apart from plotting ArviZ also supports functions for posterior analysis, model checking, comparison and diagnostics.</p>\n<p>As ArviZ is mainly a visualisation library, it already has various plotting functions to analyse Bayesian Inference data. Still, it would be nice to extend its visualisation capabilities and add some more plotting functions which the community could use.</p>\n<p>This project aims to implement dot plots,  quantile dot plots, half-eye plots, ecdf plots, and, if time permits, then also calibration plots for classification into ArviZ for both the backends Matplotlib and Bokeh and also to write tests for all these plot functions.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_036",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5768209902338048/",
          "proposal_id": null,
          "short_description": "ArviZ is a python package for exploratory analysis of Bayesian models. It is designed as a backend agnostic tool and supports different backends for...",
          "slug": "adding-new-plots-to-arviz",
          "status": "completed",
          "student_name": "Rishabh Sanjay",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "backend"
          ],
          "title": "Adding New Plots to ArviZ"
        },
        {
          "code_url": "https://tastatham.org/blog/wrapping_it_up/",
          "description": "<p>Geopandas is one of the most popular Python projects for handling geographic problems and data. Whilst Geopandas is useful for handling small data problems, it does not scale well because its geometric computation is single-threaded. Therefore, advanced geospatial analysis is still dependent on the use of relational databases and spatial extensions such as postgreSQL/PostGIS. This project will extend Geopandas capabilities to handle big problems by using Dask to bridge this gap, allowing geometric computations to leverage all available CPU cores. This will be achieved by contributing to the dask-geopandas library, to enable distributing spatial indexing, related spatial partitioning and parallised IO. Additionally, we plan to integrate other spatial operations from Geopandas and basic plotting features.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2021_037",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5818727945207808/",
          "proposal_id": null,
          "short_description": "Geopandas is one of the most popular Python projects for handling geographic problems and data. Whilst Geopandas is useful for handling small data...",
          "slug": "geopandas-dask-bridge-to-scale-geospatial-analysis",
          "status": "completed",
          "student_name": "tastatham",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "database"
          ],
          "title": "Geopandas - Dask bridge to scale geospatial analysis"
        },
        {
          "code_url": "https://larrydong.com/gsoc2021/gsoc-final/",
          "description": "<p>Bayesian nonparametric (BNP) methods offer more modelling flexibility by relaxing parametric assumptions at the cost of more daunting theoretical underpinnings and challenging implementation. PyMC3 is a Python probabilistic programming library for fitting Bayesian statistical models using Aesara - formerly Theano - as a computational backend for Markov Chain Monte Carlo (MCMC) sampling and variational inference. While PyMC3 provides built-in tools for plotting, model checking and a wide selection of statistical distributions, it currently lacks support for Dirichlet Processes (DP), a BNP method first that is garnening much attention from the research community in the last two decades. My Google Summer of Code (GSoC) proposal centers around bridging this gap in the PyMC3 framework by building a submodule for DPs and DP-related methods and contributing notebooks that build upon them.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_038",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5823250512216064/",
          "proposal_id": null,
          "short_description": "Bayesian nonparametric (BNP) methods offer more modelling flexibility by relaxing parametric assumptions at the cost of more daunting theoretical...",
          "slug": "pymc3dp-bayesian-stati-sticks-for-summer-2021",
          "status": "completed",
          "student_name": "Larry Dong",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui",
            "backend"
          ],
          "title": "pymc3.dp: Bayesian Stati-sticks for Summer 2021"
        },
        {
          "code_url": "https://harshal-dupare.medium.com/gsoc-2021-work-product-submission-c53aafaa970",
          "description": "<p>There are many algorithms implemented in NetworkX some of them being simple and some of them being very complex. Understanding the algorithm that we are using in our projects is very important. One way to understand the algorithm and its implementation is to read its documentation or if one is really interested then read the code. But it's not always possible because of different reasons, maybe the code is too large or it is very abstract and to understand one line of code we have to understand some other function.</p>\n<p>The idea of using notebooks for explaining the algorithms which is being carried out in <a href=\"https://github.com/networkx/notebooks\" target=\"_blank\">networkx-notebooks</a> will help the community to understand the algorithms more intuitively and easily. But still, there is a long way to go as very few such notebooks have been added so far and there is a large set of algorithms’ awaiting to be added to the collection.</p>\n",
          "difficulty": "advanced",
          "id": "proj_numfocus_2021_039",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5894041102712832/",
          "proposal_id": null,
          "short_description": "There are many algorithms implemented in NetworkX some of them being simple and some of them being very complex. Understanding the algorithm that we...",
          "slug": "adding-interactive-notebooks-for-algorithms-implemented-in-networkx",
          "status": "completed",
          "student_name": "Harshal Dupare",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Adding Interactive Notebooks for Algorithms Implemented in NetworkX"
        },
        {
          "code_url": "https://vilin97.github.io/posts/post5/",
          "description": "<p>Jump processes are a fundamental component in stochastic models throughout engineering, medicine and the sciences. DiffEqJump is a part of SciML, which contains infrastructure to stochastically simulate jump networks. While simulation algorithms for spatially non-homogeneous systems exist in academic literature, they are not currently supported in DiffEqJump. The goal of this project is to expand DiffEqJump with new, optimized spatial solvers and a consistent interface, enabling the study of large spatial systems of jump processes and the use of jump processes within other SciML tooling.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_040",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6316980088340480/",
          "proposal_id": null,
          "short_description": "Jump processes are a fundamental component in stochastic models throughout engineering, medicine and the sciences. DiffEqJump is a part of SciML,...",
          "slug": "efficient-spatial-simulations-in-diffeqjump",
          "status": "completed",
          "student_name": "Vasily Ilin",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Efficient Spatial Simulations in DiffEqJump"
        },
        {
          "code_url": "https://github.com/gucifer/GSoC-ignite",
          "description": "<p>PyTorch-Ignite is a great library built on top of pytorch. It provides an extremely simple engine and event system to work with, which work really well in a distributed environment. It also has a set of very handy metrics which can be used right out of the box. This is why I would like to become a contributor for the PyTorch-Ignite library. I wish to work on the metrics module because I have worked in Brain-Computer Interface, Computer Vision, Augmented Reality and am familiar with a myriad of different metrics. I am also familiar with using pytorch library and have built, trained and tested many models with it, making me a suitable candidate to work on the metrics module of PyTorch-Ignite. Contributing to PyTorch-Ignite can help me learn more about using pytorch in a distributed environment, writing test cases for your code, get used to the GitHub workflow in general.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_041",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/6321132382191616/",
          "proposal_id": null,
          "short_description": "PyTorch-Ignite is a great library built on top of pytorch. It provides an extremely simple engine and event system to work with, which work really...",
          "slug": "improve-metric-module",
          "status": "completed",
          "student_name": "Arpan Parikh",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Improve Metric Module"
        },
        {
          "code_url": "https://kushkothari2001.medium.com/gsoc-final-report-6fcade313d9f",
          "description": "<p>A major requirement for the current status of the dashboard is the implementation of a download and install pipeline for tables having spatial data in the form of vector images/data. According to the retriever docs, currently the retriever library uses the PostGIS extension for the same. Therefore, the install process to be used for the dashboard will make use of the postgres engine. The spatial datasets are already tested for only download and changes are detected using the md5 hash. This proposal will further that, into proper install of these datasets into Postgres and find out diffs in the databases using PostGIS joins. The results obtained will then be converted into HTML diffs just like we do for non-spatial databases.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_042",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5156556898828288/",
          "proposal_id": null,
          "short_description": "A major requirement for the current status of the dashboard is the implementation of a download and install pipeline for tables having spatial data...",
          "slug": "data-retriever-adding-spatial-dataset-support-kush-kothari",
          "status": "completed",
          "student_name": "Kush Kothari",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "database",
            "ui"
          ],
          "title": "[Data Retriever] Adding Spatial Dataset Support - Kush Kothari"
        },
        {
          "code_url": "https://github.com/neelsura12/gsoc",
          "description": "<p>Real-world data generating processes often don't produce normally-distributed data, in particular the skewness/kurtosis/tail index parameters are inconsistent with a Gaussian random variable. If we can \"Gaussianize\" data from such processes in a meaningful way, then we can make better inferences.  We can solve this problem generally by applying a Lambert W transform (Goerg, 2014), which assumes the observed data is distributed as Lambert W x F_X, where F_X is the distribution of the latent input (Goerg , 2011). To apply this transform, we need to estimate parameters of the Lambert W x F_X distribution and also support the inverse transform, so that we can make inferences about the latent input. With this project, we want to support Lambert W x F_X distribution in Stan in an inferential setting, which means: users can build Gaussian models over non-normal data in a transparent way.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_043",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5157746269224960/",
          "proposal_id": null,
          "short_description": "Real-world data generating processes often don't produce normally-distributed data, in particular the skewness/kurtosis/tail index parameters are...",
          "slug": "lambert-w-distributions-in-stan",
          "status": "completed",
          "student_name": "Neel",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Lambert W Distributions in Stan"
        },
        {
          "code_url": "https://balaje.github.io/2021/08/20/Wrapping-up.html",
          "description": "<p>The project aims to implement a fast finite element interpolation algorithm in Gridap.jl for any two functions belonging to finite element spaces defined on different domains. The method is based on the interpolation algorithm implemented in <a href=\"https://doc.freefem.org/documentation/finite-element.html#a-fast-finite-element-interpolator\" target=\"_blank\">FreeFem</a>. Support for computing the interpolation <a href=\"https://doc.freefem.org/documentation/finite-element.html#interpolation-matrix\" target=\"_blank\">matrix</a> associated with the linear interpolation operator will also be implemented.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_044",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5162121666494464/",
          "proposal_id": null,
          "short_description": "The project aims to implement a fast finite element interpolation algorithm in Gridap.jl for any two functions belonging to finite element spaces...",
          "slug": "a-fast-finite-element-interpolator-in-gridapjl",
          "status": "completed",
          "student_name": "Balaje",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "A fast finite element interpolator in Gridap.jl"
        },
        {
          "code_url": "https://frankschae.github.io/post/gsoc-2021/",
          "description": "<p>DiffEqSensitivity.jl is a Julia package within the SciML ecosystem for computing (adjoint) sensitivities for various kinds of differential equations in a highly performant manner within a unified user interface. \nIn this project, we aim at implementing continuous adjoint sensitivity methods for hybrid differential equations as well as shadowing methods for chaotic dynamical systems in the DiffEqSensitivity.jl package.  Moreover, we will add a symbolic preprocessing option based on the ModelingToolkit.jl package to build highly optimized adjoint differential equation code in DiffEqSensitivity.jl. Finally, we plan to refactor DiffEqSensitivity.jl to make use of a new package, namely AbstractDifferentiation.jl, such that users may straightforwardly select the best performing automatic-differentiation backend in each part of their program without the need to adapt their code substantially.</p>\n<p>Possible fields of application for these tools range from model discovery with explicit dosing times in pharmacology, over accurate gradient estimates for chaotic fluid dynamics, to the control of open quantum systems.</p>\n",
          "difficulty": null,
          "id": "proj_numfocus_2021_045",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2021/projects/5199651359162368/",
          "proposal_id": null,
          "short_description": "DiffEqSensitivity.jl is a Julia package within the SciML ecosystem for computing (adjoint) sensitivities for various kinds of differential equations...",
          "slug": "neural-hybrid-differential-equations-and-adjoint-sensitivity-analysis",
          "status": "completed",
          "student_name": "Frank Schäfer",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui",
            "backend"
          ],
          "title": "Neural Hybrid Differential Equations and Adjoint Sensitivity Analysis"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2021/organizations/6176584620310528/"
    },
    "year_2022": {
      "num_projects": 37,
      "projects": [
        {
          "code_url": "https://github.com/zarr-developers/codecs-registry",
          "description": "Each compression algorithm used by Zarr is assigned an identifier by the Numcodecs library. To make these identifiers useful in other programming languages, Zarr requires a registry to be defined that is machine-readable in multiple programming languages. This registry will serve as a critical bridge between several communities for different programming languages like Python, C, Java as well as multiple file formats like Zarr, NetCDF, HDF5, etc.  My proposal is to build a registry for codecs with their identifiers to fill this gap between different communities and I planned to complete this project in 5 stages with community review at every stage. Plus an updation guide, in order to help others to update the registry in future whenever a new codec is included.",
          "difficulty": null,
          "id": "proj_numfocus_2022_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/g4IPN5HL/",
          "proposal_id": null,
          "short_description": "Each compression algorithm used by Zarr is assigned an identifier by the Numcodecs library. To make these identifiers useful in other programming...",
          "slug": "registry-for-zarr-codecs",
          "status": "completed",
          "student_name": "Shivank Chaudhary",
          "student_profile": null,
          "tags": [
            "python",
            "java",
            "ui"
          ],
          "title": "Registry for Zarr codecs"
        },
        {
          "code_url": "https://gist.github.com/Nageshbansal/9f2856fa9e4ca0170e2f1a9000076541",
          "description": "The National Ecological Observatory Network (NEON) collects and provides long-term, open-access ecological data. The NEON Data API provides access to this data. The NeonVegWrangleR helps retrieve Neon Vegetation Structure data (VST) and Airborne Observation Platform ( AOP ) data samples from The NEON Data API, cleaning it, integrating both data, and providing researchers with a format ready for ecological analyses. But currently, NeonVegWrangleR primarily supports the R language. \nThis project aims to provide support for python by refactoring the R functions to python and improving the package by adding tests, setting up CI/CD platform, and documentation. Hence, NeonVegWrangler meets Python packaging release standards.",
          "difficulty": null,
          "id": "proj_numfocus_2022_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/lR1cWrnn/",
          "proposal_id": null,
          "short_description": "The National Ecological Observatory Network (NEON) collects and provides long-term, open-access ecological data. The NEON Data API provides access to...",
          "slug": "data-retriever-data-retrieval-using-neonvegwrangler",
          "status": "completed",
          "student_name": "Nagesh Bansal",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai"
          ],
          "title": "Data Retriever: Data retrieval using NeonVegWrangler"
        },
        {
          "code_url": "https://medium.com/@claretgrace0801/concluding-my-gsoc-22-project-c975d6612e5e",
          "description": "qutip-qip currently does not perform optimisation and scheduling at gate-level in quantum circuits. Allowing circuits to be imported from qiskit will allow qutip to take advantage of qiskit’s gate-level optimisation techniques. It will also provide a standard qiskit interface that enables us to use qutip-qip’s pulse-level circuit simulation.\n\nThe outcome of the project will be custom qutip-qip backends based on qutip-qip's existing simulators and a module that allows qiskit to use these backends.",
          "difficulty": null,
          "id": "proj_numfocus_2022_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/jFfaK3Su/",
          "proposal_id": null,
          "short_description": "qutip-qip currently does not perform optimisation and scheduling at gate-level in quantum circuits. Allowing circuits to be imported from qiskit will...",
          "slug": "qutip-qip-as-a-qiskit-backend",
          "status": "completed",
          "student_name": "Shreyas Pradhan",
          "student_profile": null,
          "tags": [
            "ui",
            "backend"
          ],
          "title": "qutip-qip as a Qiskit Backend"
        },
        {
          "code_url": "https://github.com/yannmclatchie/kulprit/",
          "description": "Projection predictive inference is a decision theoretic Bayesian approach that decouples model estimation from decision making. Given a reference model previously built including all variables present in the data, projection predictive inference projects its posterior onto a constrained space of a subset of variables. Variable selection is then performed by sequentially adding relevant variables until predictive performance is satisfactory.\n\nI propose to develop a Bambi-compliant module performing projection predictive model selection for GLMs.",
          "difficulty": null,
          "id": "proj_numfocus_2022_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/Y6kuHa8J/",
          "proposal_id": null,
          "short_description": "Projection predictive inference is a decision theoretic Bayesian approach that decouples model estimation from decision making. Given a reference...",
          "slug": "implement-projection-predictive-variable-selection-for-bambi-fitted-glms",
          "status": "completed",
          "student_name": "yann",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Implement projection predictive variable selection for Bambi-fitted GLMs"
        },
        {
          "code_url": "https://github.com/cvxpy/org/blob/main/GSoC2022/aryamanjeendgar/final_report.pdf",
          "description": "CVXPY is a Python-embedded modeling language for convex optimization problems. In this project, I aim to add support for new advancements in optimization methods for problems involving the ubiquitous matrix logarithm --- which in this context has especially important applications to quantum information. These new tools will dramatically expand CVXPY’s usefulness to QI theorists and quantum computer engineers.",
          "difficulty": null,
          "id": "proj_numfocus_2022_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/jAYeaR0R/",
          "proposal_id": null,
          "short_description": "CVXPY is a Python-embedded modeling language for convex optimization problems. In this project, I aim to add support for new advancements in...",
          "slug": "improve-cvxpys-capabilities-for-quantum-information-modeling",
          "status": "completed",
          "student_name": "Aryaman Jeendgar",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Improve CVXPY’s capabilities for quantum information modeling"
        },
        {
          "code_url": "https://medium.com/@abhishekbhatt730/simplechains-jl-for-neuralode-and-sciml-fadbe6fee481",
          "description": "This project aims to develop interfaces for the SimpleChains.jl library for use with SciML packages, so that the former’s non-allocating and high speed neural network layers and chains can make SciML implementations more performant through avoiding huge allocations during training and utilizing optimized kernels. Avoiding heap/runtime allocations in smaller networks (~200 nodes) is a direct way to increase the speed with which the code is executed.",
          "difficulty": null,
          "id": "proj_numfocus_2022_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/uy6F1j8l/",
          "proposal_id": null,
          "short_description": "This project aims to develop interfaces for the SimpleChains.jl library for use with SciML packages, so that the former’s non-allocating and high...",
          "slug": "optimizing-sciml-packages-with-simplechainsjl",
          "status": "completed",
          "student_name": "abhishekbhatt",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Optimizing SciML Packages With SimpleChains.jl"
        },
        {
          "code_url": "https://github.com/gsagostini/network-simplification",
          "description": "The study of urban morphology relies on clever abstractions of the built environment into computationally tractable models. One such model, the street network, is a graph whose edges are streets and nodes are street intersections. Network analysis tools are often tailored for street networks with the purpose of routing. In shortest path computations, network data must carefully reflect not only urban infrastructure but also the intricacy of transportation policies–such as multiple lanes and traffic direction. From the perspective of urban morphology, these features add noise to the geometric order of cities. Perpendicular two-lane streets cross in four intersections, producing a dummy city block, for example. Street networks carefully processed to answer pressing accessibility questions are not suitable for morphological analysis.\n\nWe would like to develop source-agnostic functions to process street network data for meaningful morphological analysis. The final network should be, at least, free from multiple nodes representing the same intersection and multiple edges representing the same street. This processing must rely on inherent network properties such as node connectivity and edge lengths, but not on auxiliary data such as OSM tags and building footprints. The functions will be collected under pysal’s momepy module, added to an existing toolbox of scalable urban morphological analysis.",
          "difficulty": null,
          "id": "proj_numfocus_2022_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/NIcNOOAQ/",
          "proposal_id": null,
          "short_description": "The study of urban morphology relies on clever abstractions of the built environment into computationally tractable models. One such model, the...",
          "slug": "pysal-morphological-street-network-simplification",
          "status": "completed",
          "student_name": "Gabriel Agostini",
          "student_profile": null,
          "tags": [
            "ai",
            "ui",
            "ux"
          ],
          "title": "[pysal] Morphological Street Network Simplification"
        },
        {
          "code_url": "https://github.com/gregmaya/gsoc2022_network_simpl",
          "description": "The project aims to fill the current gap in the creation of a baseline urban grid that allows for network analysis of the morphology of street networks. The idea of the project is to develop a set of tools within the current momepy.preprocessing module that combined with the current integration of NetworkX can output a solid, consistent and repeatable analysis of the urban form. \nGiven that other libraries have also approached this issue (namely osmnx.simplification and citiyseer.tools.graphs), the idea is to contribute from the persisting issues of such libraries to then continue with a solution that is much more independent. Issues like multiple Points on LineStrings, snapping ends, and curving segments have already been addressed by such tools, but parallel LineStrings, and enclosed Linestrings (eg. round-abouts) still need to be resolved, to name a few. It seems that a categorization of the different topological issues (likely similar to the ones just mentioned) could create a framework from which to approach a final pipeline. However, it is proposed that early tests of different potential avenues be performed to sketch a planning route going forward (one of such tests is exemplified under the Approach section). The ideal solution is expected to be source-agnostic, but also leverage the current efforts already done by the community.\nOverall, the idea is to prioritize work alongside the mentors and the community to focus on increasing the short-term benefits of all PySAL/GeoPandas users (some of whom might already be familiar with some of the other corrections). As the project progresses over different iterative approaches, it is expected to incorporate more performance tests to counterbalance the feasibility of each approach as well as to build the desired autonomy of the tools to be reliant exclusively on input geometries.",
          "difficulty": null,
          "id": "proj_numfocus_2022_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/hclVxBUX/",
          "proposal_id": null,
          "short_description": "The project aims to fill the current gap in the creation of a baseline urban grid that allows for network analysis of the morphology of street...",
          "slug": "street-network-simplification-a-combined-approach",
          "status": "completed",
          "student_name": "Greg Maya",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Street Network Simplification:  A combined approach"
        },
        {
          "code_url": "https://kunalghosh.github.io/post/gsoc_final_post/",
          "description": "Gaussian Processes (GPs) are a flexible class of probabilistic models which can automatically fit quite complex functions. In addition, GPs provide a principled means of computing the predictive uncertainty. PyMC includes an implementation of GPs as a result of a previous GSoC contributor. However, Gaussian processes are notorious for being very expensive to compute. Training a GP scales cubically with the training data points. This gets prohibitively expensive even for a few thousand training data points. There has been quite a lot of recent research in speeding up the training of GPs and this proposal will implement plans to implement a recently proposed GPU accelerated exact GP model [1](https://proceedings.neurips.cc/paper/2018/hash/27e8e17134dd7083b050476733207ea1-Abstract.html)",
          "difficulty": "advanced",
          "id": "proj_numfocus_2022_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/9ThHROQ9/",
          "proposal_id": null,
          "short_description": "Gaussian Processes (GPs) are a flexible class of probabilistic models which can automatically fit quite complex functions. In addition, GPs provide a...",
          "slug": "pymc-fast-exact-gaussian-processes",
          "status": "completed",
          "student_name": "KunalGhosh",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "PyMC - Fast Exact Gaussian Processes"
        },
        {
          "code_url": "https://mikics.github.io/gsoc-jupyterbook/submission.html",
          "description": "Electromagnetic devices have become ubiquitous in our lives due to their limitless applications. For designing and optimizing such devices, non-uniform and unstructured meshes are essential, due to the multiscale nature of the problem. The Finite Element Method (FEM) is well known for handling such meshes. FEniCSx is an open-source platform for solving partial differential equations with the FEM, offering high-level Python and C++ interfaces. It has become a popular choice among FEM users, especially for solid mechanic and fluid dynamic applications. However, FEniCSx has not met the same popularity for electromagnetic applications due to the lack of comprehensive demos showing how to correctly setup and solve electromagnetic partial differential equations, and therefore many researchers and engineers in this field prefer to use other (often commercial) FEM platforms. This proposal aims to solve this issue by developing extensive and accessible electromagnetic demos for a number of case studies. In particular, the work will focus on delivering at least five demos (plus tests and documentation), regarding 1) the use of complex numbers, the implementation of 2) Scattering Boundary Conditions, 3) Perfectly Matched Layers, and 4) Maxwell's equations for axisymmetric structures, and 5) the parallelization of a parameterized problem with the MPI COMM_SELF communicator.  These additions will be a step towards the extensive use of FEniCSx in the electromagnetic community since they will provide working tools for real-world problems. The demos will also be a show-reel for new features of FEniCSx that have not been covered in past demos or tutorials. A long term effect of this work could be more developers involved in the FEniCSx project, more guiding feedback from end users, and promotion of open source software for electromagnetic/photonic simulations.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2022_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/ezCgCetb/",
          "proposal_id": null,
          "short_description": "Electromagnetic devices have become ubiquitous in our lives due to their limitless applications. For designing and optimizing such devices,...",
          "slug": "expanding-fenicsx-electromagnetic-demos",
          "status": "completed",
          "student_name": "Michele Castriotta",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Expanding FEniCSx electromagnetic demos"
        },
        {
          "code_url": "https://gist.github.com/codeboy5/35e512302f1fd34bdbe211e0992e03f2",
          "description": "Time Series models constitute an integral part of the machine learning stack. Time series tasks can span a wide range of tasks such as classification, regression, forecasting, etc.\n\nThis project would aim to build elements of the FastAI.jl library, including high-level components for quickly generating state-of-the-art solutions for time-series tasks and low-level components for creating new novel techniques. The project would include adding support to load time series datasets using the FastAI.jl data registry, developing new methods for time series tasks, and training the models using best practices. We would also aim to write detailed tutorials on using, modifying, and creating new time series models for various tasks.\n\nWe wish to achieve these goals without compromising on the simplicity of use, flexibility or performance that FastAI.jl can offer.",
          "difficulty": null,
          "id": "proj_numfocus_2022_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/Q9GVFW33/",
          "proposal_id": null,
          "short_description": "Time Series models constitute an integral part of the machine learning stack. Time series tasks can span a wide range of tasks such as...",
          "slug": "fastaijl-time-series-development",
          "status": "completed",
          "student_name": "Saksham Rastogi",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "FastAI.jl Time Series Development"
        },
        {
          "code_url": "https://xspronken.github.io/2022/09/09/GSoC-Final-Submission.html",
          "description": "Quantum systems are very costly to simulate on a classical computer which can result in exceptionally long computation times. This projects aims to create a benchmarking tool that could be run regularly and record results in order to track code efficiency across different QuTiP updates. The two recorded benchmarking metrics would be memory occupation and CPU instruction count (as well as time cost of each instruction) as these are a good proxy for computation runtime without having to take hardware into account. A benchmarking guide will also be made in order to be able to translate bench results into real-world timing and give users an idea of computation times based on the hardware they will be using.",
          "difficulty": null,
          "id": "proj_numfocus_2022_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/tYPU30WM/",
          "proposal_id": null,
          "short_description": "Quantum systems are very costly to simulate on a classical computer which can result in exceptionally long computation times. This projects aims to...",
          "slug": "qutip-benchmarks",
          "status": "completed",
          "student_name": "xspronken",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Qutip Benchmarks"
        },
        {
          "code_url": "https://purna135.github.io/gsoc/work-summary/",
          "description": "Several multivariate distributions in PyMC, such as MvNormal, MvStudentT, and others,\nare constrained to working with 2D inputs and do not function with arbitrarily batched\ndimensions. The project's goal is to improve multivariate distribution support, making it\npossible to work with batched data (> 2D) in a vectorized manner.",
          "difficulty": null,
          "id": "proj_numfocus_2022_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/1wz8q5wi/",
          "proposal_id": null,
          "short_description": "Several multivariate distributions in PyMC, such as MvNormal, MvStudentT, and others, are constrained to working with 2D inputs and do not function...",
          "slug": "increase-support-for-batched-multivariate-distributions",
          "status": "completed",
          "student_name": "Purna Chandra Mansingh",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Increase Support for Batched Multivariate Distributions"
        },
        {
          "code_url": "https://github.com/SciML/ModelOrderReduction.jl",
          "description": "For simulating a system that contains many variables and/or equations, traditionally computational engineers tend to focus on utilizing an appropriate method with realistic time and space complexity. The technique of model order reduction (MOR), however, aims at approximating the original model with reduced number of variables and/or equations and still keeping sufficient accuracy. MOR is especially useful in various industries, for example thermal-fluids engineering, micro-electro-mechanical systems and control, where large-scale simulations have to be performed.\n\nThe methods of model order reduction can be classified into several classes including proper orthogonal decomposition, reduced basis, balanced truncation, etc. Several MOR libraries have been well developed in MATLAB and Python. For instance, pyMOR is a Python library that relies on the application of reduced basis methods to parameterized partial differential equations. MATLAB's model reducer supports pole-zero simplification, balanced truncation mode selection methods and so on.\n\nIn Julia, the main package that enables symbolic modeling is ModelingToolkit.jl, whose key features consist of automatic transformation and structural simplification, but it needs further works on fast ML approximate transformations. So this project is targeted on implementing MOR methods as extended features for ModelingToolkit.jl. Besides implementation of methods of model order reduction, the expected deliverables will include documentation which shows both the improved simulation time and accuracy penalty for the application of different MOR methods on test problems from various disciplines.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2022_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/nDpheIlA/",
          "proposal_id": null,
          "short_description": "For simulating a system that contains many variables and/or equations, traditionally computational engineers tend to focus on utilizing an...",
          "slug": "model-order-reduction-in-julia-sciml",
          "status": "completed",
          "student_name": "Bowen Zhu",
          "student_profile": null,
          "tags": [
            "python",
            "ml",
            "ai",
            "ui"
          ],
          "title": "Model Order Reduction in Julia SciML"
        },
        {
          "code_url": "https://github.com/SciML/QuantumNLDiffEq.jl",
          "description": "This project focuses on porting Plots recipes for SciML to Makie and adding to QuantumNLDiffEq.jl. Completion of the former would allow users to simply use Makie instead of Plots for various SciML types, while completion of latter involves adding more methods to QuantumNLDiffEq.jl.",
          "difficulty": null,
          "id": "proj_numfocus_2022_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/nMmWtAcL/",
          "proposal_id": null,
          "short_description": "This project focuses on porting Plots recipes for SciML to Makie and adding to QuantumNLDiffEq.jl. Completion of the former would allow users to...",
          "slug": "quantumnldiffeqjl-and-makie-recipes-for-sciml",
          "status": "completed",
          "student_name": "VarLad",
          "student_profile": null,
          "tags": [
            "ml"
          ],
          "title": "QuantumNLDiffEq.jl and Makie recipes for SciML"
        },
        {
          "code_url": "https://github.com/arviz-devs/ArviZGen.jl",
          "description": "ArviZ's purpose is to provide backend-agnostic tools for exploratory analysis of Bayesian models. To do so, we transform data from probabilistic programming frameworks to InferenceData, which we can then use in our plotting. Besides removing the need to explicitly import ArviZ with PyCall.jl, ArviZ.jl extends ArviZ with functionality for converting Julia types into ArviZ's InferenceData format. It also allows smoother usage with PyPlot.jl and provides functions that can be overloaded by other packages to enable their types to be used with ArviZ.\n Gen.jl is a general-purpose probabilistic programming system with programmable inference, embedded in Julia. Arviz currently isn’t compatible with Gen.jl and our goal is to implement a converter similar to the ‘from_xyz’ methods that are currently available in Arviz,jl.",
          "difficulty": null,
          "id": "proj_numfocus_2022_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/Psg95wBG/",
          "proposal_id": null,
          "short_description": "ArviZ's purpose is to provide backend-agnostic tools for exploratory analysis of Bayesian models. To do so, we transform data from probabilistic...",
          "slug": "add-gen-converter-to-arvizjl-julia",
          "status": "completed",
          "student_name": "S I Harini",
          "student_profile": null,
          "tags": [
            "ai",
            "backend"
          ],
          "title": "Add Gen converter to ArviZ.jl (Julia)"
        },
        {
          "code_url": "https://gist.github.com/vikram-s-narayan/01943ad8c52fe35f09d0749acd9ca11a",
          "description": "The purpose of this project is to improve Surrogates.jl by adding two new surrogate models - GEKPLS and GENN - and to make fixes and updates to existing Surrogates.jl code.",
          "difficulty": null,
          "id": "proj_numfocus_2022_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/XQzR5ztG/",
          "proposal_id": null,
          "short_description": "The purpose of this project is to improve Surrogates.jl by adding two new surrogate models - GEKPLS and GENN - and to make fixes and updates to...",
          "slug": "improve-surrogatesjl",
          "status": "completed",
          "student_name": "vikram-s-narayan",
          "student_profile": null,
          "tags": [],
          "title": "Improve Surrogates.jl"
        },
        {
          "code_url": "https://5hv5hvnk.github.io/blogs/NewModelBuilder",
          "description": "As the project title describes the main goal is to create a model class that builds, saves, loads, predict and fit user created models. This can be achieved by saving the metadata of model with model configuration and the model data itself and save it in a particular file format. Secondary goal of the project is to work on updation of the docker container of PyMC and write tutorials for deployment of PyMC models (using above API calls) for most common deployment tools such as docker, sagemaker, ML-Flow airflow and dask.",
          "difficulty": null,
          "id": "proj_numfocus_2022_018",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/G39Ptmap/",
          "proposal_id": null,
          "short_description": "As the project title describes the main goal is to create a model class that builds, saves, loads, predict and fit user created models. This can be...",
          "slug": "create-a-model-class-for-easier-deployment-of-pymc-models",
          "status": "completed",
          "student_name": "5hv5hvnk",
          "student_profile": null,
          "tags": [
            "api",
            "ml",
            "ai",
            "docker",
            "ui"
          ],
          "title": "Create a Model class for easier deployment of PyMC models"
        },
        {
          "code_url": "https://erinrolson.github.io/2022/09/08/GSOC-fifth-blog.html",
          "description": "Facility location modeling, a set of geoanalytic methods, is a critical problem solving tool leveraged in public and private sector decision making and planning activities. These models can be applied to a number of real-world problems, providing solutions that can account for varied resource availability and dispersion needs. Presently, PySAL has a basic implementation of location models, but these tools require further enhancement to become a comprehensive resource for users. The proposed 350-hour project aims to implement functionality for users to calculate results for the Backup Coverage Location Problem, optimize resources using the p-Dispersion model, and add additional functionality to existing models, such as facility capacity, demand unit shape, and distance metrics. Functionality will be implemented using well-known open-source GIS packages such as networkX, geopandas, and shapely.",
          "difficulty": null,
          "id": "proj_numfocus_2022_019",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/2wuW8zf8/",
          "proposal_id": null,
          "short_description": "Facility location modeling, a set of geoanalytic methods, is a critical problem solving tool leveraged in public and private sector decision making...",
          "slug": "facility-location-modeling-spopt-package-development",
          "status": "completed",
          "student_name": "Erin",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Facility Location Modeling (spopt) Package Development"
        },
        {
          "code_url": "https://drive.google.com/file/d/1igo5LbqWqdUFNKUrK9VngLQSbLYz9jTl/view?usp=sharing",
          "description": "This project aims to improve the existing deep learning for computer vision ecosystem in Julia, especially by adding more models that users can use without much modification. Metalhead.jl is the package where this project will be working on consolidating all such computer vision models., The goal will be to add models that are both customisable and extensible so that they can be used for tasks such as image classification and semantic segmentation with ease.",
          "difficulty": null,
          "id": "proj_numfocus_2022_020",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/7vJUICs0/",
          "proposal_id": null,
          "short_description": "This project aims to improve the existing deep learning for computer vision ecosystem in Julia, especially by adding more models that users can use...",
          "slug": "fluxml-metalheadjl-development",
          "status": "completed",
          "student_name": "Abhirath Anand",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ux"
          ],
          "title": "FluxML - Metalhead.jl development"
        },
        {
          "code_url": "https://www.tdhoffman.com/gsoc2022",
          "description": "For many users of statistical software, the most important aspect of a statistical software package is convenience. Therefore, it is important to structure statistical software libraries in a natural way that reflects how users most commonly think about their problems. At present, many of the user-facing interfaces of the Python Spatial Analysis Library (PySAL) follow inconsistent design patterns and may not be the most natural structures in terms of ease of use. This 350-hour project will study consider a set of interface designs for standardized use across the library’s statistical modeling packages and implement one such design in a development version of the library. If time permits, another aspect of this project that may be tackled is the extension of R-style Wilkinson formulas to spatial models via a Python package such as patsy or formulaic (Wilkinson and Rogers, 1973).",
          "difficulty": null,
          "id": "proj_numfocus_2022_021",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/NjFg0H2U/",
          "proposal_id": null,
          "short_description": "For many users of statistical software, the most important aspect of a statistical software package is convenience. Therefore, it is important to...",
          "slug": "interfaces-for-consistent-statistical-analysis-in-the-python-spatial-analysis-library-pysal",
          "status": "completed",
          "student_name": "Tyler Hoffman",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "Interfaces for consistent statistical analysis in the Python Spatial Analysis Library (PySAL)"
        },
        {
          "code_url": "https://prayasj.github.io/#/blogs/8",
          "description": "The aim of this project is to make the currently running forecasting system capable of parallelization. This is needed because the forecasting system currently follows a sequential method to forecast, which could be further optimized in the terms of time it takes by using multiple cores both on individual machines and High Performance Computers (HPC). This would be achieved by applying a forked parallelization method on the embarrassingly parallel problem available within the project currently.",
          "difficulty": null,
          "id": "proj_numfocus_2022_022",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/qBazQsVJ/",
          "proposal_id": null,
          "short_description": "The aim of this project is to make the currently running forecasting system capable of parallelization. This is needed because the forecasting system...",
          "slug": "data-retriever-high-performance-parallel-computing-for-model-fitting-and-prediction",
          "status": "completed",
          "student_name": "Prayas Jain",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "[Data Retriever] High-performance parallel computing for model fitting and prediction"
        },
        {
          "code_url": "https://gist.github.com/kpetridis24/535af6baf74953e55edc9770bea75200",
          "description": "Graph Isomorphism is an exciting topic regarding networks, but also a fairly complex problem to solve. The goal of the project is the full implementation of the VF2++ algorithm, which is an improved version of the original VF2 algorithm, extended to directed and multigraph settings, in a nonrecursive manner. \n\n\nThe brief description of the original algorithm (VF2) is that, after verifying  that both the input graphs have the same number of nodes and the exact same degree sequences, it starts constructing a mapping, between the nodes of the two graphs. If the mapping can be extended such that, every node from the first graph is matched to a node of the second graph, then the two graphs are considered to be Isomorphic.\n\nThe imporved version (VF2++), performs a preprocess, during which, a matching order is found, such that the algorithm is able to recognize the feasibility of the examined branches, avoiding a significant amount of computations by excluding the infeasible ones. \n\nThe plan to solve the problem is the following.\n\nStep 1: \nextensive research, questions asked and ideas discussed with the mentors. Establishment of a clear understanding of the topic is crucial.\n\nStep 2: \nDecomposition of the problem into smaller and more distinct, less complex sub-problems. These are basically the helper functions that are eventually going to be combined to form the final result.\n\nStep 3:\nStrict testing and reviewing the implementations throughout the entire process. Feedback from the community and the mentors regarding the progress so far. \n\nStep 4:\nImprovements based on the obtained feedback, application of optimizations, possible extra new features added.\n\nStep 5:\nIntegration of the final algorithm into the software of NetworkX. Possibly requires the creation of a wrapper class, hosting all the created functionalities.\n\nStep 6:\nDiscussions about further improvements out of the scope of GSoC. For example, parallelization with the help of tools such as Cython.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2022_023",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/V1hY83XG/",
          "proposal_id": null,
          "short_description": "Graph Isomorphism is an exciting topic regarding networks, but also a fairly complex problem to solve. The goal of the project is the full...",
          "slug": "networkx-vf2-implementation",
          "status": "completed",
          "student_name": "Konstantinos Petridis",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "NetworkX VF2++ Implementation"
        },
        {
          "code_url": "https://gist.github.com/PriyanshJalan/5756dfa7f9cf966092e8639a64fb3f3b",
          "description": "The project would involve creating a pipeline from data acquisition to simulation to overlaying the visualisation in an extended reality (XR) context. Using the real world camera feed and geolocation from an augmented reality capable device, real world topography would be extracted. This data would then be used to create a simulation using material point method and then the results would be overlayed on the scene. The project would provide a prototype to identify unsafe slopes in the wild.",
          "difficulty": null,
          "id": "proj_numfocus_2022_024",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/RH2pGDC6/",
          "proposal_id": null,
          "short_description": "The project would involve creating a pipeline from data acquisition to simulation to overlaying the visualisation in an extended reality (XR)...",
          "slug": "cb-geompm-numfocus-xr-simulations-for-natural-hazards",
          "status": "completed",
          "student_name": "Priyansh Jalan",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "CB-GeoMPM-NumFOCUS-XR Simulations-for-Natural-Hazards"
        },
        {
          "code_url": "https://gist.github.com/Vaibhav-Chopra-GT/b4725011475fb0508791222424e89f6b",
          "description": "This project aims to improve and populate the existing benchmark framework of PyBaMM. This will be achieved by -\n\n1. Adding new benchmarks for prominent battery models (Single Particle Model, Doyle Fuller Newman Model, and Single Particle Model with electrolyte). \n2. Adding user and developer documentation for benchmarking suite. \n3. Creating new benchmarks for other models and PyBaMM's API. \n4. Using files from ASV  to visualize benchmarks locally. \n5. Making the existing and the added benchmarks reproducible in any given environment.\n\nDeliverables -\n1. Documentation for benchmarks in PyBaMM’s website\n2. Template-like structure for benchmarking battery models available in PyBaMM.\n3. Benchmarks for prominent models.\n4. Benchmarks for other models and PyBaMM's API.\n5. Scripts for automating and running benchmarks locally (stretch).\n6. An environment in which all PyBaMM benchmarks can be reproduced (stretch).",
          "difficulty": null,
          "id": "proj_numfocus_2022_025",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/4azgJFTu/",
          "proposal_id": null,
          "short_description": "This project aims to improve and populate the existing benchmark framework of PyBaMM. This will be achieved by - 1. Adding new benchmarks for...",
          "slug": "benchmarks-for-pybamm",
          "status": "completed",
          "student_name": "Vaibhav Chopra",
          "student_profile": null,
          "tags": [
            "web",
            "api",
            "ai",
            "ui"
          ],
          "title": "Benchmarks for PyBaMM"
        },
        {
          "code_url": "https://github.com/lmariscal/DiffRast.jl",
          "description": "Implement the “Modular Primitives for High-Performance Differentiable Rendering” paper in Julia, making use of JuliaGPU.\n\nAllowing us to compare the existing Python/C++/Cuda implementation to the new Julia implementation.",
          "difficulty": null,
          "id": "proj_numfocus_2022_026",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/jOIuulhu/",
          "proposal_id": null,
          "short_description": "Implement the “Modular Primitives for High-Performance Differentiable Rendering” paper in Julia, making use of JuliaGPU. Allowing us to compare the...",
          "slug": "differentiable-rendering",
          "status": "completed",
          "student_name": "Leonardo D. Mariscal",
          "student_profile": null,
          "tags": [
            "python"
          ],
          "title": "Differentiable Rendering"
        },
        {
          "code_url": "https://drive.google.com/file/d/1MSZIr-VKtdHQDv-MK8hOCt8CAa8_nuil/view?usp=sharing",
          "description": "The aim is to build the textual portions of the FastAI.jl package, inspired by the fastai Python library, which will provide high-level components that can quickly and easily provide state-of-the-art results for all kinds of tasks, and provide low-level components that can be mixed and matched to build new approaches.\n\n\nThis will include handling textual data, performing transformations on it, creating a model using best practices (inspired from fastai), being able to train the created model, and interpreting and visualizing the results of the model.\n\n\nAll this will be done without compromising on ease of use, flexibility, or performance, due to the benefits Julia provides, along with the well-designed three-layered architecture.",
          "difficulty": null,
          "id": "proj_numfocus_2022_027",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/HogSGyea/",
          "proposal_id": null,
          "short_description": "The aim is to build the textual portions of the FastAI.jl package, inspired by the fastai Python library, which will provide high-level components...",
          "slug": "text-development-for-fastaijl",
          "status": "completed",
          "student_name": "Chandra Kiran Guntur",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Text Development for FastAI.jl"
        },
        {
          "code_url": "https://conorhassan.github.io/fastpages_blog/jupyter/2022/09/10/GSoC-submission.html",
          "description": "Currently, exact inference for Gaussian processes within PyMC makes heavy use of Cholesky decompositions that have a cubic asymptotic time complexity. Fortunately, modern hardware such as graphical processing units (GPUs) can improve the computational efficiency of large vector and matrix operations. While this hardware doesn't greatly benefit Cholesky decompositions, an approach called \"blackbox matrix multiplication\" (BBMM) has been developed for exact inference of Gaussian processes. BBMM efficiently utilise the benefits of GPUs, leading to quadratic asymptotic time complexity. This project aims to replace Cholesky decompositions required for inference of Gaussian processes with BBMM and similar methods, leading to massive improvements in computational efficiency for Gaussian process inference in PyMC.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2022_028",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/Q25GbRRz/",
          "proposal_id": null,
          "short_description": "Currently, exact inference for Gaussian processes within PyMC makes heavy use of Cholesky decompositions that have a cubic asymptotic time...",
          "slug": "fast-exact-gaussian-processes",
          "status": "completed",
          "student_name": "Conor Hassan",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Fast Exact Gaussian Processes"
        },
        {
          "code_url": "https://danhphan.net/blog/gp/gaussian%20process/2022/09/11/multi-ouput-gps-final-report.html",
          "description": "Multi-output Gaussian processes (MOGPs), a type of Bayesian nonparametric models, have recently gained strong attention from researchers, and become an active research topic in machine learning’s multi-task learning. The advantage of multi-output GPs is its capacity to simultaneously learn and infer many outputs which have the same source of uncertainty from inputs. This provides a useful and practical approach for various applications in different fields. \n\nThe creation of new sampling methods and the advance in computing power have paved the way for the development of Bayesian models. Different software frameworks have been built to facilitate this probabilistic programming approach. Among those, PyMC is one of the most popular frameworks with a large and strong community. PyMC provides friendly interfaces that allow users in academics and industries to perform both parametric and nonparametric Bayesian data analysis. For Bayesian nonparametric models, the Gaussian process module in PyMC supports various mean and kernel classes. However, the current GP implementations in PyMC are limited to single output. This project aims to add support for multi-output GPs in PyMC. This feature would significantly extend the capabilities of this important module and benefit the PyMC community.",
          "difficulty": null,
          "id": "proj_numfocus_2022_029",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/lKwZ8APE/",
          "proposal_id": null,
          "short_description": "Multi-output Gaussian processes (MOGPs), a type of Bayesian nonparametric models, have recently gained strong attention from researchers, and become...",
          "slug": "multi-output-gaussian-processes-in-pymc",
          "status": "completed",
          "student_name": "Danh Phan",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Multi-output Gaussian Processes in PyMC"
        },
        {
          "code_url": "https://gist.github.com/christian512/41ec4461f70b28c4f9ebc56fc4eae5cb",
          "description": "QuTiP uses Jupyter Notebooks to demonstrate its functionality in the\nfield of quantum physics and offers guidance to new users. While QuTiP is constantly improved, some notebooks might break due to a change in the QuTiP package. These errors are aggravating, especially for new users, as they appear in notebooks built especially for informative purposes. This Google Summer of Code (GSoC) project will utilize the already provided notebooks in an automated test pipeline to notify developers if recent changes break some notebooks. The test infrastructure will serve as additional integration tests to QuTiP functionality and makes it easier to keep the notebooks up to date. Furthermore, I will add an infrastructure regarding automated formatting of the notebooks and their deployment to QuTiP's website. In general, this project aims to improve the quality of the notebooks and their maintainability.",
          "difficulty": null,
          "id": "proj_numfocus_2022_030",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/Acz1NBSg/",
          "proposal_id": null,
          "short_description": "QuTiP uses Jupyter Notebooks to demonstrate its functionality in the field of quantum physics and offers guidance to new users. While QuTiP is...",
          "slug": "notebook-enhancements-for-qutip-5",
          "status": "completed",
          "student_name": "Chris Stbl",
          "student_profile": null,
          "tags": [
            "web",
            "ai",
            "ui"
          ],
          "title": "Notebook Enhancements for QuTiP 5"
        },
        {
          "code_url": "https://github.com/arviz-devs/arviz_dashboard/pull/4",
          "description": "Arviz, which is designed to be a backend-agnostic tool for diagnostics and visualization of Bayesian inference in Python, has encountered a number of problems, including: 1) It is difficult to initiate comparisons across various visualizations.  2) A shortage of interaction techniques. 3) Learning cost is high It is still hard for users without programming background . \n\nDeclarative dashboards, on the other hand, as a concept designed to apply the view-unit visualization-interaction model, can help users compare different visualizations in the same view and interact with several visualizations at the same time. \n\nAs a result, we’ll create dashboard templates for five statistical functions as part of the GSoC project to address ArviZ concerns, as well as formalize a developer guide (or blueprint) for future development. This GSoC project will act as a springboard for a larger project that will incorporate all sorts of ArviZ graphs in the dashboard as a separate Python library or ArviZ module.",
          "difficulty": null,
          "id": "proj_numfocus_2022_031",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/ap4EPHJ0/",
          "proposal_id": null,
          "short_description": "Arviz, which is designed to be a backend-agnostic tool for diagnostics and visualization of Bayesian inference in Python, has encountered a number of...",
          "slug": "arviz-dashboards",
          "status": "completed",
          "student_name": "Yilin",
          "student_profile": null,
          "tags": [
            "python",
            "ui",
            "backend"
          ],
          "title": "ArviZ Dashboards"
        },
        {
          "code_url": "https://github.com/parthb83/benchmarks/blob/final-report/README.md",
          "description": "A small benchmark suite already exists for CVXPY. The suite measures both the time to compile a problem into the solver standard form, and the time spent in the solver. Benchmarks are needed so that we can better understand how long it takes CVXPY to compile an issue. The benchmark suite needs to be extended substantially, with a wider range of problems. It should be simple to see how performance changes as a result of a PR or commit, as well as to follow those changes over time.",
          "difficulty": null,
          "id": "proj_numfocus_2022_032",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/dZSZ7AD1/",
          "proposal_id": null,
          "short_description": "A small benchmark suite already exists for CVXPY. The suite measures both the time to compile a problem into the solver standard form, and the time...",
          "slug": "improve-cvxpys-performance-benchmarks-with-continuous-integration",
          "status": "completed",
          "student_name": "Parth Bansal",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Improve CVXPY’s performance benchmarks with continuous integration."
        },
        {
          "code_url": "https://dassaniansh.blogspot.com/2022/09/gsoc-final-report.html",
          "description": "This project aims to make the model which would already be trained for the\nclassification of species and detection of alive and dead, trees or birds using transfer\nlearning on the current release model which is based on object detection, only\ndetecting trees and birds, for now, It also involves improving the user interface for\nworking with the multi-class model for a better understating of the species.",
          "difficulty": null,
          "id": "proj_numfocus_2022_033",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/n2RXlLSG/",
          "proposal_id": null,
          "short_description": "This project aims to make the model which would already be trained for the classification of species and detection of alive and dead, trees or birds...",
          "slug": "data-retriever-deepforest-multi-class-training-and-prediction",
          "status": "completed",
          "student_name": "Ansh Dassani",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "[Data Retriever] DeepForest Multi-class Training and Prediction"
        },
        {
          "code_url": "https://github.com/PhrygianGates/GSoC_Taskflow",
          "description": "This project is to add a layer of data abstraction on top of taskflow's original pipeline, so that users can either choose to prepare the data buffer manually and use an efficient pipeline without data abstraction, or choose to use a pipeline with data abstraction and let the program allocate the buffer automatically.\n\n- First, I will give an example of the use of the data abstraction after it has been added, which will be our design goal. \n- Second, I will implement two basic designs of the data abstraction layer.\n- Third, I will implement unit tests to make sure the new pipeline work.\n- Fourth, I will explore to implement a more efficient pipeline with data abstraction.\n- Last, I will implement two PARSEC benchmarks to evaluate the new pipeline.\n\nThis project will end up with a new taskflow pipeline class with data abstraction, along with unit tests and benchmarks.",
          "difficulty": null,
          "id": "proj_numfocus_2022_034",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/FgTgRVLt/",
          "proposal_id": null,
          "short_description": "This project is to add a layer of data abstraction on top of taskflow's original pipeline, so that users can either choose to prepare the data buffer...",
          "slug": "enhance-taskflows-pipeline-infrastructure",
          "status": "completed",
          "student_name": "Xiong Zhicheng",
          "student_profile": null,
          "tags": [],
          "title": "Enhance Taskflow's Pipeline Infrastructure"
        },
        {
          "code_url": "https://larrydong.com/gsoc/gsoc-2-final-submission/",
          "description": "In Bayesian statistics, one way to circumvent positing parametric assumptions is to use Dirichlet Processes (DP) as priors for probability distributions themselves. PyMC is a Python probabilistic programming library for Bayesian modelling and there are ongoing efforts to add a DP functionality to the package. DPs are daunting both theoretically and computationally as their non-trivial implementation would benefit from polished non-user facing methods in Aesara - formerly Theano - and AePPL. The former provides the computational backend to PyMC whereas AePPL converts arbitrary Aesara graphs into equivalent log-probability graphs which are convenient for automatic differentiation and hence sampling. The goals of my proposed Google Summer of Code (GSoC) project are threefold: relax the univariate assumption of components in mixture models, allow the creation of mixture graph via IfElse and Switch statements and continue ongoing efforts to add a DP functionality to PyMC.",
          "difficulty": null,
          "id": "proj_numfocus_2022_035",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/tSEKPZBa/",
          "proposal_id": null,
          "short_description": "In Bayesian statistics, one way to circumvent positing parametric assumptions is to use Dirichlet Processes (DP) as priors for probability...",
          "slug": "a-pymc-dirichlet-process-submodule-via-aeppl-enhancements",
          "status": "completed",
          "student_name": "larryshamalama",
          "student_profile": null,
          "tags": [
            "python",
            "ui",
            "backend"
          ],
          "title": "A PyMC Dirichlet Process Submodule via AePPL Enhancements"
        },
        {
          "code_url": "https://github.com/econ-ark/HARK/pull/1155",
          "description": "This project aims to implement the sequence space jacobian methods of Auclert et al. (2021) into the Heterogeneous Agents Resources and toolKit (HARK) under the econ-ARK project. These methods would allow the HARK toolkit to provide open source software for economic researchers to solve heterogeneous agent macroeconomic models. \n \nTo implement these computational methods, objects and tools in HARK will be extended to allow for the efficient simulation of a macroeconomic model, the computation of Jacobians to linearize a model, and the computation of impulse responses to a linearized model.\n\nAt the completion of this project, economic researchers will be able to simply specify the equations that define their model and be immediately returned the solutions to their model.",
          "difficulty": null,
          "id": "proj_numfocus_2022_036",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/VLmTvWI1/",
          "proposal_id": null,
          "short_description": "This project aims to implement the sequence space jacobian methods of Auclert et al. (2021) into the Heterogeneous Agents Resources and toolKit...",
          "slug": "solving-heterogeneous-agent-macroeconomic-models",
          "status": "completed",
          "student_name": "WDU",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Solving Heterogeneous Agent Macroeconomic Models"
        },
        {
          "code_url": "https://khushi-411.github.io/gsoc-cupy/",
          "description": "The project aims to enhance the coverage of SciPy functions in CuPy. The stretch goal is to introduce interpolate module in CuPy. I'm excited about it. I'll also be working on strengthening the scope of the special and stats modules in CuPy. My primary aim is to provide an efficient backbone to CuPy with optimized functions APIs.",
          "difficulty": null,
          "id": "proj_numfocus_2022_037",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2022/projects/fx6AgHkQ/",
          "proposal_id": null,
          "short_description": "The project aims to enhance the coverage of SciPy functions in CuPy. The stretch goal is to introduce interpolate module in CuPy. I'm excited about...",
          "slug": "cupy-coverage-of-scipy-functions",
          "status": "completed",
          "student_name": "Khushi Agrawal",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "CuPy coverage of SciPy functions"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2022/organizations/numfocus/"
    },
    "year_2023": {
      "num_projects": 24,
      "projects": [
        {
          "code_url": "https://pybamm.org/gsoc/2023/agriya-khetarpal/",
          "description": "This project aims to enhance the documentation infrastructure for PyBaMM and consolidate all of it in one place, which includes but will not be limited to: the API documentation, user guides, the example Jupyter notebooks, and the PyBaMM Wiki. This project will also introduce a new pybamm.org website with the Hugo static site generator, and improvements to the existing documentation built with Sphinx – based on other popular Python packages and libraries in order to make it more robust and maintainable. The project will also include other infrastructure improvements in scope such as those for the test suites, installation, and creating releases.",
          "difficulty": null,
          "id": "proj_numfocus_2023_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/DdcerdTx",
          "proposal_id": "gWiQaBzg",
          "short_description": "This project aims to enhance the documentation infrastructure for PyBaMM and consolidate all of it in one place, which includes but will not be...",
          "slug": "pybamm-documentation-agriya-khetarpal",
          "status": "completed",
          "student_name": "Agriya Khetarpal",
          "student_profile": null,
          "tags": [
            "python",
            "web",
            "api",
            "ai",
            "ui"
          ],
          "title": "[PyBaMM] - Documentation - Agriya Khetarpal"
        },
        {
          "code_url": "https://docs.google.com/document/d/1rgxcoO7hx6GDpiumeX0t7Blm7-kRfU1qSrTvS2vI42o/edit?usp=sharing",
          "description": "AiiDA has a flexible plugin system that allows extending most aspects of the code. This project aims to add several functionalities to the AiiDA plugin registry web page, including a relevant sort order for the plugins list, and the ability to search. This project also aims to get additional information about the plugins. This information will be a great way to discover and browse through the available capabilities each plugin provide.",
          "difficulty": null,
          "id": "proj_numfocus_2023_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/B9z9tso7",
          "proposal_id": "ISGbOCMO",
          "short_description": "AiiDA has a flexible plugin system that allows extending most aspects of the code. This project aims to add several functionalities to the AiiDA...",
          "slug": "ranking-system-for-aiida-plugin-registry",
          "status": "completed",
          "student_name": "Ahmed Basem",
          "student_profile": null,
          "tags": [
            "web",
            "ai"
          ],
          "title": "Ranking system for AiiDA plugin registry"
        },
        {
          "code_url": "https://pybamm.org/gsoc/2023/arjun-verma/",
          "description": "PyBaMM has a tedious installation process for development , which proves to be difficult for developers & researchers or anyone who wants to develop it. This project aims to simplify the installation process through Dockerization and make PyBaMM more accessible. In addition to that present Continuous Integration(CI) would also be modified in order to integrate dockerization with current workflow.",
          "difficulty": null,
          "id": "proj_numfocus_2023_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/vKlUTys3",
          "proposal_id": "HoopbVR7",
          "short_description": "PyBaMM has a tedious installation process for development , which proves to be difficult for developers & researchers or anyone who wants to develop...",
          "slug": "dockerizing-simplifying-pybamms-installation",
          "status": "completed",
          "student_name": "arjxn-py",
          "student_profile": null,
          "tags": [
            "ai",
            "docker"
          ],
          "title": "Dockerizing & Simplifying PyBaMM's Installation"
        },
        {
          "code_url": "https://github.com/cvxpy/org/blob/main/GSoC2023/aryamanjeendgar/final_report.pdf",
          "description": "Optimality conditions are a key aspect of mathematical optimization. The Karush-Kuhn-Tucker (KKT) conditions in particular are a really powerful result in convex optimization that provide certificates of optimality for convex constrained programming. This project aims to add support for verifying the KKT conditions for problems solved in CVXPY",
          "difficulty": null,
          "id": "proj_numfocus_2023_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/a8YyGIP0",
          "proposal_id": "m0spKGEw",
          "short_description": "Optimality conditions are a key aspect of mathematical optimization. The Karush-Kuhn-Tucker (KKT) conditions in particular are a really powerful...",
          "slug": "adding-structured-lagrangian-support-to-cvxpy",
          "status": "completed",
          "student_name": "Aryaman Jeendgar",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Adding structured Lagrangian support to CVXPY"
        },
        {
          "code_url": "https://dev.to/asmitbm/google-summer-of-code-2023-with-conda-forge-12c4",
          "description": "The project aims to modernize the conda-forge website by redesigning the landing\npage and creating a style guide for other conda-forge’s web-based projects. The new\nimplementation is expected to provide an intuitive and usable user experience. The\nredesigned landing page is expected to pass the SpeedPage and WAVE automated\ntests. The project also aims to work towards WCAG 2 conformance during the design\nphase and include accessibility annotations for the development phase. The expected\noutcome is a prototype conda-forge.org frontpage redesign that is live in cf-infra-docs and a conda-forge style guide for its new online presence. This project will benefit the conda-forge community by providing a more user-friendly and accessible website.",
          "difficulty": null,
          "id": "proj_numfocus_2023_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/5mhdEKMI",
          "proposal_id": "py35QfVW",
          "short_description": "The project aims to modernize the conda-forge website by redesigning the landing page and creating a style guide for other conda-forge’s web-based...",
          "slug": "modernization-of-the-conda-forgeorg-website",
          "status": "completed",
          "student_name": "Asmit Malakannawar",
          "student_profile": null,
          "tags": [
            "web",
            "ai",
            "ui"
          ],
          "title": "Modernization of the conda-forge.org website"
        },
        {
          "code_url": "https://medium.com/@ayeankit/final-report-google-summer-of-code-2023-6a45e877322b",
          "description": "Cookiecutter is a powerful command-line utility that generates project templates. Open science lab has developed a template that aims to provide the workflow, library, and tool recommended by PyOpenSci. This project aims to improve the document and add a different tool, add build systems, testing libraries, and more static analysis tools, and change the template engine from cookiecutter to cookieninja.",
          "difficulty": null,
          "id": "proj_numfocus_2023_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/26c9LZfd",
          "proposal_id": "fuPTPJhe",
          "short_description": "Cookiecutter is a powerful command-line utility that generates project templates. Open science lab has developed a template that aims to provide the...",
          "slug": "open-science-labs-improve-scientific-python-cookiecutter-project",
          "status": "completed",
          "student_name": "ayeankit",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Open Science Labs-Improve Scientific Python Cookiecutter Project"
        },
        {
          "code_url": "https://cmhyett.github.io/portfolio/gsoc/",
          "description": "I propose to implement a common interface to deploy the power of SciML to dynamical systems on graphs. In achieving this, one new package will be developed (I refer to it temporarily as ``PDEsOnGraphs.jl'') and two will be contributed to: modernization of FEniCS.jl with integration with FEniCSx/DOLFINx, and implementation of staggered-grid discretizations in MethodOfLines.jl. I propose this work to empower researchers modeling flows - be it water, sewer, natural gas, electricity, traffic, blood, etc. - by utilizing the power of the julia, and specifically the SciML, ecosystem.",
          "difficulty": null,
          "id": "proj_numfocus_2023_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/YX0ACw7M",
          "proposal_id": "nEy4hpUP",
          "short_description": "I propose to implement a common interface to deploy the power of SciML to dynamical systems on graphs. In achieving this, one new package will be...",
          "slug": "numfocus-sciml-pdes-on-graphs",
          "status": "completed",
          "student_name": "Criston Hyett",
          "student_profile": null,
          "tags": [
            "ml"
          ],
          "title": "NumFocus & SciML, PDEs on Graphs"
        },
        {
          "code_url": "https://github.com/daniel-saunders-phil/GSoC/tree/master",
          "description": "This project would implement the Besag, York, Mollie (BYM) model in PyMC. BYM is a highly flexible model for studying spatial data and is used widely in epidemiology, agriculture, and ecology. The strategy behind the BYM model is to treat the outcome of interest as the result of three factors: some set of predictor variables, spatial covariance between neighboring regions, and random effects that represent non-spatial heterogeneity.\n\nAlthough very flexible, the BYM model can be difficult to specify in a way that is simultaneously computationally efficient, interpretable, and identifiable. Recently, Morris et al (2019) demonstrated an alternative specification of the BYM model that is significantly more efficient, interpretable, and can be identified with Monte Carlo Markov Chain (MCMC) samplers.\n\nDeveloping an implementation in Python with PyMC would make the model more accessible to a greater variety of users. Furthermore, BYM models are only available in a Bayesian framework. As a leading Bayesian statistics package, PyMC should support this extremely useful model in spatial statistics.",
          "difficulty": null,
          "id": "proj_numfocus_2023_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/Oxk6HziB",
          "proposal_id": "ztmhLSmF",
          "short_description": "This project would implement the Besag, York, Mollie (BYM) model in PyMC. BYM is a highly flexible model for studying spatial data and is used widely...",
          "slug": "expand-support-for-spatial-models-in-pymc",
          "status": "completed",
          "student_name": "Daniel_Saunders",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "Expand support for spatial models in PyMC"
        },
        {
          "code_url": "https://gstechschulte.github.io/cached-blog/posts/2023-08-18-gsoc-final-report.html",
          "description": "Bayesian modeling has increased significantly in academia and industry over the past years thanks to the development of high quality and user friendly open source probabilistic programming languages (PPL) in Python and R. Of these is Bambi, a Python library built on top of the PyMC PPL, that makes it easy to specify complex generalized linear multilevel models using a formula notation similar to those found in R. However, as the model building portion of the Bayesian workflow becomes easier, the interpretation of these models has not. Currently, to aid in model interpretability, Bambi only supports conditional adjusted predictions plots. The objective is to take inspiration from the existing Bambi tooling and R package marginaleffects, to extend upon existing plotting functionality and to provide additional plotting functions such as conditional comparisons and conditional marginal effects to allow Bambi modelers to extract insights and interpret their models in a more automatic and effective manner.",
          "difficulty": "beginner",
          "id": "proj_numfocus_2023_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/MpE5Sl2V",
          "proposal_id": "EC4raCRO",
          "short_description": "Bayesian modeling has increased significantly in academia and industry over the past years thanks to the development of high quality and user...",
          "slug": "better-tools-to-interpret-complex-bambi-regression-models",
          "status": "completed",
          "student_name": "GStechschulte",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Better tools to interpret complex Bambi regression models"
        },
        {
          "code_url": "https://pybamm.org/gsoc/2023/julian-evers/",
          "description": "A very interesting and nice thing during the development of batteries are back-of-the-envelope estimations. An example might be to estimate an areal loading of active material necessary to compete with another active material, which has different capacity and potential. The different loading would also influence the entire cell and process design such that a coupled cell-process-cost model could give much more accurate and holistic cost estimates than single rules of thumb can. The coupling of cell and process can be achieved by decomposing the process into decoupled process units, which are then connected with cell parameters, e.g. areal loadings. The flexible submodel structure of PyBaMM would enable the use of independent “plug and play” economics e.g. for modeling different processes and economies of scale, as well as the combination of other PyBaMM models to estimate key values for degradation and thermal performance. Making it possible e.g. to study the interplay between formation and degradation accompanied with costs and other key values such as energy densities.",
          "difficulty": null,
          "id": "proj_numfocus_2023_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/OE5AUkm6",
          "proposal_id": "x1zNVduY",
          "short_description": "A very interesting and nice thing during the development of batteries are back-of-the-envelope estimations. An example might be to estimate an areal...",
          "slug": "pybamm-techno-economic-analysis-library",
          "status": "completed",
          "student_name": "Julian Evers",
          "student_profile": null,
          "tags": [],
          "title": "PyBaMM Techno-Economic Analysis Library"
        },
        {
          "code_url": "https://docs.google.com/document/d/1aGnYhUlbT970HkipDZ4K7R4qqTtid29tmSFYT98hYyw/edit",
          "description": "NetworkX is a Python package offering a large set of algorithms and tools for the study and manipulation of graphs. Users have requested parallel implementations of many algorithms, something especially relevant with the rising interest in machine learning and, as a result, parallel computation. As such, I built the foundation for nx_parallel, a parallel backend to NetworkX that makes use of its plugin dispatch architecture, an experimental feature. I parallelized multiple NetworkX functions in nx_parallel, and created the structure for future efforts to build out the parallel backend. \nIn addition, although the graph algorithms in NetworkX are well-documented, users benefit from explanations and example uses of the algorithms. To satisfy this need, NetworkX has created nx-guides, which are pedagogical Jupyter Notebooks that clearly explain and experimentally explore (with examples) algorithms implemented in NetworkX. I added a notebook to nx-guides where I explain the traversal algorithms provided by NetworkX. In addition, new contributors currently do not have a roadmap for contributing to nx-guides, as mentioned by @MridulS in community meeting notes. In addition to my pedagogical notebooks, I finalized an easy-to-follow contributing guide for nx-guides.",
          "difficulty": "beginner",
          "id": "proj_numfocus_2023_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/3FX4575A",
          "proposal_id": "V76dh8bS",
          "short_description": "NetworkX is a Python package offering a large set of algorithms and tools for the study and manipulation of graphs. Users have requested parallel...",
          "slug": "nx_parallel-a-parallel-backend-for-networkx-nx-guides-contributor-guide-and-traversal-notebook",
          "status": "completed",
          "student_name": "Kavish Senthilkumar",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui",
            "backend"
          ],
          "title": "nx_parallel: a parallel backend for NetworkX + nx-guides Contributor Guide and Traversal Notebook"
        },
        {
          "code_url": "https://medium.com/@Lalit.Chauhan/gsoc23-final-project-report-117b5308e047",
          "description": "The project will involve the creation of a new package that will provide an interface to query for chemical species and enzymes using the PubChem API. This will then be integrated into the existing library Catalyst.jl to improve upon its functionalities.\n\nThis will prove in Improved accuracy in identifying chemical species and enzymes in reaction networks. By accessing the vast amount of data in the PubChem database, Catalyst.jl will be able to provide more accurate identification of chemical species and enzymes in reaction networks, reducing ambiguity and improving the quality of results.",
          "difficulty": null,
          "id": "proj_numfocus_2023_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/aAJMK8lZ",
          "proposal_id": "NXyOkEqX",
          "short_description": "The project will involve the creation of a new package that will provide an interface to query for chemical species and enzymes using the PubChem...",
          "slug": "sciml-integrating-pubchem-closely-into-catalyst-and-sciml",
          "status": "completed",
          "student_name": "Lalit Chauhan",
          "student_profile": null,
          "tags": [
            "react",
            "api",
            "ml",
            "database",
            "ui"
          ],
          "title": "SciML: Integrating PubChem Closely into Catalyst and SciML"
        },
        {
          "code_url": "https://github.com/taskflow/taskflow/",
          "description": "The C++ Standard Template Library (STL) provides many algorithms to sort, search, and perform a variety of operations on numerous data structures in its algorithms library. However, a major issue with the STL is that it is not optimized for parallel programming. Despite the fact that nearly all processors ship today with multithreading available, the STL is currently single threaded, leaving its algorithms library running at suboptimal efficiency. Taskflow is a C++ parallel programming library that organizes functions into tasks that it then can run concurrently or consecutively, depending on the user’s goal. My project will reimplement the STL’s algorithm library using Taskflow so that it can take advantage of multithreading.",
          "difficulty": null,
          "id": "proj_numfocus_2023_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/Mv3UZZQg",
          "proposal_id": "S2erw9Uv",
          "short_description": "The C++ Standard Template Library (STL) provides many algorithms to sort, search, and perform a variety of operations on numerous data structures in...",
          "slug": "taskflow-creating-parallel-algorithm-primitives",
          "status": "completed",
          "student_name": "Om Khangaonkar",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Taskflow: Creating Parallel Algorithm Primitives"
        },
        {
          "code_url": "https://erikqqy.github.io/2023/08/22/gsoc-final-report/",
          "description": "Boundary value problems (BVPs) are mathematical models that arise in a variety of fields, such as economics and chemistry. BVPs are essentially ordinary differential equations (ODEs), but with additional constraints. The current implementation of MIRK solvers in BoundaryValueDiffEq.jl does not support defect control and mesh uniform refinement, which really hindered its application. To address this limitation, the goal of this project is to implement defect control for MIRK (Monotonic Implicit Runge-Kutta) solvers and to add mesh uniform refinement to BoundaryValueDiffEq.jl, thus enhancing the capabilities of SciML's differential equations solvers in solving BVPs。",
          "difficulty": null,
          "id": "proj_numfocus_2023_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/zLtIiHjs",
          "proposal_id": "DK7ZTTN4",
          "short_description": "Boundary value problems (BVPs) are mathematical models that arise in a variety of fields, such as economics and chemistry. BVPs are essentially...",
          "slug": "adaptive-mirk-bvp-solvers",
          "status": "completed",
          "student_name": "Qingyu Qu",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Adaptive MIRK BVP solvers"
        },
        {
          "code_url": "https://devrd.github.io/posts/gsoc_fin",
          "description": "Matplotlib is a popular data visualization library that is used in multiple academic and industrial projects. LaTeX is a common tool for formatting mathematical symbols in most technical plots. Matplotlib supports mathematical typesetting through the ‘mathtext’ module. This LaTeX framework enables mathematical symbols, math fonts, and font encodings to fine-tune the usability of math texts inside a data plot. This project focuses on improving mathtext by examining the known/reported issues within the existing framework, expanding support for new Math-LaTeX-based features, and incorporating robust testing to track down unobserved issues. The overarching goal of this project is to improve the functionality and usability of mathtext for a wide spectrum of use cases.",
          "difficulty": null,
          "id": "proj_numfocus_2023_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/AWFpwnZK",
          "proposal_id": "iFFqK8Sk",
          "short_description": "Matplotlib is a popular data visualization library that is used in multiple academic and industrial projects. LaTeX is a common tool for formatting...",
          "slug": "matplotlib-improvements-to-mathtex",
          "status": "completed",
          "student_name": "Ratnabali <devRD>",
          "student_profile": null,
          "tags": [],
          "title": "Matplotlib: Improvements to MathTeX"
        },
        {
          "code_url": "https://gist.github.com/rohanbabbar04/8d3b957fd359c4c14d1d3882b38967f9",
          "description": "Pylops has been developed to solve large-scale inverse problems. Keeping in mind the\nmemory size of a single machine, there is a need to perform the operations in a\ndistributed fashion.\nThe main goal of this project is to use the mpi4py package to exchange messages\nbetween different processes across distributed memory.\nThe main outcomes of this project are to develop a DistributedArray class using mpi4py to broadcast or scatter numpy/cupy arrays and perform basic operations like sum, product, dot-product, element-wise product, etc in a distributed fashion. Additionally, MPI functionality will be added to BlockDiag, VStack, and HStack, and the code for forward, centered, and backward finite difference stencils will be updated using Distributed Arrays. Lastly, at least one of the CG, CGLS, and LSQR solvers will be modified to use Distributed Arrays.\nThis will benefit the Pylops Codebase as integrating mpi4py into the codebase will\nenhance the operators' performance and prevent exceeding memory on a single\nmachine.",
          "difficulty": null,
          "id": "proj_numfocus_2023_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/eNJTJO25",
          "proposal_id": "hfqdEk3O",
          "short_description": "Pylops has been developed to solve large-scale inverse problems. Keeping in mind the memory size of a single machine, there is a need to perform the...",
          "slug": "pylops-mpi-backend-for-distributed-inverse-problems",
          "status": "completed",
          "student_name": "Rohan Babbar",
          "student_profile": null,
          "tags": [
            "ai",
            "backend"
          ],
          "title": "PyLops: MPI backend for distributed inverse problems"
        },
        {
          "code_url": "https://github.com/rongboxu/P-Median-Model-with-Near-Far-Cost-Allocation",
          "description": "For now spopt has implemented several basic facility location models, providing the free open source for researcher, or organizations to use. However, there are still many useful improvements can be made. This proposal suggests improving the spopt package by implementing the P-Median model with Near-Far Cost Allocation. In the article by Church (2018), it proposed a new p-median model which can distinguish between near and far facilities, use both explicit and implicit variables for capacity allocations. Based on that, the writer plans to implement the p-median model with near-far cost allocation. By this, the spopt package can provide more accurate and efficient solutions to spatial optimization problems, typically for the problems with large data points, and large demand volume. This proposal will introduce the reason why the writer chooses this project, the technical details of this project, and the plan and delivery schedules.",
          "difficulty": null,
          "id": "proj_numfocus_2023_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/05jDO3IG",
          "proposal_id": "IosfHXC5",
          "short_description": "For now spopt has implemented several basic facility location models, providing the free open source for researcher, or organizations to use....",
          "slug": "pysal-spopt-development-p-median-model-with-near-far-cost-allocation-guided-by-toblers-law",
          "status": "completed",
          "student_name": "Rongbo Xu",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "[PySAL - spopt Development] P-Median Model with Near-Far Cost Allocation: Guided by Tobler's Law"
        },
        {
          "code_url": "https://sachinjalan.github.io/",
          "description": "CB Geo-Material Point Method is used to simulate particulate and fluid systems. In this method, particles are mapped to a background mesh, and calculations done on the mesh points are transformed into the original particles. In this project, we would implement 1-D and 2-D MPM code in python using the JAX library. We will abstract the code into classes to apply automatic differentiation and use just-in-time compilation. We will also implement 1D MPM code in C++ and apply auto diff. Currently, the MPM code does not have an inverse problem solver; hence in this project, we will implement an inverse problem solver using automatic differentiation and gradient-based optimizations to minimize the loss function.",
          "difficulty": null,
          "id": "proj_numfocus_2023_018",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/RZJ09HkH",
          "proposal_id": "yXiCAP3f",
          "short_description": "CB Geo-Material Point Method is used to simulate particulate and fluid systems. In this method, particles are mapped to a background mesh, and...",
          "slug": "cb-geo-differentiable-programming-in-mpm",
          "status": "completed",
          "student_name": "Sachin Jalan",
          "student_profile": null,
          "tags": [
            "python",
            "ui"
          ],
          "title": "CB Geo: Differentiable Programming in MPM"
        },
        {
          "code_url": "https://gist.github.com/sak-codes/2c2d948f8ec285360247db6606cb4ad3",
          "description": "PyDataStructs is a high-performance python package for data structures and algorithms providing C++ backend via Python C-API  as well as a parallel computation that provides lightning performance.\na) Single package for all data structures and algorithms.\nb) Consistent APIs and Clean Interface.\nc) Supported on all three platforms  - Windows, macOS, and Linux.\n\nI aim to work on the following during the project duration - \n1) Increase the scope of missing data structures and algorithms\n2) Adding methods to current data structures to extend their support in other research \n     and engineering backgrounds\n3) Implementing the C++ backend to provide high performance\n4) Enhancing the documentation for make it more user friendly and easy to follow\n5) Aggressively test the newly added as well as the existing code to achieve 100% \n    coverage which currently is at 99%.",
          "difficulty": "beginner",
          "id": "proj_numfocus_2023_019",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/42ye2zYO",
          "proposal_id": "fff1j87q",
          "short_description": "PyDataStructs is a high-performance python package for data structures and algorithms providing C++ backend via Python C-API as well as a parallel...",
          "slug": "extending-the-data-structures-and-algorithms-along-with-providing-c-backend",
          "status": "completed",
          "student_name": "Sakshi Oza",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai",
            "ux",
            "backend"
          ],
          "title": "Extending the data structures and algorithms along with providing C++ backend."
        },
        {
          "code_url": "https://gist.github.com/satsin06/e3bd59a5b69df7dc5b38cf848b8f5b8f",
          "description": "The project aims to build a new function that populates the NEON field and remote sensing data for deepforest which will help us build a baseline classification for tree health status. NEON DATA API provides access to open-access ecological data where neonwranglerpy package helps in retrieving the data, cleaning, and providing a ready format for ecological analysis for researchers. With the help of this project, we will be able to train multi-class classification in deepForest. By this, we will improve the automated alignment of deepForest boxes to NEON individual tree coordinates, provided as stem location.",
          "difficulty": null,
          "id": "proj_numfocus_2023_020",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/HooCVkAe",
          "proposal_id": "82KzqcLo",
          "short_description": "The project aims to build a new function that populates the NEON field and remote sensing data for deepforest which will help us build a baseline...",
          "slug": "data-retriever-tree-health-and-mortality-from-neon-data",
          "status": "completed",
          "student_name": "Satyam Sinha",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "ui"
          ],
          "title": "Data Retriever: Tree health and mortality from NEON data"
        },
        {
          "code_url": "https://docs.google.com/document/d/1mVEFSlEbtmZec8C3SRJ0CX1Sp3gIYQPjRY2iaktr9H4/edit?usp=sharing",
          "description": "FluxML is a deep learning stack built in 100% Julia code, which aims to provide high-speed and light-weight abstraction of GPU, auto-differentiation and deep learning model composites. This project will introduce a specific benchmarking system to adapt to the current requirements of the FluxML community. The system includes GitHub Actions workflows that are triggered by specific events, a FluxML-specific benchmarking tool and a repository for benchmarking code.",
          "difficulty": null,
          "id": "proj_numfocus_2023_021",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/whO3fAS8",
          "proposal_id": "aYOjyrG9",
          "short_description": "FluxML is a deep learning stack built in 100% Julia code, which aims to provide high-speed and light-weight abstraction of GPU, auto-differentiation...",
          "slug": "benchmark-tooling-for-common-models-and-operations",
          "status": "completed",
          "student_name": "skyleaworlder",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui",
            "ux"
          ],
          "title": "Benchmark tooling for common models and operations"
        },
        {
          "code_url": "https://github.com/qutip/qutip-virtual-lab/releases/tag/v1.0.0-rc.1",
          "description": "Simulating quantum physics in QuTiP provides an excellent educational tool. However, using QuTiP requires writing Python code, which may present an obstacle in some teaching contexts. Programming is, of course, a very valuable skill to master. Attempting to master it while simultaneously coming to grips with quantum mechanics is perhaps less advisable.\n\nWe would like to create a graphical virtual laboratory powered by QuTiP which allows users to explore quantum systems without being distracted by the need to write software.\n\nThe virtual lab would allow building up experiments from components (e.g. sub-spaces such as qubits, Hamiltonians for those subspaces, interaction Hamiltonians, environment baths), evolving the system over time, applying measurements, and attaching monitoring of quantum states or measurement outcomes (e.g. Hinton plots, Bloch sphere plots). \n\nDeliverables\n\n- A graphical interface that acts as a virtual laboratory\n- Allows the construction of simple quantum systems (e.g. placing four neutral atoms)\n- Allows defining the evolution of each system component\n- Allows defining the interactions between system components\n- Allows coupling the system to an environment bath\n- Allows simulating the system dynamics and visualizing their evolution over time\n- Allows visualizing the steady state of the defined system\n- Can be run on both desktop and tablets",
          "difficulty": null,
          "id": "proj_numfocus_2023_022",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/88K7XU4Q",
          "proposal_id": "XOucSZXW",
          "short_description": "Simulating quantum physics in QuTiP provides an excellent educational tool. However, using QuTiP requires writing Python code, which may present an...",
          "slug": "qutip-virtual-lab",
          "status": "completed",
          "student_name": "Trent F",
          "student_profile": null,
          "tags": [
            "python",
            "ui"
          ],
          "title": "QuTiP Virtual Lab"
        },
        {
          "code_url": "https://www.zijie.ca/documents/WilliamZ_GSoC_2023_report.pdf",
          "description": "(This project is for CVXPY)\nThe performance of canonicalization procedures for optimization problems is an important metric for CVXPY users. Typically, this process is quite slow for large Disciplined Parametrized Programs(DPP). However, it is possible to improve upon the canonicalization by replacing the way 3D sparse tensors are represented.\nOne of the major updates of CVXPY 1.3 was the addition of a SciPy backend, which allowed a performance speedup for certain types of optimization problems. This new backend offers an alternative to the original C++ backend implementation (CVXCORE), and enables easier development. \nThe SciPy backend has some limitations especially when it comes to manipulating sparse tensors with 3 dimensions. The current representation of a 3D sparse tensor is to use a list of 2D matrices. However, a sparse tensor of large dimension could be represented as a single strided matrix, which can make CVXPY backend operations orders of magnitude more efficient.",
          "difficulty": null,
          "id": "proj_numfocus_2023_023",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/Cpab8rXK",
          "proposal_id": "htCPrXw3",
          "short_description": "(This project is for CVXPY) The performance of canonicalization procedures for optimization problems is an important metric for CVXPY users....",
          "slug": "boosting-canonicalization-performance-by-replacing-n-dimensional-sparse-tensor-representation",
          "status": "completed",
          "student_name": "WilliamZijieZhang",
          "student_profile": null,
          "tags": [
            "ai",
            "ui",
            "backend"
          ],
          "title": "Boosting canonicalization performance by replacing N-dimensional sparse tensor representation"
        },
        {
          "code_url": "https://tamakoshi2001.github.io/2023/08/24/Final-Report-for-Visualization-with-QuTiP.html",
          "description": "QuTiP has a lot of visualization functions, but they are sometimes not user-friendly in that colors are unchangeable and arguments are not organized. This project aims to improve them.\n\nThis project will enhance existing functions by unifying the interface and adding colorblind options for all of them. Additionally, the project will develop an animation function for the evolution of quantum states.\n\nThe deliverable consists of unified interfaces for plot functions that have colorblind support, animation functions for the Result object, and pytests and documents for all of them.",
          "difficulty": null,
          "id": "proj_numfocus_2023_024",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2023/projects/TV6us9ou",
          "proposal_id": "ltfUQOyT",
          "short_description": "QuTiP has a lot of visualization functions, but they are sometimes not user-friendly in that colors are unchangeable and arguments are not organized....",
          "slug": "visualization-with-qutip",
          "status": "completed",
          "student_name": "Yuji Tamakoshi",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Visualization with QuTiP"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/programs/2023/organizations/numfocus"
    },
    "year_2024": {
      "num_projects": 35,
      "projects": [
        {
          "code_url": "https://github.com/ka-bear/NeuralPDE.jl/blob/master/README.md",
          "description": "The goal of this project is to implement Physics-Informed Point Networks (PIPNs) in Julia to solve partial differential equations (PDEs) on irregular geometries. PIPNs combine deep learning (specifically PointNet architectures for processing point cloud data) with the governing physics equations to enable efficient simulations on complex geometric domains.\n\nI plan on solving this problem by creating a well-documented, optimized and thoroughly tested Julia package for PIPNs that can efficiently solve PDEs on complex geometries. The implementation will be integrated with relevant scientific computing and machine learning packages in Julia.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2024_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/JbJi9hVk/",
          "proposal_id": null,
          "short_description": "The goal of this project is to implement Physics-Informed Point Networks (PIPNs) in Julia to solve partial differential equations (PDEs) on irregular...",
          "slug": "implementation-of-physics-informed-point-networks-for-simulation-in-irregular-geometries",
          "status": "completed",
          "student_name": "Kabir Jain",
          "student_profile": null,
          "tags": [
            "ai",
            "cloud"
          ],
          "title": "Implementation of Physics-Informed Point Networks for Simulation in Irregular Geometries"
        },
        {
          "code_url": "https://github.com/imperorrp/gsoc-2024",
          "description": "ArviZ is a package for the exploratory analysis of bayesian inference models. The current Python release of ArviZ involves three major modules that also encapsulate its core functionalities- data, plots, and stats. These are planned to be split into packages of their own, like arviz-plots, arviz-base, and arviz-stats. Development work involving the creation of these is being undertaken, with some key refactoring changes especially planned for the arviz-plots based plotting functionality, which is what this project is based on. \n\n\nThe current plots that Arviz supports were added incrementally to the package over time, including in past GSoC projects, resulting in some redundancy and complicated to extend code. Plans and brainstorming for refactoring this have been around for a while. \n\n\nWork done so far on ArviZ-Plots has included a new class, PlotCollection, an improved backend interface and backend system, and 4 “batteries-included” plots at least partially adapted for this new backend. \n\nFor my role in the course of this project, I will be using the PlotCollection class to implement some other plots from old ArviZ and add modular backend functions and visual elements (an intermediate layer for atomic visual elements used across plot types) required for these as appropriate. I will also be working on creating documentation and tests for these new plots added to ArviZ-plots as well as the PlotCollection class used to do these. For users, the refactored changes aim to provide improved visual aesthetics, an abstraction of aesthetics mapping to subplots and a more compact, flexible API overall. For developers, easier writing of new plotting functionality, extensibility and maintainability are the goals.",
          "difficulty": "medium",
          "id": "proj_numfocus_2024_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/X9jNcYK7/",
          "proposal_id": null,
          "short_description": "ArviZ is a package for the exploratory analysis of bayesian inference models. The current Python release of ArviZ involves three major modules that...",
          "slug": "arviz-plotting-refactoring-python",
          "status": "completed",
          "student_name": "Ratish Panda",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai",
            "ui",
            "backend"
          ],
          "title": "ArviZ Plotting Refactoring Python"
        },
        {
          "code_url": "https://gist.github.com/Om-Doiphode/77ac70ab14c9134182cebe6077480de1",
          "description": "The Everglades, a vital habitat for vulnerable and endangered bird species, requires accurate monitoring of nesting patterns for effective conservation. However, detecting bird nests in this vast and complex landscape is challenging, especially using UAV imagery that varies in quality and detail. Existing image recognition models lack the specificity needed for accurate nest detection in this unique environment, struggling with small or camouflaged objects. This project addresses this gap by developing a robust, machine learning-based model tailored to consistently and accurately identify bird nests in Everglades UAV imagery, even under challenging conditions.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2024_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/uN8mA5zq/",
          "proposal_id": null,
          "short_description": "The Everglades, a vital habitat for vulnerable and endangered bird species, requires accurate monitoring of nesting patterns for effective...",
          "slug": "developing-an-advanced-image-recognition-model-for-bird-nest-detection-in-uav-imagery",
          "status": "completed",
          "student_name": "Om Doiphode",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Developing an Advanced Image Recognition Model for Bird Nest Detection in UAV Imagery"
        },
        {
          "code_url": "https://github.com/aiidateam/aiida-explorer/blob/gsoc/gsoc/README.md",
          "description": "The project aims to create an intuitive tool in React for browsing AiiDA graphs, replacing the outdated AiiDA Provenance Browser in Materials Cloud Explore. This tool will interface with AiiDA via REST API, enabling dynamic graph exploration, clear differentiation of input and output nodes, complete visualization of connecting nodes, and node preview without page redirection. The desired result is an AiiDA node graph viewer developed with React, potentially published as a Component on the npm repository",
          "difficulty": null,
          "id": "proj_numfocus_2024_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/l9XgEOnp/",
          "proposal_id": null,
          "short_description": "The project aims to create an intuitive tool in React for browsing AiiDA graphs, replacing the outdated AiiDA Provenance Browser in Materials Cloud...",
          "slug": "explore-the-aiida-node-graph-in-the-browser",
          "status": "completed",
          "student_name": "Sharan poojari",
          "student_profile": null,
          "tags": [
            "react",
            "api",
            "ai",
            "cloud",
            "ui"
          ],
          "title": "Explore the Aiida Node graph in the browser"
        },
        {
          "code_url": "https://github.com/jupyterlab/frontends-team-compass/wiki/GSoC-2024-Submission-%E2%80%90-Improve-User-Experience-Using-Jupyter-Toolkit",
          "description": "The UI Toolkit serves as a component library tailored for crafting web interfaces within the Jupyter ecosystem, encompassing platforms such as Jupyter Hub, Jupyter Widgets, and Jupyter Lab. With the introduction of this toolkit, the aim is to capitalise on its capabilities to enhance UI consistency and alleviate maintenance overhead. Here's a structured plan to achieve this:\n 1.Use toolkit search/input for all search/inputs: filebrowser, extension manager, debugger kernel source\n 2.Use toolkit button for all buttons: Dialog, extension manager, notification, running tabs \n 3.Use toolkit tree view for all tree view: table of content, debugger variables and running tabs\n 4.Use toolkit for the settings editor\n 5.Add icon component to the toolkit\n 6.Use toolkit icon for LabIcon\n 7.Add window split component to the toolkit\n 8.Add tree grid component to the toolkit\n 9.Add dock panel to the toolkit\n10.Explore switching default renderer in lumino by the toolkit:\n a.Menu\n b.Tab panel\n c.Dock Panel\nI am committed to collaborating closely with my mentor, @Frédéric Collonval, to tackle these challenges efficiently and deliver tangible results within the stipulated timeframe of the Google Summer of Code program.",
          "difficulty": null,
          "id": "proj_numfocus_2024_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/dT0khoRP/",
          "proposal_id": null,
          "short_description": "The UI Toolkit serves as a component library tailored for crafting web interfaces within the Jupyter ecosystem, encompassing platforms such as...",
          "slug": "improve-user-experience-using-the-jupyter-toolkit",
          "status": "completed",
          "student_name": "Mehak Jain",
          "student_profile": null,
          "tags": [
            "web",
            "api",
            "ai",
            "ui"
          ],
          "title": "Improve user experience using the Jupyter toolkit"
        },
        {
          "code_url": "https://gist.github.com/HarshvirSandhu/5003741ae50575ab5d1ee04027518d3e",
          "description": "PyTensor is a Python library that allows you to define, optimize/rewrite, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. It is based on Theano and integrates with NumPy, C/JAX/Numba, and has a tight API documentation.\nThe project aims to integrate PyTorch as a new backend for PyMC, this would bridge the gap between the PyTorch and PyMC ecosystems. This integration will provide users with access to GPU hardware, enhance performance. \nKey deliverables include implementing a PyTorch Linker, creating dispatch functions for type conversion, and adding support for linear algebra, element-wise, and sparse operations in PyTorch. The goal is to establish a foundation for future contributions and foster community engagement, ultimately improving the accessibility and functionality of PyMC within the PyTorch ecosystem.",
          "difficulty": null,
          "id": "proj_numfocus_2024_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/Wr8mzd8o/",
          "proposal_id": null,
          "short_description": "PyTensor is a Python library that allows you to define, optimize/rewrite, and evaluate mathematical expressions involving multi-dimensional arrays...",
          "slug": "pymc-add-pytorch-backend-to-pytensor",
          "status": "completed",
          "student_name": "Harshvir Sandhu",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai",
            "backend"
          ],
          "title": "PyMC - Add PyTorch backend to PyTensor"
        },
        {
          "code_url": "https://gist.github.com/rohanbabbar04/903972740663fe46b5a6cd4a62e264e5",
          "description": "PreliZ is a Python package aimed at helping practitioners choose prior distributions by offering a set of tools for various facets of prior elicitation. The main objective of this project is to expand these features and make them more robust, transforming PreliZ into a tool that easily integrates with other libraries such as PyMC, Bambi, and PyStan, while remaining agnostic to Probability Programming Languages (PPLs). The key outcomes of this project include generalizing Bambi's parsers, integrating PyMC for interoperability, establishing a common infrastructure for future PPLs, extending the `predictive_explorer` function to handle multiple inputs and outputs from various PPLs for comprehensive prior predictive distribution plotting, enhancing the `ppa` function to support models from PreliZ, PyMC, or Bambi for interactive prior updates, and improving the handling of PyMC models within PreliZ's `ppe` function while extending support to PreliZ and Bambi models.",
          "difficulty": null,
          "id": "proj_numfocus_2024_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/lBtIkPJ4/",
          "proposal_id": null,
          "short_description": "PreliZ is a Python package aimed at helping practitioners choose prior distributions by offering a set of tools for various facets of prior...",
          "slug": "arviz-prior-elicitation",
          "status": "completed",
          "student_name": "Rohan Babbar",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "ArviZ: Prior Elicitation"
        },
        {
          "code_url": "https://pybamm.org/gsoc/2024/ankit-meda/",
          "description": "This project aims to enhance PyBaMM's packaging infrastructure by migrating from setuptools and wheel to scikit-build-core, providing improved control, flexibility, and compatibility. \n\nKey goals include optimizing build performance and reducing dependency-related issues. Additionally, the project targets transitioning to the manylinux_2_28 standard for building wheels to align with evolving Python tooling standards and leveraging testing infrastructure, such as the pybamm.test() API ensures thorough testing of built wheels.",
          "difficulty": null,
          "id": "proj_numfocus_2024_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/YyLzWWqr/",
          "proposal_id": null,
          "short_description": "This project aims to enhance PyBaMM's packaging infrastructure by migrating from setuptools and wheel to scikit-build-core, providing improved...",
          "slug": "pybamm-migrate-to-scikit-build-core",
          "status": "completed",
          "student_name": "Ankit Meda",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai",
            "ui",
            "ux"
          ],
          "title": "PyBaMM - Migrate to scikit-build-core"
        },
        {
          "code_url": "https://docs.google.com/document/d/1R_9bY0G2UsjEfvYxcHxUv9WV4zNeX5yP9YOy-o6ruyk/edit?usp=sharing",
          "description": "Time series clustering involves grouping similar time series data together based on specific features or patterns. Deep learning algorithms have become increasingly popular for clustering. However, the aeon's deep clustering module currently lacks several deep learning-based algorithms. In this project the aim is to implement some of the top performing and interesting algorithms from a recent comparison of deep learning for time series clustering and benchmark them. This project includes further developing the aeon deep learning networks module, making the package publicly documented for user to explore and well tested to help the maintenance of the deep learning implemented in the future.",
          "difficulty": null,
          "id": "proj_numfocus_2024_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/Hvd0DfkD/",
          "proposal_id": null,
          "short_description": "Time series clustering involves grouping similar time series data together based on specific features or patterns. Deep learning algorithms have...",
          "slug": "aeon-developing-deep-learning-framework-and-implementations-for-time-series-clustering",
          "status": "completed",
          "student_name": "Aadya Chinubhai",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "aeon - Developing Deep Learning Framework and Implementations for Time Series Clustering"
        },
        {
          "code_url": "https://github.com/pvlib/pvlib-python/issues/2065",
          "description": "Accounting for spectral effects in photovoltaic (PV) performance models is critical for accurate and reliable performance forecasts. Variation in the solar spectral distribution changes the useful fraction of irradiance incident on a PV device, and thus can increase or decrease its performance. The relationship between the performance of a PV module and the solar spectrum is captured by a “spectral correction function” (SCF), a plethora of which have been published in the literature over the last quarter of a century. However, only a fraction of these published models are available in pvlib. The aim of this project is to implement new SCFs in pvlib and develop examples to guide users in applying these models. The implementation of these new models will strengthen pvlib through enhancing its flexibility, accuracy, and reliability for different modelling scenarios. Furthermore, the additions to the example gallery will increase the accessibility and usability of these models and pvlib as a whole, in particular for new users.",
          "difficulty": null,
          "id": "proj_numfocus_2024_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/TT5QrYqT/",
          "proposal_id": null,
          "short_description": "Accounting for spectral effects in photovoltaic (PV) performance models is critical for accurate and reliable performance forecasts. Variation in the...",
          "slug": "enhancing-solar-energy-modelling-implementing-new-spectral-corrections-in-pvlib-python",
          "status": "completed",
          "student_name": "Dax",
          "student_profile": null,
          "tags": [
            "python",
            "ios",
            "ai",
            "ui"
          ],
          "title": "Enhancing solar energy modelling: implementing new spectral corrections in pvlib python"
        },
        {
          "code_url": "https://gist.github.com/PatriceJada/3f9655f73709d24a6e72c1045837e844",
          "description": "This proposal outlines a project aimed at enhancing the security posture of NumFOCUS affiliate projects by implementing the OSSF Scorecard action and remediating scores across multiple projects. The project will focus on integrating continuous fuzzing using Google's OSS-Fuzz, automating builds and releases, integrating build provenance, implementing signing processes, and enhancing reproducibility. It will target several NumFOCUS projects identified as requiring these enhancements, including aeon-toolkit, pymc, deepforest, retriever, jupyterlab, and spyder.",
          "difficulty": null,
          "id": "proj_numfocus_2024_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/aCyIEbWA/",
          "proposal_id": null,
          "short_description": "This proposal outlines a project aimed at enhancing the security posture of NumFOCUS affiliate projects by implementing the OSSF Scorecard action and...",
          "slug": "gosst-implement-ossf-scorecard-action-and-remediating-score-across-multiple-numfocus-projects",
          "status": "completed",
          "student_name": "Patrice",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "GOSST: Implement OSSF Scorecard Action and Remediating  Score Across Multiple NumFOCUS Projects"
        },
        {
          "code_url": "https://gist.github.com/LegionAtol/3389c65aaa88928ab9191a319e4a7b34",
          "description": "The Gradient Ascent Pulse Engineering (GRAPE) algorithm has been implemented in QuTiP, facilitating a model-based approach to quantum optimal control. This project seeks to augment QuTiP's capabilities by leveraging advanced machine learning techniques, including reinforcement learning and deep learning, trying to obtain better control signals to minimize the cost function (such as fidelity).\r\nThe project will begin with an in-depth review of the latest scientific literature to define the state of the art in applying machine learning to quantum optimal control.\r\nBased on this research, I will develop one or more ML or RL models, drawing inspiration from successful implementations in related domains. These models will be integrated with the QuTiP packages, ensuring both compatibility and ease of use. Practically, this will allow users to select their preferred method of resolution when setting up the quantum control optimization problem. Additionally, I will produce documentation and examples to guide users in effectively utilizing these new features.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2024_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/ylzSM2QC/",
          "proposal_id": null,
          "short_description": "The Gradient Ascent Pulse Engineering (GRAPE) algorithm has been implemented in QuTiP, facilitating a model-based approach to quantum optimal...",
          "slug": "control-ml-optimization",
          "status": "completed",
          "student_name": "AlessioParato",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "Control ML Optimization"
        },
        {
          "code_url": "https://gist.github.com/Kishan-Ved/ebe0a971220d67517ae815e4f92d2459",
          "description": "PyDataStructs aims to be a Python package for various data structures and algorithms (including their parallel implementations). My project involves adding a C++ backend for tree data structures and their algorithms available in PyDataStructs. This will be linked to the Python frontend via Python C-API. The user will have an option to run algorithms in this C++ backend, by simply passing a backend parameter to the existing Python functions. This will greatly enhance the computation speed, making it extremely valuable for scientific computing and high-performance applications. I will test my implementations against the existing Python testcases to ensure that they are fully compatible with the Python frontend.",
          "difficulty": null,
          "id": "proj_numfocus_2024_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/2nrxEFTg/",
          "proposal_id": null,
          "short_description": "PyDataStructs aims to be a Python package for various data structures and algorithms (including their parallel implementations). My project involves...",
          "slug": "open-science-labs-pydatastructs-add-a-c-backend-for-tree-data-structures-and-their-algorithms",
          "status": "completed",
          "student_name": "Kishan Ved",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai",
            "frontend",
            "backend"
          ],
          "title": "Open Science Labs: PyDataStructs: Add a C++ Backend for tree data structures and their algorithms"
        },
        {
          "code_url": "https://docs.google.com/document/d/1H_2ZiKekr9VPaVgawmOwZLuGtwYapmCAbKJrhJsIBZw/edit?usp=sharing",
          "description": "This project would integrate the current state-of-the-art 3D reconstruction method in computer graphics namely \"Gaussian splatting\" with existing rendering systems in CB-Geo MPM to enable simulations from videos using the Material Point Method.  It\nwill enable video data from real-world phenomena such as landslides to be transformed directly into simulations. This project will make use of Gaussian splatting to extract 3D graphics primitives from videos. These primitives will then undergo simulation through the Material Point Method. Hence the project will involve adding support for Gaussian Splatting as well as support for MPM simulations on obtained splats/particles/primitives. Another very interesting research aspect explored in this project was deriving material properties such as young modulus, friction angle etc. by leveraging JAX's differentiability. This leads to deriving material properties from just videos!",
          "difficulty": null,
          "id": "proj_numfocus_2024_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/oSmAfyRO/",
          "proposal_id": null,
          "short_description": "This project would integrate the current state-of-the-art 3D reconstruction method in computer graphics namely \"Gaussian splatting\" with existing...",
          "slug": "cb-geompm-3d-gaussian-splat-to-enable-physics-driven-mpm-simulations-from-videos",
          "status": "completed",
          "student_name": "RaghavAgarwal",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "CB-GeoMPM: 3D Gaussian Splat to enable Physics-Driven MPM Simulations from Videos"
        },
        {
          "code_url": "https://gist.github.com/tanish1729/7ea3964b0740e8c2ef559a47dd394ee3",
          "description": "PyMC uses PyTensor as its computational backend, which allows efficient optimisation, rewrites and evaluation of mathematical operations. Using a recently introduced framework (CoLa- Compositional Linear Algebra), we identify a lot of algebraic simplifications and implement them as graph rewrites. As a result, we would be speeding up multiple model families in PyMC, such as Time Series, State-Space models and Gaussian Processes. The goal is to simplify efforts in implementations while achieving a\nhigh degree of computational efficiency",
          "difficulty": null,
          "id": "proj_numfocus_2024_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/KqLF8xKs/",
          "proposal_id": null,
          "short_description": "PyMC uses PyTensor as its computational backend, which allows efficient optimisation, rewrites and evaluation of mathematical operations. Using a...",
          "slug": "pymc-improve-pytensor-linear-algebra-support-using-graph-rewrites",
          "status": "completed",
          "student_name": "Tanish Taneja",
          "student_profile": null,
          "tags": [
            "ai",
            "backend"
          ],
          "title": "PyMC - Improve PyTensor linear algebra support using graph rewrites"
        },
        {
          "code_url": "https://github.com/jupyterlab/frontends-team-compass/wiki/GSoC-2024-Submission-%E2%80%90-Make-plugin-system-data-based",
          "description": "The JupyterLab application relies heavily on plugins sourced from the Lumino project. Currently, all plugins load at startup, significantly increasing load time. The proposed solution is to enhance the extension configuration to incorporate entrypoints, akin to how VS Code manages extensions. This configuration will dictate when to load an extension based on various triggers, ultimately improving performance. Introducing main and side panel changes without manual coding will further optimize performance.",
          "difficulty": null,
          "id": "proj_numfocus_2024_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/fL6zttzm/",
          "proposal_id": null,
          "short_description": "The JupyterLab application relies heavily on plugins sourced from the Lumino project. Currently, all plugins load at startup, significantly...",
          "slug": "make-the-plugin-system-data-based",
          "status": "completed",
          "student_name": "Ashok Kumar Choudhary",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Make the Plugin System Data-Based"
        },
        {
          "code_url": "https://github.com/ampdes/gsoc24",
          "description": "Large scale simulation of scientific and engineering problems requires\nhigh performance and distributed memory systems. Computing resources and\ntime are not unlimited and efficient usage of the computing resources\ncalls for scalable and flexible checkpointing which is the ability to\nstart, pause and resume simulations, thus saving energy consumption and\nmoney.\n\nFEniCS is a popular open-source computing platform for solving partial\ndifferential equations (PDEs) with the finite element method (FEM). For\nthe latest version of FEniCS project known as\nDOLFINx,\nADIOS4DOLFINx is a\nprototype checkpointing framework that implements several variations of checkpointing using the state of\nthe art *The Adaptable Input Output (I/O) System* called\nADIOS2.\n\nNow, there is a need for implementing checkpointing functionality as a\ncore feature of the DOLFINx. Since DOLFINx is a C++ library with a\nPython wrapper, this feature is implemented in C++ with appropriate APIs\nexposed to the python user using nanobind.",
          "difficulty": null,
          "id": "proj_numfocus_2024_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/6cJYjFC7/",
          "proposal_id": null,
          "short_description": "Large scale simulation of scientific and engineering problems requires high performance and distributed memory systems. Computing resources and time...",
          "slug": "checkpointing-in-dolfinx-using-adios2",
          "status": "completed",
          "student_name": "amujahid",
          "student_profile": null,
          "tags": [
            "python",
            "ios",
            "api",
            "ui"
          ],
          "title": "Checkpointing in DOLFINx using ADIOS2"
        },
        {
          "code_url": "https://docs.google.com/document/d/1t7mZNv2f_8BjUGpfSOyNhtpCgUHTboP5VpRbrPII-nU/edit?usp=sharing",
          "description": "Expanded and enhanced the nx-parallel project, a newly developed parallel backend for NetworkX utilizing joblib to parallelize graph algorithms. Key accomplishments include integrating NetworkX’s and joblib’s configuration systems into nx-parallel, switching the build tool from hatchling to setuptools, automating backend metadata updation through a pre-commit hook, enhancing and improving existing parallel graph algorithms by implementing chunking mechanisms, providing custom chunking capabilities for all algorithms, and centralizing testing frameworks. Also accomplished various enhancement and maintenance goals, such as improving algorithm performance, added new functionalities, error-free initialization for the `ParallelGraph` class and built a more comprehensive and improved README and a Contributor's guide. Beyond the proposed GSoC proposal, created a conda-forge feedstock for nx-parallel to enhance accessibility. My work also involved engaging with the NetworkX community, reviewing pull requests, and presenting talks and posters at various conferences/meet-ups. All the development workflow is well-documented in 8 GSoC Blogs written every 2 weeks during the project duration. Towards the end, I wrapped up my work by creating various issues discussing the future directions nx-parallel can go and features and functionalities nx-parallel can have. Refer the full final work product report and the initial proposal to know more and do check out the ideas in the \"Experimental and more\" section of the proposal that could be played around with, if you want to continue the work!",
          "difficulty": null,
          "id": "proj_numfocus_2024_018",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/78MjHdc8/",
          "proposal_id": null,
          "short_description": "Expanded and enhanced the nx-parallel project, a newly developed parallel backend for NetworkX utilizing joblib to parallelize graph algorithms. Key...",
          "slug": "networkx-revisiting-and-expanding-nx-parallel",
          "status": "completed",
          "student_name": "Aditi Juneja",
          "student_profile": null,
          "tags": [
            "ai",
            "ui",
            "backend"
          ],
          "title": "NetworkX: Revisiting and expanding nx-parallel"
        },
        {
          "code_url": "https://gist.github.com/griegner/c414f77d957dea73b84dcd80d580b602",
          "description": "Develop aeon-neuro to provide structured tools for machine learning from neural data. This project will focus on implementing algorithms for EEG classification by building on the multivariate classification algorithms outlined in Rushbrooke 2023. This paper demonstrates that existing time series models implemented in aeon can successfully classify patients from healthy individuals using frequency domain features alone, eliminating the need for detailed time domain feature selection. In addition to applying existing machine learning models to EEG datasets, we will further develop aeon-neuro to be more accessible to the scientific research community by interfacing it with existing data formatting standards (BIDs) and EEG analysis libraries (MNE). Alongside these primary outcomes, we will adhere to best practices in research software development, including writing well-test code, consistent documentation, and user-facing examples/notebooks.",
          "difficulty": null,
          "id": "proj_numfocus_2024_019",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/htrPCGOM/",
          "proposal_id": null,
          "short_description": "Develop aeon-neuro to provide structured tools for machine learning from neural data. This project will focus on implementing algorithms for EEG...",
          "slug": "aeon-machine-learning-from-eeg-with-aeon-neuro",
          "status": "completed",
          "student_name": "griegner",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "aeon - Machine learning from EEG with aeon-neuro"
        },
        {
          "code_url": "https://gist.github.com/JoshuaGlaZ/acca2c1649ba1b828a41e75a24076b71",
          "description": "This project focuses on extending the noWorkflow scientific workflow library by introducing new features that enhance its ability to analyze experiment reproducibility, particularly through the use of Abstract Syntax Trees (ASTs). noWorkflow is a library that tracks the lineage of data from its origin to its current state in experiment trials. While it effectively captures trial data, its existing methods for comparing these trials and evaluating reproducibility are limited.\n\nTo address these limitations, this project implements a method for generating the trial’s AST from noWorkflow's provenance data, providing a more precise representation of the code structure. This method allows users to gain deeper insights into how code evolves and interacts over time and offers flexibility through command line or visualization tools. Additionally, a new feature is introduced to visualize the definition of a trial, providing a comprehensive view of the trial's code components and their relationships. These enhancements collectively boost noWorkflow’s functionality, making it a more powerful tool for analyzing and ensuring reproducibility in scientific workflows, and strengthening confidence in experimental outcomes.",
          "difficulty": null,
          "id": "proj_numfocus_2024_020",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/RzA1qtu0/",
          "proposal_id": null,
          "short_description": "This project focuses on extending the noWorkflow scientific workflow library by introducing new features that enhance its ability to analyze...",
          "slug": "open-science-labs-noworkflow-verify-the-reproducibility-of-an-experiment",
          "status": "completed",
          "student_name": "Joshua Talahatu",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Open Science Labs | noWorkFlow: Verify the reproducibility of an experiment"
        },
        {
          "code_url": "https://trygvrad.github.io/gsoc-2024-bivariate-colormaps-summary/",
          "description": "Multivariate data visualization is useful when grappling with correlated data that naturally arises in a number of scientific fields, such as polarization microscopy, hyperspectral astronomy, various X-ray imaging techniques, geographical data, etc. While specialized and/or commercial tools exist in some of these disciplines, implementing support for multivariate color mapping in matplotlib would provide a unified framework and expand access across the various use cases. This feature has been proposed multiple times, but implementation is non-trivial as it affects the low-level classes that handle data normalization. A discussion on GitHub led me to develop a solution where the class ScalarMappable is replaced by VectorMappable. I have already demonstrated the feasibility of this approach, and developed a working implementation, including a test suite for the new functionality. This project aims to finish this implementation by creating tutorials, examples, and presenting color maps for various use cases. Additionally, tests, docstrings, variable names, and code organization must be updated to conform to the quality standards of matplotlib.",
          "difficulty": null,
          "id": "proj_numfocus_2024_021",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/oEBt7vSe/",
          "proposal_id": null,
          "short_description": "Multivariate data visualization is useful when grappling with correlated data that naturally arises in a number of scientific fields, such as...",
          "slug": "bivariate-colormaps",
          "status": "completed",
          "student_name": "trygvrad",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Bivariate Colormaps"
        },
        {
          "code_url": "https://gadhvirushiraj.github.io/gsoc24/posts/final-report/",
          "description": "The project aims to improve the quantum circuit visualization capabilities of QuTiP-QIP by introducing a new framework for circuit rendering that doesn't rely on external dependencies. Presently, circuit visualization relies on LaTeX and ImageMagick, which can be problematic for users. This solution plans to create two rendering modules: one utilizing matplotlib for visually appealing and precise quantum circuit diagrams, and another ASCII text-based rendering. The matplotlib renderer will also support generating circuit visualizations within IPython environments like Jupyter Notebook, while the text-based renderer will cater to command-line interactions. Apart from the rendering modules a Circuit Renderer Selector will also be included in the project deliverables, enabling users to easily choose their preferred rendering method among LaTeX, Matplotlib, or Text-Based options. These tools will enable users to visualize quantum circuits more efficiently and effectively, making it easier to work with QuTiP.",
          "difficulty": null,
          "id": "proj_numfocus_2024_022",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/93Y1TKO6/",
          "proposal_id": null,
          "short_description": "The project aims to improve the quantum circuit visualization capabilities of QuTiP-QIP by introducing a new framework for circuit rendering that...",
          "slug": "qutip-enhanced-quantum-circuit-diagrams",
          "status": "completed",
          "student_name": "Rushiraj Gadhvi",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "QuTiP: Enhanced Quantum Circuit Diagrams"
        },
        {
          "code_url": "https://gist.github.com/aphc14/26be43eb6cd71682a673f1baba22e482",
          "description": "I propose the implementation of the Pathfinder algorithm for variational inference in PyMC. The Pathfinder algorithm is a recent advancement in the field of approximate Bayesian inference, offering a scalable and efficient approach for approximating posterior distributions. Integrating this algorithm into PyMC, a popular probabilistic programming library, would provide users with a powerful tool for conducting Bayesian inference on complex models. The Pathfinder algorithm's ability to handle high-dimensional parameter spaces and large datasets makes it particularly well-suited for applications where traditional Markov chain Monte Carlo methods may be computationally expensive or impractical. This addition to PyMC would enhance its capabilities, making it more versatile and accessible for a broader range of Bayesian modeling scenarios.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2024_023",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/XrU6u7kZ/",
          "proposal_id": null,
          "short_description": "I propose the implementation of the Pathfinder algorithm for variational inference in PyMC. The Pathfinder algorithm is a recent advancement in the...",
          "slug": "pathfinder-variational-inference",
          "status": "completed",
          "student_name": "mcao",
          "student_profile": null,
          "tags": [
            "ios",
            "ai",
            "ui"
          ],
          "title": "Pathfinder Variational Inference"
        },
        {
          "code_url": "https://pybamm.org/gsoc/2024/santhosh-sundaram/",
          "description": "The project aims to build and publish python-cookiecutter templates for new PyBaMM-based projects. It is designed to simplify the setup process of the development environment for researchers and scientists interested in utilizing PyBaMM for battery modeling who may lack familiarity with managing Python environments or repositories.\nThe project intends to enhance the accessibility and usability of PyBaMM for newbies and experienced users alike. Providing a standardized template with best practices and automation tools would lower the barrier to entry for adopting PyBaMM in battery modeling projects. This would in turn make battery modeling more accessible, efficient, and collaborative for the research community. The project also intends to implement \"Model entry points'', allowing community contributors to create and share models of their repositories using the cookiecutter template without directly adding them upstream. This would not only let community contributors retain ownership and choose license terms but also grant flexibility to the PyBaMM team in supporting models, Including all of GitHub's functionality and infrastructure contained within the template.",
          "difficulty": null,
          "id": "proj_numfocus_2024_024",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/eU9Jznmr/",
          "proposal_id": null,
          "short_description": "The project aims to build and publish python-cookiecutter templates for new PyBaMM-based projects. It is designed to simplify the setup process of...",
          "slug": "build-and-publish-pybamm-cookiecutter-as-a-template-for-new-pybamm-based-projects",
          "status": "completed",
          "student_name": "Santhosh Sundaram",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Build and publish PyBaMM-cookiecutter as a template for new PyBaMM-based projects"
        },
        {
          "code_url": "https://schnellerhase.github.io/en/posts/2024/gsoc/",
          "description": "Multigrid methods shape the method of choice when a self containing family of triangulations of a FEM discretization is at hand to achieve an optimal order solver. Optimal order meaning linear complexity in the number of DOFs, which is the same for the assembly of the associated linear system of equations, making this a completely astonishing and non-trivial result of the theory of multigrid methods.\n    \nBut also in applications this outperforms classical, algebraic based, solver routines when it comes to large scale simulations. Although, the flexibility of modern AMG implementations to not require any such structure of meshes, multirgrid methods remain of great interest not only in academia. So an implementation in the dolfinx framework should allow for versatile extensions and applications.\n\nTo achieve this, multiple components of data structure associated with mesh, geoemtry and topology require close analysis and a fundamentally new feature, the necessary prolongation and restriction operators, need to be implemented. This process is split into multiple isolated, but chronologically dependent phases.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2024_025",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/YhEwl8iB/",
          "proposal_id": null,
          "short_description": "Multigrid methods shape the method of choice when a self containing family of triangulations of a FEM discretization is at hand to achieve an optimal...",
          "slug": "multigrid-for-fenicsx",
          "status": "completed",
          "student_name": "Paul Kühner",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Multigrid for FEniCSx"
        },
        {
          "code_url": "https://muhammed-magdy.hashnode.dev/my-gsoc-adventure-from-data-to-detection",
          "description": "DeepForest is a library for training and deploying deep learning models for forestry tasks.\nThe library is built on top of the PyTorch deep learning framework and supports custom model architectures and loss functions, allowing users to create and train their models. It also supports multi-label classification, enabling the detection and classification of multiple tree species within the same image.\nThe project I want to participate in is the Advancing Bird Detection and Classification in Hand-Held Airborne Imagery project and the goals are:\n\n1 - A refined and optimized deepforest model for accurate bird detection and classification in hand-held plane imagery.\n2 - An annotated dataset for training and testing, contributing to the improvement of the model's performance.\n3 - Comparative analysis of bird count accuracy by species, providing valuable insights into the model's effectiveness.",
          "difficulty": null,
          "id": "proj_numfocus_2024_026",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/RKvEGjbd/",
          "proposal_id": null,
          "short_description": "DeepForest is a library for training and deploying deep learning models for forestry tasks. The library is built on top of the PyTorch deep learning...",
          "slug": "data-retriever-advancing-bird-detection-and-classification-in-hand-held-airborne-imagery",
          "status": "completed",
          "student_name": "Muhammed Magdy",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Data Retriever - Advancing Bird Detection and Classification in Hand-Held Airborne Imagery"
        },
        {
          "code_url": "https://github.com/pvlib/pvlib-python/issues/2068",
          "description": "Accurate modeling of cell temperature is essential for estimating the performance of PV systems. However, very few models exist for calculating cell temperature for floating PV systems, and none of the existing models are available in open-source or commercial software. This project aims to extend pvlib python’s capabilities in modeling floating PV systems by adding functions for calculating cell temperature and ambient conditions. \n\nThe following will be added to pvlib:\n- Lindholm model for calculating PV cell temperature\n- Albedo and wind speed functions\n- Rahaman thermal model for calculating the PV cell temperature\n- Gallery example of the expansion of the Faiman expression for floating PV heat loss coefficients\n\nSuch development will strengthen the pvlib package and enable more accurate modeling of floating PV.",
          "difficulty": null,
          "id": "proj_numfocus_2024_027",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/Z32UN1Qx/",
          "proposal_id": null,
          "short_description": "Accurate modeling of cell temperature is essential for estimating the performance of PV systems. However, very few models exist for calculating cell...",
          "slug": "floating-solar-enabling-modeling-of-floating-pv-with-pvlib",
          "status": "completed",
          "student_name": "Ioannis Sifnaios",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "Floating Solar - Enabling modeling of floating PV with pvlib"
        },
        {
          "code_url": "https://prady0t.github.io/My-Blog/posts/gsoc-final/",
          "description": "Goal of this project is to improve PyBaMM's test suite by migrating from Unittest to Pytest. This would include but is not limited to : rewriting all it's test from unittest style tests to pytest, integrating various pytest's plugins for better test results, using \"hypothesis\" to implement property-based testing, creating test suite for packaging infrastructure, updating noxfiles, updating CI jobs, etc. \nThis would lead to a much faster tests, better coverage and enhanced test results. Well documenting this projects can help benefit other projects with similar migrations.",
          "difficulty": null,
          "id": "proj_numfocus_2024_028",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/gnFfAnqb/",
          "proposal_id": null,
          "short_description": "Goal of this project is to improve PyBaMM's test suite by migrating from Unittest to Pytest. This would include but is not limited to : rewriting all...",
          "slug": "improve-pybamms-testing-infrastructure",
          "status": "completed",
          "student_name": "prady0t",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Improve PyBaMM's testing infrastructure."
        },
        {
          "code_url": "https://github.com/fverdugo/PartitionedArrays.jl/pull/167",
          "description": "Algebraic multigrid (AMG) methods are one of the most popular techniques to solve systems of linear equations in structural mechanics. Parallel AMGs are widely used to solve large systems of equations on supercomputers or high performance clusters. Despite their significance, there is yet no parallel implementation of general AMG solvers available in pure Julia. This project aims at extending the existing implementation for scalar AMGs in the PartitionedArrays.jl package by a general AMG solver that can be applied to vector-valued problems with arbitrary near null spaces, such as the linear elasticity model. \n\n\nThe project goals have been developed in collaboration with the Gridap organization’s mentor, Francesc Verdugo, and they consist of the full implementation of a parallelized version of a smoothed aggregation AMG method, including the provision of relevant tests and extension of the documentation with a tutorial and method descriptions. Further deliverables are bi-weekly posts in a social media platform and a small tutorial on how to use PartitionedArrays.jl.",
          "difficulty": null,
          "id": "proj_numfocus_2024_029",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/th3mATRB/",
          "proposal_id": null,
          "short_description": "Algebraic multigrid (AMG) methods are one of the most popular techniques to solve systems of linear equations in structural mechanics. Parallel AMGs...",
          "slug": "parallel-algebraic-multigrid-for-structural-mechanics-in-julia-with-partitionedarraysjl",
          "status": "completed",
          "student_name": "Gelieza Kötterheinrich",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Parallel Algebraic Multigrid for Structural Mechanics in Julia with PartitionedArrays.jl"
        },
        {
          "code_url": "https://github.com/jupyterlab/jupyterlab-builder/blob/main/README.md",
          "description": "The builder tooling of JupyterLab is directly integrated in the core codebase. This causes maintenance to become a burden for both core developers and extension creators. Reusability of  the builder’s functionality is also constrained. To tackle this problem I propose to extract and refactor the builder tooling into a separate well defined package. Thus a new command line interface will be created with a wide range of features and functionalities, apart from its primitive purpose.",
          "difficulty": null,
          "id": "proj_numfocus_2024_030",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/YMB3Rc53/",
          "proposal_id": null,
          "short_description": "The builder tooling of JupyterLab is directly integrated in the core codebase. This causes maintenance to become a burden for both core developers...",
          "slug": "swiss-army-knife-builder-cli",
          "status": "completed",
          "student_name": "Ronan Coutinho",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Swiss Army Knife Builder CLI"
        },
        {
          "code_url": "https://github.com/pvlib/pvlib-python/issues/2064",
          "description": "This proposal aims to add a variety of scientific utilities to the pvlib python project that will focus on new models and research tools regarding shading and spectral effects. These improvements will contribute to expanding the current capabilities in simulating, analyzing, and researching photovoltaic systems.\nThe proposed improvements are comprised of a shading losses model with an example of row to row trackers shading example; a variety of utilities for researching and estimating spectral mismatch losses; a non-uniform irradiance mismatch losses model, and models for Photosynthetically Active Radiation (PAR). These last models would be used in agrivoltaics, the integration of photovoltaic systems in crops.\nFurther details and references can be found in the Proposal PDF file.",
          "difficulty": null,
          "id": "proj_numfocus_2024_031",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/fxPFQqZc/",
          "proposal_id": null,
          "short_description": "This proposal aims to add a variety of scientific utilities to the pvlib python project that will focus on new models and research tools regarding...",
          "slug": "pvlib-python-improvements-on-shading-and-spectral-research-and-modeling",
          "status": "completed",
          "student_name": "Echedey Luis",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "pvlib python improvements on shading and spectral research and modeling"
        },
        {
          "code_url": "https://ayushinav.github.io/blog/2024/gsoc24/",
          "description": "NeuralPDE.jl is a high performance Julia package to solve differential equations using neural networks. This proposal aims to improve the sampling framework in the package to include user generated symbolic loss functions, add Neural Tangent Kernel adaptive loss function for improved training and add Deep-Ritz method to solve high dimensional second order PDEs to the package. The proposal also aims to expand the codebase of the LuxNeuralOperators.jl to include high performance codes for Fourier Neural Operators, Markov Neural Operators, DeepONets and other operator learning schemes and perform benchmark tests to the package.",
          "difficulty": null,
          "id": "proj_numfocus_2024_032",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/tzIHpdbD/",
          "proposal_id": null,
          "short_description": "NeuralPDE.jl is a high performance Julia package to solve differential equations using neural networks. This proposal aims to improve the sampling...",
          "slug": "feature-enhacments-in-neuralpdejl-and-luxneuraloperatorsjl",
          "status": "completed",
          "student_name": "Abhinav Pratap Singh",
          "student_profile": null,
          "tags": [
            "ai",
            "ux"
          ],
          "title": "Feature enhacments in NeuralPDE.jl and LuxNeuralOperators.jl"
        },
        {
          "code_url": "https://gist.github.com/itsdivya1309/4a12a00ba459dd57165bd07ae43a9afb",
          "description": "This project will implement and benchmark the Proximity Forest Algorithm for Time Series Classification in aeon. With the ever-increasing data, the applications of time series classification are also increasing. Hence, we need classification algorithms that are both efficient and scalable. The Proximity Forest Algorithm is the current state-of-the-art distance-based classifier that creates an ensemble of decision trees, where the splits are based on the similarity between time series measured using various parameterised distance measures. \nCurrently, a version of Proximity Forest which can match the performance of the original implementation has not been implemented in Python. This project aims to implement Proximity Forest in aeon for the classification of univariate time series datasets of equal length and make it accessible for a greater variety of users. The implementation will be benchmarked on the UCR archive to match the results of the original Java implementation in terms of run time and accuracy.",
          "difficulty": null,
          "id": "proj_numfocus_2024_033",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/8TYGhJjy/",
          "proposal_id": null,
          "short_description": "This project will implement and benchmark the Proximity Forest Algorithm for Time Series Classification in aeon. With the ever-increasing data, the...",
          "slug": "aeon-implement-proximity-forest-for-time-series-classification",
          "status": "completed",
          "student_name": "Divya Tiwari",
          "student_profile": null,
          "tags": [
            "python",
            "java",
            "ai"
          ],
          "title": "aeon - Implement Proximity Forest for Time Series Classification"
        },
        {
          "code_url": "https://small-hardhat-133.notion.site/My-Journey-with-QuTiP-and-JAX-Google-Summer-of-Code-fffe7b50d46e80d88de8fea6f34b5361",
          "description": "The project aims to seamlessly integrate JAX's jit and auto-differentiation functionalities into QuTiP, a quantum computing simulation library, enhancing its computational capabilities. Deliverables include cataloging JAX support in QuTiP functions, adding JAX functionality with clear documentation, designing interfaces for smooth integration, and creating example notebooks for practical usage. Emphasizing advanced applications and user-friendly interfaces, the project prioritizes example notebooks demonstrating quantum control optimization tasks, along with intuitive interface designs like decorator-based integration and hybrid solvers. This project not only improves QuTiP's efficiency but also serves as an educational resource, showcasing the synergy between cutting-edge quantum computing and machine learning techniques.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2024_034",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/5fsiLIJm/",
          "proposal_id": null,
          "short_description": "The project aims to seamlessly integrate JAX's jit and auto-differentiation functionalities into QuTiP, a quantum computing simulation library,...",
          "slug": "qutip-project-integrating-auto-differentiation-with-qutip-solvers-using-jax",
          "status": "completed",
          "student_name": "ragarwal00",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "QuTiP Project: Integrating Auto-differentiation with QuTiP Solvers Using JAX"
        },
        {
          "code_url": "https://github.com/sakshamdhuria/researchPractice/tree/main/WorkStealingChaseLevDeque",
          "description": "Our project aims to enhance Taskflow's work-stealing scheduler by implementing a worker-specific notification module. This will provide finer control over task execution in parallel computing applications. We'll extend the module, conduct thorough testing, evaluate performance, and integrate the solution into Taskflow.",
          "difficulty": null,
          "id": "proj_numfocus_2024_035",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/archive/2024/projects/rA2ux1oS/",
          "proposal_id": null,
          "short_description": "Our project aims to enhance Taskflow's work-stealing scheduler by implementing a worker-specific notification module. This will provide finer control...",
          "slug": "taskflows-worker-specific-notification-module",
          "status": "completed",
          "student_name": "saksham12321",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Taskflow's Worker Specific Notification Module"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/archive/2024/organizations/numfocus/"
    },
    "year_2025": {
      "num_projects": 32,
      "projects": [
        {
          "code_url": null,
          "description": "sbi is an open-source Python package used for simulation-based inference. It provides an interface for running algorithms that are used to identify model parameters that are consistent with data. Currently, this project uses “stringly typed” values for its functions' arguments. Even though stringly typed code is flexible and easier to implement, it comes with a set of drawbacks. Using stringly typed code leads to a suboptimal developer experience with limited IDE support and subtle bugs that are hard to identify and fix. This project aims to improve the developer experience and mitigate these issues by updating arguments in functions to use strongly typed code. In addition, it plans to create a pattern for sbi contributors to follow when defining new functions and classes that would otherwise use stringly typed arguments.",
          "difficulty": null,
          "id": "proj_numfocus_2025_001",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/pPYqxGL6",
          "proposal_id": "QQlvQRzu",
          "short_description": "sbi is an open-source Python package used for simulation-based inference. It provides an interface for running algorithms that are used to identify...",
          "slug": "from-stringly-typed-to-strongly-typed-arguments-in-sbi",
          "status": "in-progress",
          "student_name": "Abel Abate",
          "student_profile": null,
          "tags": [
            "python",
            "ai"
          ],
          "title": "From \"Stringly Typed\" to \"Strongly Typed\" Arguments in sbi"
        },
        {
          "code_url": null,
          "description": "This project proposes the development of a reusable and extensible Hamiltonian Library within\nthe QuTiP framework. It aims to organize common quantum models (e.g., Jaynes-Cummings,\nRabi, Dicke, spin chains) into a well-structured library with a language-agnostic specification\nformat (e.g., JSON). The project will also provide a clean API for easy model instantiation and\nparameter manipulation, along with LaTeX and text-rendered output for documentation and\nvisualization.\nThe library will eliminate redundancy across tutorials and examples and empower users and\neducators to work more efficiently with pre-built, customizable quantum models. It will support\ntime-dependent and parameterized Hamiltonians, and serve as a bridge to other languages,\nsuch as Julia.",
          "difficulty": "beginner",
          "id": "proj_numfocus_2025_002",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/gTuguCKx",
          "proposal_id": "119M9W9I",
          "short_description": "This project proposes the development of a reusable and extensible Hamiltonian Library within the QuTiP framework. It aims to organize common quantum...",
          "slug": "qutip",
          "status": "in-progress",
          "student_name": "Akhil Pratap Singh",
          "student_profile": null,
          "tags": [
            "api",
            "ai",
            "ui"
          ],
          "title": "QuTiP"
        },
        {
          "code_url": null,
          "description": "This project aims to enhance the performance of the NetworkX library by parallelizing graph algorithms using the joblib backend in nx-parallel. Embarassingly parallel graph algorithms can become computationally intensive on large graphs which can be significantly reduced by running them on multiple CPU cores. The deliverables for this project include parallel implementations of embarassingly parallel algorithms like Triangles, Harmonic Centrality, Clustering Coefficient, Jaccard Coefficient, and  Average Neighbor Degree along with benchmarking and performance comparisons against their serial counterparts. Additionally, the project will focus on refining the existing heatmap timing script to maintain consistency across performance evaluations.",
          "difficulty": null,
          "id": "proj_numfocus_2025_003",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/GxfLMOTC",
          "proposal_id": "N9I4BYNH",
          "short_description": "This project aims to enhance the performance of the NetworkX library by parallelizing graph algorithms using the joblib backend in nx-parallel....",
          "slug": "adding-embarrassingly-parallel-graph-algorithms-in-nx-parallel",
          "status": "in-progress",
          "student_name": "Akshita Sure",
          "student_profile": null,
          "tags": [
            "ai",
            "backend"
          ],
          "title": "Adding embarrassingly parallel graph algorithms in nx-parallel"
        },
        {
          "code_url": null,
          "description": "State-space models (SSMs) provide a flexible framework for modeling dynamic systems where\nlatent states evolve over time. In econometrics, Dynamic Factor Models (DFMs) are widely\nused to capture the co-movement of multiple time series by assuming that a small number of\nlatent factors drive the observed variables. The PyMC library already includes implemen-\ntations of SARIMAX, VARMAX, and structural state-space models, along with example\nnotebooks for their usage. This project aims to extend the existing PyMC state-space module by implementing Dynamic Factor Models, aligning with the functionality available in\nstatsmodels. Our implementation will follow a Bayesian approach, leveraging PyMC’s probabilistic programming\nframework and PyTensor for computation. Additionally, an accompanying example notebook will demonstrate estimation, forecasting, and causal analysis with the new model,\nensuring accessibility for users.\nThis enhancement will significantly expand PyMC's capabilities, empowering student, practitioners and researchers in econometrics, macroeconomics, and beyond to model complex time-series data probabilistically.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2025_004",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/OU9piGFJ",
          "proposal_id": "FhdBlLOy",
          "short_description": "State-space models (SSMs) provide a flexible framework for modeling dynamic systems where latent states evolve over time. In econometrics, Dynamic...",
          "slug": "state-space-models-dynamic-factor-models",
          "status": "in-progress",
          "student_name": "Andrea Catelli",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "State-Space Models: Dynamic Factor Models"
        },
        {
          "code_url": null,
          "description": "This project focuses on implementing a versioning system for the DISCOVER Cookbook, enabling seamless navigation across distinct documentation editions via a dynamic, metadata-informed version-switching interface. Moreover, each version will support multiple languages, necessitating the development of both version and language switchers.\n\nLeveraging Git branches and an enhanced GitHub Actions deployment pipeline, the project will programmatically build and deploy versioned instances, ensuring persistent access to historical content alongside current revisions.\n\nThe user interface will include a dynamic version-switching mechanism and a context-aware notification banner to alert users when they are viewing outdated content.\n\nThis enhancement will improve the usability, maintainability, and accessibility of the Cookbook for both users and contributors, while providing maintainers with a scalable and transparent content management workflow.",
          "difficulty": null,
          "id": "proj_numfocus_2025_005",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/ovpNbdUa",
          "proposal_id": "TbjLxyav",
          "short_description": "This project focuses on implementing a versioning system for the DISCOVER Cookbook, enabling seamless navigation across distinct documentation...",
          "slug": "versioning-system-for-discover-cookbook",
          "status": "in-progress",
          "student_name": "Ashish Mahajan",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "Versioning System for DISCOVER Cookbook"
        },
        {
          "code_url": null,
          "description": "Stochastic dynamical systems play an important role in scientific and engineering domains, particularly in systems governed by Brownian motion or subject to random perturbations from the environment. Stochastic Differential Equations (SDEs) and Stochastic Partial Differential Equations (SPDEs) provide a mathematical framework to describe such complex stochastic behaviour. Understanding the hidden physics within these systems is pretty much essential for analyzing their stochastic and nonlinear dynamics.\n\nThe NeuralPDE package in the SciML ecosystem currently lacks documentation for its existing SDE Physics-Informed Neural Network (PINN) solver and does not yet support multidimensional SDEs and SPDEs. This project aims to document the existing solver while also extending it to include PINN solvers for multidimensional SDEs based on the Wiener expansion, which expresses stochastic solutions as spectral expansions in terms of a set of random basis functions. The proposed SDE PINN solver uses the Kosambi-Karhunen-Loève (KKL) expansion for the Wiener process to obtain finite-dimensional approximations, effectively transforming SDEs into rough path ODEs. These ODEs can then be solved using the standard loss function formulation of PINNs for ODEs.\n\nAs a natural extension, this approach can be generalized to SPDEs using the Polynomial Chaos Expansion (PCE), which extends the Wiener expansion to handle spatially distributed noise in stochastic systems. By developing and implementing these solvers, this project aims to enhance NeuralPDE's capabilities in solving high-dimensional stochastic systems, making it a more comprehensive tool for data-driven modelling and simulation of stochastic dynamical systems.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2025_006",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/SayjRFPs",
          "proposal_id": "QSu6ACOR",
          "short_description": "Stochastic dynamical systems play an important role in scientific and engineering domains, particularly in systems governed by Brownian motion or...",
          "slug": "multidimensional-sde-pinn-solvers",
          "status": "in-progress",
          "student_name": "Astitva Aggarwal",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Multidimensional SDE PINN solvers"
        },
        {
          "code_url": null,
          "description": "Time series forecasting is paramount in many domains, including finance, healthcare, energy, and climate science. This project suggests incorporating deep learning-based forecasting models—Informer, TCN, and DeepAR—into the aeon/tookit. The objectives are to construct an efficient and scalable framework for forecasting that accommodates top-performing models, is compatible with Aeon’s data management, and provides stable training, evaluation, and documentation. Through simplifying the\navailability of advanced forecasting software, the project would make it easier to utilize the toolkit to assist researchers with streamlined time series analysis.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2025_007",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/arjEn266",
          "proposal_id": "XgNTLDNe",
          "short_description": "Time series forecasting is paramount in many domains, including finance, healthcare, energy, and climate science. This project suggests incorporating...",
          "slug": "suborganization-aeon-project-3-forecasting-deep-learning-for-forecasting",
          "status": "in-progress",
          "student_name": "balgopal",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "SubOrganization: Aeon Project #3: Forecasting – Deep Learning for Forecasting"
        },
        {
          "code_url": null,
          "description": "Community detection is one of the most commonly used network analysis techniques. It is the process of grouping nodes of a network together based on their connections, with the scope of finding clusters which are more connected internally than externally. By uncovering these communities one can gain insight into how groups interact and how the network is organized. Community detection finds use in various scientific disciplines, including biology, neuroscience, sociology, and physics. \nThis project aims to develop a hands-on guide to community detection with python-igraph, tailored to empirical researchers who may only have limited network science experience. The guide will be delivered in the form of an interactive, executable document, and will include detailed code examples, case studies, and visual demonstrations of the main concepts of community detection. We will cover key ideas such as modularity, hierarchical clustering, consensus clustering, and overlapping communities. Additionally, we will provide brief descriptions of community detection methods and their tradeoffs, along with examples of visualization techniques.",
          "difficulty": null,
          "id": "proj_numfocus_2025_008",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/yD4aJtvm",
          "proposal_id": "vRD6VfmI",
          "short_description": "Community detection is one of the most commonly used network analysis techniques. It is the process of grouping nodes of a network together based on...",
          "slug": "community-detection-guide-with-igraph",
          "status": "in-progress",
          "student_name": "Bea Márton",
          "student_profile": null,
          "tags": [
            "python",
            "ai",
            "ui"
          ],
          "title": "Community detection guide with igraph"
        },
        {
          "code_url": null,
          "description": "The bayesplot package is a key tool in the Stan ecosystem for visualizing Bayesian analysis results. However, it currently lacks specialized visualizations for predictive checks of discrete and categorical outcomes, and some existing plots could be improved for better usability and accuracy. These limitations hinder researchers' ability to thoroughly validate their models against real-world data, particularly for discrete and bounded data types.\r\n\r\nThis project aims to expand and refine bayesplot by implementing new visualization techniques based on recommendations from Säilynoja et al. (2025). \r\n\r\nDeliverables:\r\nNew plotting functions integrated into bayesplot (e.g., ppc_density_bounded, calibration plots).\r\nEnhanced versions of existing functions (e.g., rootograms, residual plots).\r\nComprehensive documentation with examples and guides.\r\nUnit tests for robustness and edge cases.\r\nBlog posts tracking progress and showcasing new features.\r\n\r\nBy the end of the project, bayesplot will offer a more versatile and user-friendly toolkit for Bayesian model checking, strengthening its role in the Stan community. These improvements will empower researchers to diagnose and communicate model fit more effectively, advancing Bayesian workflows across disciplines like machine learning, statistics, and data science.",
          "difficulty": null,
          "id": "proj_numfocus_2025_009",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/wAdAD4kH",
          "proposal_id": "5XqxINgB",
          "short_description": "The bayesplot package is a key tool in the Stan ecosystem for visualizing Bayesian analysis results. However, it currently lacks specialized...",
          "slug": "creating-new-plots-with-bayesplot-stan",
          "status": "in-progress",
          "student_name": "Behram",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Creating New Plots with Bayesplot (Stan)"
        },
        {
          "code_url": null,
          "description": "Currently, the Cookbook has multiple resources that can help any event became inclusive and accessible to everyone. However, its accessibility remains limited due to its exclusive support for English. This language restriction creates a barrier for a global audience, preventing many from fully benefiting from its guidance.\nThis project aims to develop a comprehensive translation workflow for the DISCOVER Cookbook, enabling seamless multilingual support. A language selection mechanism will be integrated within the book, allowing users to easily switch between available translations. Additionally, an automated update system will be implemented to ensure translations remain synchronized as content evolves. To maintain high-quality translations, the project will engage and onboard community translators, fostering collaboration and sustainability in the translation process.",
          "difficulty": null,
          "id": "proj_numfocus_2025_010",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/iMKr9viy",
          "proposal_id": "isPHCAP2",
          "short_description": "Currently, the Cookbook has multiple resources that can help any event became inclusive and accessible to everyone. However, its accessibility...",
          "slug": "adding-translation-system-for-discover-cookbook",
          "status": "in-progress",
          "student_name": "Dia29",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "Adding Translation System for DISCOVER Cookbook"
        },
        {
          "code_url": null,
          "description": "The LiftOver2D project aims to develop a high-performance tool for converting Hi-C matrices between different genome assemblies and binning schemes. This functionality is essential for integrating data from various sources and experiments — especially with the growing popularity of multi-omics approaches and the increasing availability of public datasets. Existing solutions, such as HiCLift, offer partial support but often fail to provide an optimal balance between accuracy and performance, particularly in cases of partial bin mismatches or complex remapping scenarios.\n\nLiftOver2D seeks to overcome these limitations by leveraging background contact distributions at the bin level, allowing for more precise and efficient remapping. The main goal is to design a method that achieves an acceptable trade-off between accuracy and speed, ensuring the tool is practical for real-world bioinformatics pipelines without sacrificing data quality or runtime efficiency. During the project, we plan to develop a custom model for bin-level remapping and optimal bin-to-bin matching across genome assemblies, and test our tool on various experiments and organisms using publicly available data from open databases (such as NCBI GEO). We aim to maximize performance and parallelization using both high-level data frameworks (like Dask or Polars) and lower-level languages where appropriate. The resulting algorithm will be wrapped into convenient packages for Python, R, and the command line. We also plan to collaborate with major tools in the Hi-C ecosystem (such as Cooler or Muon for multimodal experiments) to integrate our functionality into widely-used frameworks.\n\nIn the long term, LiftOver2D aspires to become a community-standard solution for fast remapping of 2D genomic contact data. The development will be carried out as an open-source project in collaboration with the community and aligned with NumFOCUS’s mission to support sustainable scientific software.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2025_011",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/XnTtGYoC",
          "proposal_id": "7Tr5GXxw",
          "short_description": "The LiftOver2D project aims to develop a high-performance tool for converting Hi-C matrices between different genome assemblies and binning schemes....",
          "slug": "liftover2d-a-tool-for-converting-hi-c-matrices-across-assemblies-and-binning-schemes",
          "status": "in-progress",
          "student_name": "Egor Pitikov",
          "student_profile": null,
          "tags": [
            "python",
            "ios",
            "ai",
            "database"
          ],
          "title": "LiftOver2D: A Tool for Converting Hi-C Matrices Across Assemblies and Binning Schemes"
        },
        {
          "code_url": null,
          "description": "In the Python Spatial Analysis Library (pysal), the spopt package is concerned with the formulation and solving of various spatial optimization problems, particularly regionalization and location-based problems. This project proposes to enhance the spopt package with a route module, which will function as an API to set up and solve vehicle routing problems (VRP), including parameterizing vehicles, depots, and routes\nin various VRP setups.",
          "difficulty": null,
          "id": "proj_numfocus_2025_012",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/JhcSXfTK",
          "proposal_id": "GD0ipSN6",
          "short_description": "In the Python Spatial Analysis Library (pysal), the spopt package is concerned with the formulation and solving of various spatial optimization...",
          "slug": "pysal-produce-routing-engine-for-spopt",
          "status": "in-progress",
          "student_name": "fiendskrah",
          "student_profile": null,
          "tags": [
            "python",
            "api"
          ],
          "title": "[PYSAL] - Produce Routing Engine for `spopt`"
        },
        {
          "code_url": null,
          "description": "optimagic is a optimization library which aims to provide a unified interface to optimizers from SciPy, NlOpt and many other widely used packages. This project aims to add more optimizers specifically from ensmallen, PRIMA, Nevergrad, Bayesian Optimization, Knitro and if possible, others. I will implement each particular optimizer, reading the literature and official documentation related to each optimizer, and keeping in mind optimagic's core idea. The main goal is to wrap as many optimizers as possible, giving them a consistent interface with optimagic's minimize function. For users, this will mean more freedom while choosing and comparing optimizers that best suits their needs. This will involve writing well-tested code, tests, and benchmarking to further improve performance. Also, I will write documentation, how-to-guides and example notebooks to guide users using the library.",
          "difficulty": null,
          "id": "proj_numfocus_2025_013",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/j9i3Vx5T",
          "proposal_id": "zscWDapL",
          "short_description": "optimagic is a optimization library which aims to provide a unified interface to optimizers from SciPy, NlOpt and many other widely used packages....",
          "slug": "adding-more-optimizer-interfaces-to-optimagic",
          "status": "in-progress",
          "student_name": "gauravmanmode",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Adding More Optimizer Interfaces to optimagic"
        },
        {
          "code_url": null,
          "description": "This project aims to test the performance of |toqito⟩ and compare it with other quantum \ncomputing libraries. It is divided into three parts: (1) Comparing |toqito⟩ with libraries like \nPennyLane, Qiskit, etc. by running standardized tests inside Docker to ensure consistency \nacross different computers; (2) Automatic benchmarking using GitHub Actions, where \nperformance tests run on every update and results are stored for analysis; and (3) \nIdentifying slow parts of |toqito⟩ using cProfile, focusing on operations like matrix \ncalculations, quantum measurements, and random object generation. \n------------------------------------------------------------------------------\nDeliverables include:\n\n1. A new benchmark/ folder in |toqito⟩ that can run and store benchmarks, \nincluding support for running them in Docker. \n2. A system to track |toqito⟩’s performance over time using monthly benchmarks or \nwe can choose to run only relevant benchmarks after each merged PR. \n3. Found and suggested improvements for slow parts in at least one full module of \n|toqito⟩.",
          "difficulty": null,
          "id": "proj_numfocus_2025_014",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/5DqdhWwe",
          "proposal_id": "XPJ9Zkex",
          "short_description": "This project aims to test the performance of |toqito⟩ and compare it with other quantum computing libraries. It is divided into three parts: (1)...",
          "slug": "benchmarking-and-profiling-in-toqito",
          "status": "in-progress",
          "student_name": "justuy",
          "student_profile": null,
          "tags": [
            "ai",
            "docker"
          ],
          "title": "Benchmarking and Profiling in toqito"
        },
        {
          "code_url": null,
          "description": "This project aims to extend the capabilities of the ONNX-to-mlpack converter by adding support for more advanced and diverse model architectures. The focus will be on enabling the translation of complex ONNX computational graphs, including LSTM-based models and Directed Acyclic Graph (DAG) structures. Additionally, the project will introduce support for NLP models and incorporate foundational NLP components such as Word2Vec-based tokenizers, encoders and decoders in mlpack.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2025_015",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/57ne67Mj",
          "proposal_id": "I9KbneYo",
          "short_description": "This project aims to extend the capabilities of the ONNX-to-mlpack converter by adding support for more advanced and diverse model architectures. The...",
          "slug": "extending-onnx-mlpack-translator-with-advanced-model-support",
          "status": "in-progress",
          "student_name": "kumar utkarsh",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Extending ONNX-mlpack Translator with Advanced Model Support"
        },
        {
          "code_url": null,
          "description": "The project aims to enhance the functionality of optimagic by adding support for a wider range of numerical optimization libraries.The goal is to develop interfaces for optimizers from Bayesian Optimization, Nevergrad, PyGAD, DEAP, and PySwarms.",
          "difficulty": null,
          "id": "proj_numfocus_2025_016",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/kggF8GVK",
          "proposal_id": "CefkTUbv",
          "short_description": "The project aims to enhance the functionality of optimagic by adding support for a wider range of numerical optimization libraries.The goal is to...",
          "slug": "adding-more-optimizer-interfaces-to-optimagic",
          "status": "in-progress",
          "student_name": "madman",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Adding More Optimizer Interfaces to optimagic"
        },
        {
          "code_url": null,
          "description": "sbi is a Python package providing simulation-based inference tools for researchers and practitioners; given simulation results, sbi aims to infer the distribution of parameters of the phenomena under study. The sbi package lacks an implementation of the Simformer, a novel Transformer-based approach to simulation-based inference introduced by Gloeckler et al. (2024). This project aims to implement the Simformer in sbi using PyTorch, documenting the API produced, and providing tutorials and benchmarks for the sbi community to use the Simformer for their analysis.",
          "difficulty": null,
          "id": "proj_numfocus_2025_017",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/Joey5EeQ",
          "proposal_id": "2s4i7lWR",
          "short_description": "sbi is a Python package providing simulation-based inference tools for researchers and practitioners; given simulation results, sbi aims to infer the...",
          "slug": "implementing-the-simformer-for-sbi",
          "status": "in-progress",
          "student_name": "Massimiliano Carli",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai"
          ],
          "title": "Implementing the Simformer for sbi"
        },
        {
          "code_url": null,
          "description": "This project aims to implement the RUBI integration system - a powerful, open source, rule-based integration system developed for the computational software system Mathematica - in the julia package Symbolics.jl. The goal is to enhance Julia's symbolic computation capabilities, providing a faster and more comprehensive solution for symbolic integration.",
          "difficulty": null,
          "id": "proj_numfocus_2025_018",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/TRqpJPrm",
          "proposal_id": "p9SH8uh7",
          "short_description": "This project aims to implement the RUBI integration system - a powerful, open source, rule-based integration system developed for the computational...",
          "slug": "implementing-rubi-rule-based-integrator-in-the-julia-package-symbolicsjl",
          "status": "in-progress",
          "student_name": "Mattia Micheletta Merlin",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Implementing RUBI (Rule-based Integrator) in the Julia package Symbolics.jl"
        },
        {
          "code_url": null,
          "description": "This project will make the addition and sharing of third-party battery models easier in PyBaMM. It is an extension of the PyBaMM cookiecutter project of year 2024 and will include a Dispatch API, a single location to register models, and enhance model loading using entry points. The copier template will also be enhanced so that individuals with varying levels of experience will be able to use it more easily. By incorporating features such as dynamic model loading, caching, and enhanced documentation, the project will make it easier for more users and developers to work with external models and make PyBaMM more flexible and convenient to use in the long term.",
          "difficulty": null,
          "id": "proj_numfocus_2025_019",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/3t9McTvW",
          "proposal_id": "P1wcpcyH",
          "short_description": "This project will make the addition and sharing of third-party battery models easier in PyBaMM. It is an extension of the PyBaMM cookiecutter project...",
          "slug": "pybamm-adding-a-dispatching-mechanism-for-third-party-models",
          "status": "in-progress",
          "student_name": "Medha-Bhardwaj",
          "student_profile": null,
          "tags": [
            "api"
          ],
          "title": "PyBaMM - Adding a Dispatching Mechanism  for Third Party Models."
        },
        {
          "code_url": null,
          "description": "A key component of Bayesian inference is integrating over prior distributions to obtain posteriors. In practice however, these distributions are often high-dimensional, resulting in a significant computational cost associated with integration, which remains a key challenge in Bayesian ML. Under certain assumptions, it is possible to efficiently compute posteriors for Latent Gaussian Models (LGMs), which represent a broad class of statistical models in Bayesian statistics. This is known as the method of Integrated Nested Laplace Approximations (INLA), and this project aims to implement a working basis for INLA in the PyMC library.",
          "difficulty": null,
          "id": "proj_numfocus_2025_020",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/Djw07Zv0",
          "proposal_id": "AaC2yTpG",
          "short_description": "A key component of Bayesian inference is integrating over prior distributions to obtain posteriors. In practice however, these distributions are...",
          "slug": "implementing-integrated-nested-laplace-approximations-inla",
          "status": "in-progress",
          "student_name": "Michal Novomestsky",
          "student_profile": null,
          "tags": [
            "ml",
            "ai"
          ],
          "title": "Implementing Integrated Nested Laplace Approximations (INLA)"
        },
        {
          "code_url": null,
          "description": "This project addresses the need for enhanced usability and learning resources within the toqito quantum information library by creating a user-friendly example gallery, inspired by successful models like scikit-learn's. The core problem is the current lack of diverse, executable examples demonstrating toqito's capabilities in practical scenarios. The proposed solution involves developing the gallery's web infrastructure (potentially using Sphinx-Gallery) integrated into toqito's existing documentation, and populating it with high-quality, self-contained Python examples. Key deliverables include the functional gallery structure and 6 core examples demonstrating crucial toqito functionalities: modeling cryptographic protocols (Bit Commitment, QKD QBER) using ExtendedNonlocalGame, verifying state antidistinguishability thresholds from recent literature using the state_opt module, and illustrating channel properties (is_extremal) using channel_props. This gallery will significantly improve toqito's accessibility for researchers and new users, providing practical code and explanations for core quantum information concepts.",
          "difficulty": null,
          "id": "proj_numfocus_2025_021",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/lI08brT4",
          "proposal_id": "zWtvWyMX",
          "short_description": "This project addresses the need for enhanced usability and learning resources within the toqito quantum information library by creating a...",
          "slug": "create-and-add-to-an-example-gallery-for-toqito",
          "status": "in-progress",
          "student_name": "Nafisa Shamim Rafa",
          "student_profile": null,
          "tags": [
            "python",
            "ios",
            "web",
            "ai",
            "ui"
          ],
          "title": "Create and Add to an Example Gallery for toqito"
        },
        {
          "code_url": null,
          "description": "This project aims to enhance DeepForest by integrating and extending the active learning capabilities from Weecology/BOEM into its training pipeline. The goal is to enhance the efficiency and scalability of tree and bird detection in aerial imagery, enabling smarter sample selection and reduced annotation effort. By using advanced sampling strategies such as uncertainty-based and diversity-based selection, users will be able to automatically generate predictions, identify the most valuable samples for annotation, and streamline the entire labeling process. The project will also focus on building an intuitive workflow, writing clear documentation, ensuring strong test coverage, and creating user-friendly interfaces. Ultimately, this work will help reduce manual annotation efforts, speed up training, and improve model performance, making DeepForest more adaptable.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2025_022",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/n9Ophyn4",
          "proposal_id": "Zfi87i6M",
          "short_description": "This project aims to enhance DeepForest by integrating and extending the active learning capabilities from Weecology/BOEM into its training pipeline....",
          "slug": "developing-an-active-learning-module-for-deepforest",
          "status": "in-progress",
          "student_name": "Nakshatra Piplad",
          "student_profile": null,
          "tags": [
            "ml",
            "ai",
            "ui"
          ],
          "title": "Developing an Active Learning  Module for DeepForest"
        },
        {
          "code_url": null,
          "description": "Template Numerical Library (TNL) already includes several solvers for partial differential equations, such as the Finite Element Method (FEM), Lattice Boltzmann Method (LBM), and Smoothed Particle Hydrodynamics (SPH). However, it currently lacks native support for the Finite Volume Method (FVM), which I aim to implement. An FVM solver for the Navier-Stokes equations would make it possible to address a wide range of problems in computational fluid dynamics and aerospace.\n\nI plan to start by rewriting my 2D Euler equation solver from my Bachelor's thesis to work within TNL. Then, I’ll extend the implementation to support the Navier-Stokes equations in 2D, and finally in 3D, using an LU-SGS approach. In the final phase, I’ll focus on code optimization, documentation, and creating a clean, user-friendly interface.\n\nI plan to deliver a Finite Volume Method solver for the Euler equations in 2D integrated into TNL. This will be followed by an extension to support 2D Navier-Stokes equations, and finally, a 3D Navier-Stokes solver. The final code will be documented and unified with TNL's code standards.",
          "difficulty": null,
          "id": "proj_numfocus_2025_023",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/dLFOcSDt",
          "proposal_id": "wCElOp8v",
          "short_description": "Template Numerical Library (TNL) already includes several solvers for partial differential equations, such as the Finite Element Method (FEM),...",
          "slug": "finite-volume-method-implementation-for-tnl",
          "status": "in-progress",
          "student_name": "Petr Sokol",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Finite Volume Method Implementation for TNL"
        },
        {
          "code_url": null,
          "description": "Seeing the current increasing demand of high performance batteries, accurate thermal modelling of battery behaviour is essential.\n\nThis project extends PyBaMM by adding the capability to simulate battery temperature in three dimensions. It starts by developing a 3D thermal model for batteries using existing 3D mesh and discretization tools, initially assuming a constant heat source. This thermal model is then coupled with existing battery models (like the SPM or DFN) so that the heat generated during battery operation can be simulated.\nThe model will also eventually allow temperature data from the thermal simulation to feed back into the battery model, enabling more realistic, two-way interactions. \n\nAs an advanced goal, the project will integrate detailed 3D temperature profiles from a spirally wound battery design into the electrochemical model, which will lay the groundwork for more complex and accurate battery simulations.",
          "difficulty": "advanced",
          "id": "proj_numfocus_2025_024",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/epbg9kwP",
          "proposal_id": "z6jK4f0y",
          "short_description": "Seeing the current increasing demand of high performance batteries, accurate thermal modelling of battery behaviour is essential. This project...",
          "slug": "adding-a-spirally-wound-geometry-for-thermal-simulations-in-pybamm",
          "status": "in-progress",
          "student_name": "Rishab87",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Adding a spirally wound geometry for thermal simulations in PyBaMM"
        },
        {
          "code_url": null,
          "description": "This project aims to create a benchmark dataset for tree species classification using multi-sensor airborne data (RGB, HSI, and LiDAR) from the National Ecological Observatory Network (NEON). The goal is to build a reproducible, well-documented dataset of hand-annotated tree crowns and use it to train baseline models for each modality individually and in combination. Alongside this, we’ll explore integration with DeepForest to support crown detection and classification workflows.\n\nDeliverables:\n1. A finalized, curated data product for tree species classification using NEON data added to TorchGeo.\n2. Baseline models for each modality and multi-modal combinations.\n3. Reproducible training pipelines and clear documentation.\n4. A utility to simplify NEON data access.\n5. Integration work and documentation linking this effort with DeepForest.",
          "difficulty": null,
          "id": "proj_numfocus_2025_025",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/nrEEuvuB",
          "proposal_id": "i3yTem2k",
          "short_description": "This project aims to create a benchmark dataset for tree species classification using multi-sensor airborne data (RGB, HSI, and LiDAR) from the...",
          "slug": "data-retriever-creating-a-multi-sensor-airborne-benchmark-for-tree-species-classification",
          "status": "in-progress",
          "student_name": "Ritesh Chowdhry",
          "student_profile": null,
          "tags": [
            "ai",
            "ui"
          ],
          "title": "Data Retriever: Creating a multi-sensor airborne benchmark for Tree Species classification"
        },
        {
          "code_url": null,
          "description": "This project attempts to integrate DeepForest's object detection models into Large Language Models (LLMs) so that ecological images can be queried using natural language. Building on the pre-built models in DeepForest for tree, bird, and livestock detection, the system would extract structured annotations from images and convert them to an LLM-compatible format. Users can interact with an image through a queryable interface and receive proper responses based on object detection and spatial reasoning. This will involve prompt engineering, fine-tuning and experimentation with different LLMs.",
          "difficulty": null,
          "id": "proj_numfocus_2025_026",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/ItYAp7By",
          "proposal_id": "3UTR8SA4",
          "short_description": "This project attempts to integrate DeepForest's object detection models into Large Language Models (LLMs) so that ecological images can be queried...",
          "slug": "integrating-deepforest-object-detection-with-llm-for-automated-ecological-image-analysis",
          "status": "in-progress",
          "student_name": "Samia Haque Tisha",
          "student_profile": null,
          "tags": [
            "ui"
          ],
          "title": "Integrating DeepForest Object Detection with LLM for Automated Ecological Image Analysis"
        },
        {
          "code_url": null,
          "description": "ArviZ is a Python library for the exploratory analysis of Bayesian inference models. It is currently undergoing a major refactor into a modular structure comprising three sub-packages: arviz-base, arviz-stats, and arviz-plots. This refactoring brings changes to both the API and the internal implementation, with most of the design decisions already in place. The primary task that remains is migrating and reimplementing existing features from legacy ArviZ into the new structure.\n\nThis project focuses on achieving feature parity in arviz-plots by reintroducing essential visualization tools from the original ArviZ while also enhancing them with new capabilities. These include plots for MCSE, t-statistics, parallel coordinates, quantile dot plots, support for circular variables in trace plots and rank distribution plots, among others. Additionally, new features such as a dark theme and improved rank plots with better envelopes for multiple sample comparisons will be incorporated.\n\nThe goal is to implement and rigorously test these plotting functions, which are critical for model comparison, criticism, and sampling diagnostics. By ensuring that arviz-plots matches and improves upon the original functionality, this project will enhance the usability, maintainability, and extensibility of ArviZ. Ultimately, it will help strengthen ArviZ’s position as a go-to library for Bayesian model visualization and diagnostics.",
          "difficulty": null,
          "id": "proj_numfocus_2025_027",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/QEEVWGcd",
          "proposal_id": "HGRFMu2T",
          "short_description": "ArviZ is a Python library for the exploratory analysis of Bayesian inference models. It is currently undergoing a major refactor into a modular...",
          "slug": "arviz-plots-feature-parity",
          "status": "in-progress",
          "student_name": "Shreyansh868",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai"
          ],
          "title": "ArviZ Plots Feature Parity"
        },
        {
          "code_url": null,
          "description": "This project will investigate algorithms for forecasting based on traditional machine learning (tree based) and time series machine learning (transformation based). It will involve helping develop the aeon framework to process both standard ML and extrisnic regression algorithms for forecasting. This will involve evaluating regression algorithms already in `aeon` for forecasting problems as well as `scikit-learn` regressors. The tree-based SETAR-Tree and SETAR-Forest algorithms will also be implemented in the forecasting module.",
          "difficulty": null,
          "id": "proj_numfocus_2025_028",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/MPYRSOTi",
          "proposal_id": "Xw5VtsDR",
          "short_description": "This project will investigate algorithms for forecasting based on traditional machine learning (tree based) and time series machine learning...",
          "slug": "aeon-implementing-and-evaluating-machine-learning-forecasters",
          "status": "in-progress",
          "student_name": "Tina0228",
          "student_profile": null,
          "tags": [
            "ml"
          ],
          "title": "aeon - Implementing and Evaluating Machine Learning Forecasters"
        },
        {
          "code_url": null,
          "description": "This project aims to develop a comprehensive Hamiltonian Library for QuTiP (Quantum Toolbox in Python). Currently, QuTiP users must frequently recreate common quantum system Hamiltonians from scratch, leading to redundant work and inconsistencies. The library will provide ready-to-use implementations of frequently used quantum systems like Jaynes-Cummings, Rabi, Dicke, and various spin-chain models. Key features include a standardised API, JSON serialisation for cross-platform compatibility, time-dependent parameter support, and LaTeX representation capabilities. The deliverables include a core Hamiltonian base class, at least 10 implemented quantum models, comprehensive documentation, tutorials, and full integration with QuTiP's existing functionality. This project will significantly enhance user experience and reduce redundancy in quantum simulations.",
          "difficulty": null,
          "id": "proj_numfocus_2025_029",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/TgdXdTXP",
          "proposal_id": "T5zlMdzC",
          "short_description": "This project aims to develop a comprehensive Hamiltonian Library for QuTiP (Quantum Toolbox in Python). Currently, QuTiP users must frequently...",
          "slug": "hamiltonian-library-for-qutip",
          "status": "in-progress",
          "student_name": "VanshajB",
          "student_profile": null,
          "tags": [
            "python",
            "api",
            "ai"
          ],
          "title": "Hamiltonian Library for QuTiP"
        },
        {
          "code_url": null,
          "description": "The `loo` package is a widely used R package in the Stan ecosystem which exposes a clean API to cross-validate (CV) Bayesian models. As new CV methods and diagnostics are created and adopted by the field, the `loo` package must be updated to support them. Currently different predictive performance measures have different APIs and varying level of supported features. This project is focused on refactoring the API to unify the support for different predictive measures to make all useful features available for all predictive measures to make it easier for the modellers to use the most appropriate measures for their applications.\n\nKey technical components will include creating a flexible object which can report multiple metrics and scores. Additionally, we need to create functions to support model comparisons for all these scores and metrics. We will also allow for measures besides log score for LOO-CV to be used under the same, unified interface as existing options and create a consistent loo object for all measures. We will further unify the interface by allowing for non-log score measures for in-sample, test data, and K-fold-CV use cases. We will also be extending the model comparison functions to carry forward information on what measure is being compared, diagnostic data, and information on how to calculate the standard error (SE) of the differences of various measures.",
          "difficulty": null,
          "id": "proj_numfocus_2025_030",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/NxqejlhZ",
          "proposal_id": "F8mxdlIA",
          "short_description": "The `loo` package is a widely used R package in the Stan ecosystem which exposes a clean API to cross-validate (CV) Bayesian models. As new CV...",
          "slug": "extending-the-loo-package",
          "status": "in-progress",
          "student_name": "Visruth",
          "student_profile": null,
          "tags": [
            "api",
            "ai"
          ],
          "title": "Extending the loo Package"
        },
        {
          "code_url": null,
          "description": "Graphs are powerful tools for understanding relationships and structures — from social media connections to brain networks. Often, we want to study whether these structures exhibit unusual features. To do so, we compare the graph in question to a \"baseline\" or \"generic\" graph, called a null model; this gives us a point of reference to identify whether the features we see are truly unusual or simply a result of random chance. \n\nAs such, the goal of this project is to expand the igraph library's ability to work with null models. Given a set of characteristics about a graph, we want to make it more flexible to 1) check whether a graph with these characteristics exist (graphicality), 2) create a graph with these characteristics (construction), and 3) derive other graphs that share the same characteristics (rewiring). \n\nWith more flexible and performant tools for working with null models, igraph can better support the network science underpinning so many scientific domains.",
          "difficulty": null,
          "id": "proj_numfocus_2025_031",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/q04crkoi",
          "proposal_id": "ui2N1vyT",
          "short_description": "Graphs are powerful tools for understanding relationships and structures — from social media connections to brain networks. Often, we want to study...",
          "slug": "igraph-degree-constrained-null-models-graph-construction",
          "status": "in-progress",
          "student_name": "Zara Zong",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "igraph | Degree-Constrained Null Models & Graph Construction"
        },
        {
          "code_url": null,
          "description": "This project aims to extend PySAL's spatial optimisation library (spopt) by implementing flow-based facility location models, specifically the Flow Refueling Location Model and the Deviated Flow Refueling Location Model. While spopt currently includes various node-based location optimisation models, it lacks flow-based models that are crucial for transportation infrastructure planning. The proposed implementation will include comprehensive data processing components for network and flow data, core optimisation model implementations with solver integration, and output processing tools for visualisation and analysis.",
          "difficulty": null,
          "id": "proj_numfocus_2025_032",
          "mentor_names": [],
          "project_url": "https://summerofcode.withgoogle.com/programs/2025/projects/rCb85IXn",
          "proposal_id": "pi6dq8ii",
          "short_description": "This project aims to extend PySAL's spatial optimisation library (spopt) by implementing flow-based facility location models, specifically the Flow...",
          "slug": "proposal-for-pysal-spopt",
          "status": "in-progress",
          "student_name": "ZixinFeng",
          "student_profile": null,
          "tags": [
            "ai"
          ],
          "title": "Proposal for PYSAL– SPOPT"
        }
      ],
      "projects_url": "https://summerofcode.withgoogle.com/programs/2025/organizations/numfocus"
    }
  },
  "first_time": false,
  "contact": {
    "email": "info@numfocus.org",
    "guide_url": "https://github.com/numfocus/gsoc/blob/master/CONTRIBUTING-students.md",
    "ideas_url": "https://github.com/numfocus/gsoc/blob/master/2025/ideas-list.md",
    "irc_channel": null,
    "mailing_list": "https://groups.google.com/a/numfocus.org/forum/#!forum/gsoc"
  },
  "social": {
    "blog": "http://www.numfocus.org/blog",
    "discord": null,
    "facebook": null,
    "github": null,
    "gitlab": null,
    "instagram": null,
    "linkedin": null,
    "mastodon": null,
    "medium": null,
    "reddit": null,
    "slack": null,
    "stackoverflow": null,
    "twitch": null,
    "twitter": "https://twitter.com/NumFOCUS/",
    "youtube": null
  },
  "meta": {
    "version": 1,
    "generated_at": "2026-01-25T15:28:53.780Z"
  }
}